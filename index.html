<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">279</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">118</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">385</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">385</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">118</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">279</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3633eb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3633eb/" class="post-title-link" itemprop="url">安全漏洞防护</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-16 15:51:30" itemprop="dateCreated datePublished" datetime="2022-11-16T15:51:30+08:00">2022-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="安全漏洞防护"><a href="#安全漏洞防护" class="headerlink" title="安全漏洞防护"></a>安全漏洞防护</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong><code>跨站脚本（Cross-site scripting，通常简称为XSS）</code></strong> 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。</p>
<p>XSS 攻击示例：</p>
<p>假如有下面一个 textbox</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;address1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1from&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>value1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 <code>&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</code> 那么就会变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;address1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;!- &quot;&gt;</span><br></pre></td></tr></table></figure>

<p>嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。</p>
<h3 id="攻击手段和目的"><a href="#攻击手段和目的" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h3><p>常用的 XSS 攻击手段和目的有：</p>
<ul>
<li>盗用 cookie，获取敏感信息。</li>
<li>利用植入 Flash，通过 <code>crossdomain</code> 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。</li>
<li>利用 <code>iframe</code>、<code>frame</code>、<code>XMLHttpRequest</code> 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>
<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>
<li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。</li>
</ul>
<h3 id="应对手段"><a href="#应对手段" class="headerlink" title="应对手段"></a>应对手段</h3><ul>
<li><strong>过滤特殊字符</strong> - 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如 <code>&gt;</code> 转义为 <code>&amp;gt</code>、<code>&lt;</code> 转义为 <code>&amp;lt</code> 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 <code>3&lt;5</code> 中的 <code>&lt;</code> 需要进行文本匹配后再转移，如：<code>&lt;img src=</code> 这样的上下文中的 <code>&lt;</code> 才转义。</li>
<li><strong>设置 Cookie 为 HttpOnly</strong> - 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">Wiki 词条 - 跨站脚本</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html">Web 安全测试之 XSS</a></li>
</ul>
</blockquote>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>**<code>跨站请求伪造（Cross-site request forgery，CSRF）</code>**，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<h3 id="攻击手段和目的-1"><a href="#攻击手段和目的-1" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h3><p>可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。</p>
<p>CSRF 能做的事太多：</p>
<ul>
<li>以你名义发送邮件，发消息</li>
<li>用你的账号购买商品</li>
<li>用你的名义完成虚拟货币转账</li>
<li>泄露个人隐私</li>
<li>…</li>
</ul>
<h3 id="应对手段-1"><a href="#应对手段-1" class="headerlink" title="应对手段"></a>应对手段</h3><ul>
<li><strong>表单 Token</strong> - CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。</li>
<li><strong>验证码</strong> - 请求提交时，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。</li>
<li><strong>Referer check</strong> - HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">Wiki 词条 - 跨站请求伪造</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅谈 CSRF 攻击方式</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22521378">「每日一题」CSRF 是什么？</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22521378">「每日一题」CSRF 是什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/855395f9603b">WEB 安全之-CSRF（跨站请求伪造）</a></li>
</ul>
</blockquote>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>**<code>SQL 注入攻击（SQL injection）</code>**，是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p>
<p>攻击示例：</p>
<p>考虑以下简单的登录表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们的处理里面的 SQL 可能是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username:<span class="operator">=</span>r.Form.Get(&quot;username&quot;)</span><br><span class="line">password:<span class="operator">=</span>r.Form.Get(&quot;password&quot;)</span><br><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM user WHERE username=&#x27;&quot;<span class="operator">+</span>username<span class="operator">+</span>&quot;&#x27; AND password=&#x27;&quot;<span class="operator">+</span>password<span class="operator">+</span>&quot;&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>如果用户的输入的用户名如下，密码任意</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myuser<span class="string">&#x27; or &#x27;</span>foo<span class="string">&#x27; = &#x27;</span>foo<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure>

<p>那么我们的 SQL 变成了如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;foo&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;foo&#x27;</span> <span class="comment">--&#x27;&#x27; AND password=&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 SQL 里面 <code>--</code> 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p>
<p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM products WHERE name LIKE &#x27;%&quot;<span class="operator">+</span>prod<span class="operator">+</span>&quot;%&#x27;&quot;</span><br><span class="line">Db.Exec(<span class="keyword">sql</span>)</span><br></pre></td></tr></table></figure>

<p>如果攻击提交 <code>a%&#39; exec master..xp_cmdshell &#39;net user test testpass /ADD&#39; --</code> 作为变量 prod 的值，那么 sql 将会变成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM products WHERE name LIKE &#x27;%a%&#x27; exec master..xp_cmdshell &#x27;net user test testpass /ADD&#x27;--%&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p>
<p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p>
<h3 id="攻击手段和目的-2"><a href="#攻击手段和目的-2" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h3><ul>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如 <code>SELECT * FROM sys.tables</code>）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如 <code>ALTER LOGIN sa WITH PASSWORD=&#39;xxxxxx&#39;</code>）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin”可停止服务器的 IIS 服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。</li>
</ul>
<h3 id="应对手段-2"><a href="#应对手段-2" class="headerlink" title="应对手段"></a>应对手段</h3><ul>
<li><strong>使用参数化查询</strong> - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database&#x2F;sql 里面的查询函数 <code>Prepare</code> 和 <code>Query</code> ，或者 <code>Exec(query string, args ...interface&#123;&#125;)</code>。</li>
<li><strong>单引号转换</strong> - 在组合 SQL 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A">Wiki 词条 - SQL 注入攻击</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md">避免 SQL 注入</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jobbole.com/83092/">实例讲解 SQL 注入攻击</a></li>
</ul>
</blockquote>
<h2 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h2><p>**<code>拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击</code>**，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。</p>
<h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><ul>
<li>带宽消耗型攻击</li>
<li>资源消耗型攻击</li>
</ul>
<h3 id="应对手段-3"><a href="#应对手段-3" class="headerlink" title="应对手段"></a>应对手段</h3><ul>
<li><strong>防火墙</strong> - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。</li>
<li><strong>路由器、交换机</strong> - 具有速度限制和访问控制能力。</li>
<li><strong>流量清洗</strong> - 通过采用抗 DoS 软件处理，将正常流量和恶意流量区分开。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A">拒绝服务攻击</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6236e0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6236e0/" class="post-title-link" itemprop="url">认证设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-15 18:04:17" itemprop="dateCreated datePublished" datetime="2022-11-15T18:04:17+08:00">2022-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="认证设计"><a href="#认证设计" class="headerlink" title="认证设计"></a>认证设计</h1><h2 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h2><h3 id="什么是认证"><a href="#什么是认证" class="headerlink" title="什么是认证"></a>什么是认证</h3><p><strong>认证 (Authentication)</strong> 是根据凭据验明访问者身份的流程。即验证“你是你所说的那个人”的过程。</p>
<p>身份认证，通常通过用户名&#x2F;邮箱&#x2F;手机号以及密码匹配来完成，也可以通过手机&#x2F;邮箱验证码或者生物特征（如：指纹、虹膜）等其他因素。在某些应用系统中，为了追求更高的安全性，往往会要求多种认证因素叠加使用，这就是我们经常说的多因素认证。</p>
<p>常见的认证方式</p>
<ul>
<li>用户名、密码认证</li>
<li>手机和短信验证码认证</li>
<li>邮箱和邮件验证码认证</li>
<li>人脸识别、指纹识别等生物因素认证</li>
<li>令牌认证</li>
<li>OTP 认证</li>
<li>Radius 网络认证</li>
</ul>
<h3 id="什么是授权"><a href="#什么是授权" class="headerlink" title="什么是授权"></a>什么是授权</h3><p><strong>授权 (Authorization)</strong> 是指向经过身份认证的访问者授予执行某项操作的权限（如访问资源，执行文件&#x2F;数据读写权限等）。 简言之，授权是验证“你被允许做你想做的事”的过程。</p>
<p>虽然授权通常在身份验证后立即发生（例如，登录计算机系统时），但这并不意味着授权以身份验证为前提：匿名代理可以被授权执行有限的操作集。</p>
<h2 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h2><p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
<p>Cookie 实际上是存储在客户端上的文本信息，并保留了各种跟踪的信息。</p>
<p>Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p>
<ul>
<li><a href="https://dunwu.github.io/waterdrop/pages/c46bff/">Cookie 和 Session</a></li>
<li><a href="https://dunwu.github.io/waterdrop/pages/95e45f/">分布式会话</a></li>
</ul>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p><strong>SSO(Single Sign On)，即单点登录</strong>。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。</p>
<p>SSO 需要解决多个异构系统之间的问题：</p>
<ul>
<li>Session 共享问题</li>
<li>跨域问题</li>
</ul>
<h3 id="Session-共享问题"><a href="#Session-共享问题" class="headerlink" title="Session 共享问题"></a>Session 共享问题</h3><p>分布式 Session 的几种实现策略：</p>
<ul>
<li>粘性 Session - 缺点：当<strong>服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</li>
<li>应用服务器间的 Session 复制共享 - 缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</li>
<li>基于缓存的 Session 共享 ✅ （推荐方案） - 不过需要程序自身控制 Session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。</li>
</ul>
<blockquote>
<p>详情请参考：<a href="../theory/distributed-session.md">Session 原理</a></p>
</blockquote>
<h3 id="Cookie-跨域"><a href="#Cookie-跨域" class="headerlink" title="Cookie 跨域"></a>Cookie 跨域</h3><p><strong>Cookie 不能跨域</strong>！比如：浏览器不会把 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 的 cookie 传给 <a target="_blank" rel="noopener" href="http://www.baidu.com./">www.baidu.com。</a></p>
<p>这就存在一个问题：由于域名不同，用户在系统 A 登录后，浏览器记录系统 A 的 Cookie，但是访问系统 B 的时候不会携带这个 Cookie。</p>
<p>针对 <strong>Cookie 不能跨域</strong> 的问题，有几种解决方案：</p>
<ul>
<li>服务端生成 Cookie 后，返回给客户端，客户端解析 Cookie ，提取 Token （比如 JWT），此后每次请求都携带这个 Token。</li>
<li>多个域名共享 Cookie，在返回 Cookie 给客户端的时候，在 Cookie 中设置 domain 白名单。</li>
<li>将 Token 保存在 <strong><code>SessionStroage</code></strong> 中（不依赖 Cookie 就没有跨域的问题了）。</li>
</ul>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 是实现 SSO 的主流方式。</p>
<p>CAS 分为两部分，CAS Server 和 CAS Client</p>
<ul>
<li><strong><code>CAS Server</code></strong> - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。</li>
<li><strong><code>CAS Client</code></strong> - 业务应用，需要接入 CAS Server。当用户访问我们的应用时，首先需要重定向到 CAS Server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。</li>
</ul>
<p>术语：</p>
<ul>
<li><strong><code>Ticket Granting Ticket (TGT)</code></strong> - 可以认为是 CAS Server 根据用户名、密码生成的一张票，存在 Server 端。</li>
<li><strong><code>Ticket Granting Cookie (TGC)</code></strong> - 其实就是一个 Cookie，存放用户身份信息，由 Server 发给 Client 端。</li>
<li><strong><code>Service Ticket (ST)</code></strong> - 由 TGT 生成的一次性票据，用于验证，只能用一次。</li>
</ul>
<p>CAS 工作流程：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200119195646.png" alt="img"></p>
<ol>
<li>用户访问 CAS Client A（业务系统），第一次访问，重定向到认证服务中心（CAS Server）。CAS Server 发现当前请求中没有 Cookie，再重定向到 CAS Server 的登录页面。重定向请求的 URL 中包含访问地址，以便认证成功后直接跳转到访问页面。</li>
<li>用户在登录页面输入用户名、密码等认证信息，认证成功后，CAS Server 生成 TGT，再用 TGT 生成一个 ST。然后返回 ST 和 TGC（Cookie）给浏览器。</li>
<li>浏览器携带 ST 再度访问之前想访问的 CAS Client A 页面。</li>
<li>CAS Client A 收到 ST 后，向 CAS Server 验证 ST 的有效性。验证通过则允许用户访问页面。</li>
<li>此时，如果登录另一个 CAS Client B，会先重定向到 CAS Server，CAS Server 可以判断这个 CAS Client B 是第一次访问，但是本地有 TGC，所以无需再次登录。用 TGC 创建一个 ST，返回给浏览器。</li>
<li>重复类似 3、4 步骤。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200119202448.png" alt="img"></p>
<p>以上了归纳总结如下：</p>
<ol>
<li><strong>访问服务</strong> - 用户访问 SSO Client 资源。</li>
<li><strong>定向认证</strong> - SSO Client 重定向用户请求到 SSO Server。</li>
<li><strong>用户认证</strong> - 用户身份认证。</li>
<li><strong>发放票据</strong> - SSO Server 会产生一个 Service Ticket (ST) 并返回给浏览器。</li>
<li><strong>验证票据</strong> - 浏览器每次访问 SSO Client 时，携带 ST，SSO Client 向 SSO Server 验证票据。只有验证通过，才允许访问。</li>
<li><strong>传输用户信息</strong> - SSO Server 验证票据通过后，传输用户认证结果信息给 SSO Client。</li>
</ol>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token (JWT，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519">RFC 7519 (opens new window)</a>)，是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519)。该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p>
<p>详细内容可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/576dbf44b2ae">什么是 JWT (opens new window)</a>。</p>
<h2 id="Oauth2-0"><a href="#Oauth2-0" class="headerlink" title="Oauth2.0"></a>Oauth2.0</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> 是一个关于授权（Authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。</p>
<p>简单来说，<strong>OAuth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。</p>
<p>OAuth 2.0 定义了四种授权方式。</p>
<ul>
<li><strong>授权码模式（authorization code）</strong></li>
<li><strong>简化模式（implicit）</strong></li>
<li><strong>密码模式（resource owner password credentials）</strong></li>
<li><strong>客户端模式（client credentials）</strong></li>
</ul>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<h3 id="隐藏模式"><a href="#隐藏模式" class="headerlink" title="隐藏模式"></a>隐藏模式</h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<h3 id="客户端凭证模式"><a href="#客户端凭证模式" class="headerlink" title="客户端凭证模式"></a>客户端凭证模式</h3><p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p>
<h3 id="令牌的更新"><a href="#令牌的更新" class="headerlink" title="令牌的更新"></a>令牌的更新</h3><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致</li>
</ul>
<h2 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h2><h3 id="ID-Token"><a href="#ID-Token" class="headerlink" title="ID Token"></a>ID Token</h3><p>ID Token 相当于用户的身份凭证，开发者的前端访问后端接口时可以携带 ID Token，开发者服务器可以校验用户的 ID Token 以确定用户身份，验证通过后返回相关资源。</p>
<p><strong>ID Token</strong> 本质上是一个 <a target="_blank" rel="noopener" href="https://docs.authing.cn/v2/concepts/jwt-token.html"><code>JWT Token</code></a>，包含了该用户身份信息相关的 key&#x2F;value 键值对，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://server.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24400320&quot;</span><span class="punctuation">,</span> <span class="comment">// subject 的缩写，为用户 ID</span></span><br><span class="line">   <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s6BhdRkqt3&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;n-0S6_WzA2Mj&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1311281970</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1311280970</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;auth_time&quot;</span><span class="punctuation">:</span> <span class="number">1311280969</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;acr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;urn:mace:incommon:iap:silver&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>ID Token 本质上是一个 JWT Token 意味着：</p>
<p>用户的身份信息直接被编码进了 id_token，你不需要额外请求其他的资源来获取用户信息；</p>
<p>id_token 可以验证其没有被篡改过，详情请见如何验证 ID Token。</p>
<h3 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h3><p>Access Token 用于基于 Token 的认证模式，允许应用访问一个资源 API。用户认证授权成功后，认证系统会签发 Access Token 给应用。应用需要<strong>携带 Access Token</strong> 访问资源 API，资源服务 API 会通过拦截器查验 Access Token 中的 <code>scope</code> 字段是否包含特定的权限项目，从而决定是否返回资源。</p>
<p>如果你的用户通过社交账号登录，例如微信登录，微信作为身份提供商会颁发自己的 Access Token，你的应用可以利用 Access Token 调用微信相关的 API。这些 Access Token 是由社交账号服务方控制的，格式也是任意的。</p>
<h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>AccessToken 和 IdToken 是 JSON Web Token (opens new window)，有效时间通常较短。通常用户在获取资源的时候需要携带 AccessToken，当 AccessToken 过期后，用户需要获取一个新的 AccessToken。</p>
<p>Refresh Token 用于获取新的 AccessToken。这样可以缩短 AccessToken 的过期时间保证安全，同时又不会因为频繁过期重新要求用户登录。</p>
<p>用户在初次认证时，Refresh Token 会和 AccessToken、IdToken 一起返回。你的应用必须安全地存储 Refresh Token，它的重要性和密码是一样的，因为 Refresh Token 能够一直让用户保持登录。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.rfcreader.com/#rfc6749">RFC 6749</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解 OAuth 2.0</a></li>
<li><a target="_blank" rel="noopener" href="https://darutk.medium.com/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb">The Simplest Guide To OAuth 2.0</a></li>
<li><a target="_blank" rel="noopener" href="https://openid.net/specs/openid-connect-core-1_0.html">OIDC 规范</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/576dbf44b2ae">什么是 JWT</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/05473f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/05473f/" class="post-title-link" itemprop="url">授权设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-15 17:48:06" itemprop="dateCreated datePublished" datetime="2022-11-15T17:48:06+08:00">2022-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="授权设计"><a href="#授权设计" class="headerlink" title="授权设计"></a>授权设计</h1><h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><p>最简单的授权形式可能是根据是否已对发出请求的实体进行身份验证来授予或拒绝访问权限。 如果请求者可证明自己是所自称的身份，则可访问受保护的资源或功能。</p>
<p>常见的授权模式有以下几种：</p>
<ul>
<li><strong>ACL</strong>：ACL 即 <strong>通过访问控制列表</strong>。ACL 进行的授权涉及到维护明确的特定实体列表，这些实体有权或无权访问资源或功能。 ACL 提供对身份验证即授权的精细控制，但管理工作会随着实体数量的增加而变得困难。</li>
<li><strong>RBAC</strong>：RBAC 即 <strong>基于角色的权限控制（Role-Based Access Control）</strong>。RBAC 应该是最常见的授权模式。 使用 RBAC 时，会对角色进行定义，以说明实体可执行的活动类型。 应用程序开发人员向角色而非单个实体授予访问权限。 然后，管理员可再将角色分配给不同的实体，从而控制哪些实体有权访问哪些资源和功能。在高级 RBAC 实现中，可将角色映射到权限集合，其中权限描述了可执行的细化操作或活动。 然后，会将角色配置为权限组合。 通过将授予给为实体分配的各种角色的权限进行相交，计算实体的总体权限集。</li>
<li><strong>ABAC</strong>：ABAC 即 <strong>基于属性的访问控制</strong> 是一种更精细的访问控制机制。在此方法中，规则应用于实体、所访问的资源和当前环境。 这些规则用于确定对资源和功能的访问级别。 例如，可能只允许拥有管理员身份的用户在工作日上午 9 点至下午 5 点期间访问使用元数据标记“仅限工作时间的管理员”标识的文件。 在这种情况下，通过检查用户的属性（状态为管理员）、资源属性（文件上的元数据标记）以及环境属性（当前时间）来确定访问权限。<ul>
<li>ABAC 的优点：可通过规则和条件评估实现更精细的动态访问控制，而无需创建大量特定的角色和 RBAC 分配。</li>
</ul>
</li>
</ul>
<h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p><strong>RBAC（Role-Based Access Control）即：基于角色的权限控制</strong>。通过角色关联用户，角色关联权限的方式间接赋予用户权限。</p>
<p>每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 RBAC 就是：用户关联角色，角色关联权限。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200119210359.png" alt="img"></p>
<p>角色继承(Hierarchical Role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200119210528.png" alt="img"></p>
<h3 id="职责分离-Separation-of-Duty"><a href="#职责分离-Separation-of-Duty" class="headerlink" title="职责分离(Separation of Duty)"></a>职责分离(Separation of Duty)</h3><p>为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 RBAC 被提出。</p>
<p>职责分离有两种模式：</p>
<p>静态职责分离(Static Separation of Duty)：用户无法同时被赋予有冲突的角色。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/594774-feb7c1074d151113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img"></p>
<p>动态职责分离(Dynamic Separation of Duty)：用户在一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/594774-059b93e4209e8fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/397/format/webp" alt="img"></p>
<p>讲了这么多 RBAC，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。</p>
<h3 id="RBAC0-模型"><a href="#RBAC0-模型" class="headerlink" title="RBAC0 模型"></a>RBAC0 模型</h3><p>最简单的用户、角色、权限模型。这里面又包含了 2 种：</p>
<ol>
<li>用户和角色是多对一关系，即：一个用户只充当一种角色，一种角色可以有多个用户担当。</li>
<li>用户和角色是多对多关系，即：一个用户可同时充当多种角色，一种角色可以有多个用户担当。</li>
</ol>
<p>那么，什么时候该使用多对一的权限体系，什么时候又该使用多对多的权限体系呢？</p>
<p>如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。其余情况尽量使用多对多的权限体系，保证系统的可扩展性。如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限。</p>
<h3 id="RBAC1-模型"><a href="#RBAC1-模型" class="headerlink" title="RBAC1 模型"></a>RBAC1 模型</h3><p>相对于 RBAC0 模型，增加了子角色，引入了继承概念，即子角色可以继承父角色的所有权限。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/CN3L7POv7d8Ku1QMnXGU.png" alt="img"></p>
<p><strong>使用场景：</strong>如某个业务部门，有经理、主管、专员。主管的权限不能大于经理，专员的权限不能大于主管，如果采用 RBAC0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况。</p>
<p>而 RBAC1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限。</p>
<h3 id="RBAC2-模型"><a href="#RBAC2-模型" class="headerlink" title="RBAC2 模型"></a>RBAC2 模型</h3><p>基于 RBAC0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等。</p>
<ul>
<li><strong>角色互斥：</strong>同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。案例：财务系统中一个用户不能同时被指派给会计角色和审计员角色。</li>
<li><strong>基数约束：</strong>一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 CEO 创建的，那这个角色的数量是有限的。</li>
<li><strong>先决条件角色：</strong>指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限。</li>
<li><strong>运行时互斥：</strong>例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。</li>
</ul>
<h3 id="RBAC3-模型"><a href="#RBAC3-模型" class="headerlink" title="RBAC3 模型"></a>RBAC3 模型</h3><p>称为统一模型，它包含了 RBAC1 和 RBAC2，利用传递性，也把 RBAC0 包括在内，综合了 RBAC0、RBAC1 和 RBAC2 的所有特点，这里就不在多描述了。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/7MEIhTRfnGmV0T5MBYoH.png" alt="img"></p>
<h3 id="什么是权限"><a href="#什么是权限" class="headerlink" title="什么是权限"></a>什么是权限</h3><p>说了这么久用户-角色-权限，可能小伙伴们都了解了什么是用户、什么是角色。但是有的小伙伴会好奇，那权限又是个什么玩意呢？</p>
<p>权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，按照我个人的理解，可以将权限分为：<strong>页面权限、操作权限和数据权限</strong>（这种分类法，主要是结合自己在工作中的实际情况理解总结而来，若有不足之处，也请大家指出）。</p>
<p><strong>页面权限：</strong>所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限。</p>
<p>如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/zZMuljfwRvu8Be6oEFlV.png" alt="img"></p>
<p>客户列表、客户黑名单、客户审批页面组成了客户管理这个模块。对于普通用户，不能进行审批操作，即无客户审批页面权限，在他的账号登录后侧边导航栏只显示客户列表、客户黑名单两个菜单。</p>
<p><strong>操作权限：</strong>用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。</p>
<p><strong>数据权限：</strong>一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。</p>
<p>简单举个例子：某系统中有销售部门，销售专员负责推销商品，销售主管负责管理销售专员日常工作，经理负责组织管理销售主管作业。</p>
<p>如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/eQKuv1vmlhA7eNDvlb1t.png" alt="img"></p>
<p>按照实际理解，‘销售专员张三’登录时，只能看到自己负责的数据；销售主管 2 登录时，能看到他所领导的所有业务员负责的数据，但看不到其他团队业务员负责的数据。</p>
<p>换另外一句话就是：我的客户只有我和我的直属上级以及直属上级的领导能看到，这就是我理解的数据权限。</p>
<p>要实现数据权限有多种方式：</p>
<ol>
<li>可以利用 RBAC1 模型，通过角色分级来实现。</li>
<li>在‘用户-角色-权限’的基础上，增加用户与组织的关联关系，用组织决定用户的数据权限。</li>
</ol>
<p>具体如何做呢？</p>
<p><strong>① 组织层级划分：</strong></p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/7OfSVWkovU90yPLCAYXl.png" alt="img"></p>
<p><strong>② 数据可视权限规则制定：</strong>上级组织只能看到下级组织员工负责的数据，而不能看到其他平级组织及其下级组织的员工数据等。</p>
<p>通过以上两点，系统就可以在用户登录时，自动判断要给用户展示哪些数据了。</p>
<h3 id="用户组的使用"><a href="#用户组的使用" class="headerlink" title="用户组的使用"></a>用户组的使用</h3><p>当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候我们可以引入一个概念“用户组”，就是将相同属性的用户归类到一起。</p>
<p>例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量。</p>
<p>同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限。</p>
<p>用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：我们在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分。</p>
<p>关于用户组的详细疑难解答，请查看<a target="_blank" rel="noopener" href="https://wen.woshipm.com/question/detail/88fues.html%E3%80%82%E5%9C%A8%E8%BF%99%E9%87%8C%E4%B9%9F%E5%8D%81%E5%88%86%E6%84%9F%E8%B0%A2%E4%B8%BA%E6%88%91%E8%A7%A3%E7%AD%94%E7%96%91%E6%83%91%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC%EF%BC%81">https://wen.woshipm.com/question/detail/88fues.html。在这里也十分感谢为我解答疑惑的朋友们！</a></p>
<h3 id="实例分析一、如何设计-RBAC-权限系统"><a href="#实例分析一、如何设计-RBAC-权限系统" class="headerlink" title="实例分析一、如何设计 RBAC 权限系统"></a>实例分析一、如何设计 RBAC 权限系统</h3><p>首先，我们思考一下一个简单的权限系统应该具备哪些内容？</p>
<p>答案显而易见，RBAC 模型：<strong>用户-角色-权限</strong>。所以最基本的我们应该具备用户、角色、权限这三个内容。</p>
<p>接下来，我们思考，究竟如何将三者关联起来。回顾前文，角色作为枢纽，关联用户、权限。所以在 RBAC 模型下，我们应该：<strong>创建一个角色，并为这个角色赋予相应权限，最后将角色赋予用户</strong>。</p>
<p>将这个问题抽象为流程，如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/UGJGmWviv32mWGgEkYpC.png" alt="img"></p>
<p>现在，基本的流程逻辑已经抽象出来了，接下来，分析该如何设计呢？</p>
<ul>
<li>第一步，需要角色管理列表，在角色管理列表能快速创建一个角色，且创建角色的同时能为角色配置权限，并且支持创建成功的角色列表能随时进行权限配置的的修改；</li>
<li>第二步，需要用户管理列表，在用户管理列表能快速添加一个用户，且添加用户时有让用户关联角色的功能。</li>
</ul>
<p>简单来说权限系统设计就包含以上两步，接下来为大家进行实例分析。</p>
<h3 id="实例分析二、"><a href="#实例分析二、" class="headerlink" title="实例分析二、"></a>实例分析二、</h3><p><strong>① 创建角色列表</strong></p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/KHqjDiWnyZrOxgJnvjRX.png" alt="img"></p>
<p>在角色列表快速创建一个角色：点击创建角色，支持创建角色时配置权限。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/uPzZ1iOh0bQpKkYbWCAc.png" alt="img"></p>
<p><strong>② 创建用户列表</strong></p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/x1pHe9duvadzeUfoeOac.png" alt="img"></p>
<p>在用户列表快速创建一个用户：支持用户关联角色的功能。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/VZLXACV2P72RTzJn0Us8.png" alt="img"></p>
<p>上述案例是基于最简单的 RBAC0 模型创建，适用于大部分常规的权限管理系统。</p>
<p>下面再分析一下 RBAC1 中角色分级具体如何设计。</p>
<ol>
<li><strong>在 RBAC0 的基础上，加上角色等级这个字段。</strong></li>
<li><strong>权限分配规则制定</strong>：低等级角色只能在高等级角色权限基础上进行删减权限。</li>
</ol>
<p>具体界面呈现如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/lGcyi0RJKsKmDI6C0bXy.png" alt="img"></p>
<p>以上就是简单的 RBAC 系统设计，若需更复杂的，还请读者根据上面的分析自行揣摩思考，尽管样式不同，但万变不离其宗，理解清楚 RBAC 模型后，结合自己的业务就可以设计出一套符合自己平台需求的角色权限系统，具体的就不再多阐述了。</p>
<h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><h3 id="OAuth2-0-简介"><a href="#OAuth2-0-简介" class="headerlink" title="OAuth2.0 简介"></a>OAuth2.0 简介</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> 是一个授权标准协议。OAuth 在全世界得到广泛应用，目前的版本是 2.0 版。</p>
<p>简单来说，<strong>OAuth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。</p>
<p>根据 OAuth 2.0 协议规范，主要有<strong>四个主体</strong>：</p>
<ul>
<li><strong>授权服务器</strong>：负责颁发 Access Token。</li>
<li><strong>资源所有者</strong>：你的应用的用户是资源的所有者，授权其他人访问他的资源。</li>
<li><strong>调用方</strong>：调用方请求获取 Access Token，经过用户授权后，授权服务器为其颁发 Access Token。调用方可以携带 Access Token 到资源服务器访问用户的资源。</li>
<li><strong>资源服务器</strong>：接受 Access Token，然后验证它的被赋予的权限项目，最后返回资源。</li>
</ul>
<p>其他重要概念：</p>
<ul>
<li>一次 OAuth 2.0 授权是指用户<strong>授权调用方</strong>相关的权限。</li>
<li><strong>Code 授权码</strong>是由授权服务器颁发的，用于调用方使用 Code 换取 Token。</li>
<li><strong>Access Token</strong> 由授权服务器颁发，持有 Access Token 说明完成了用户授权。</li>
<li><strong>Refresh Token</strong> 是一个可选的 Token，用于在 Access Token 过期后获取一个新的 Access Token。</li>
</ul>
<h3 id="OAuth-2-0-授权模式"><a href="#OAuth-2-0-授权模式" class="headerlink" title="OAuth 2.0 授权模式"></a>OAuth 2.0 授权模式</h3><p>OAuth 2.0 定义了四种授权方式。</p>
<ul>
<li><strong>授权码模式（authorization code）</strong></li>
<li><strong>简化模式（implicit）</strong></li>
<li><strong>密码模式（resource owner password credentials）</strong></li>
<li><strong>客户端模式（client credentials）</strong></li>
</ul>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<h4 id="隐藏模式"><a href="#隐藏模式" class="headerlink" title="隐藏模式"></a>隐藏模式</h4><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<h4 id="客户端凭证模式"><a href="#客户端凭证模式" class="headerlink" title="客户端凭证模式"></a>客户端凭证模式</h4><p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p>
<h3 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h3><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/azure/active-directory/develop/authorization-basics">Microsoft Azure 中国技术文档 - 授权基础知识</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63769951">RBAC用户、角色、权限、组设计方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce0944b4a903">权限系统设计模型分析（DAC，MAC，RBAC，ABAC）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.woshipm.com/pd/1150093.html">RBAC 模型：基于用户-角色-权限控制的一些思考</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/128c54/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/128c54/" class="post-title-link" itemprop="url">Spring 之事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-22 07:46:49" itemprop="dateCreated datePublished" datetime="2022-09-22T07:46:49+08:00">2022-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">Spring数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>27k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-之事务"><a href="#Spring-之事务" class="headerlink" title="Spring 之事务"></a>Spring 之事务</h1><p>Spring 框架为事务管理提供了一致的抽象，具有以下好处：</p>
<ul>
<li>跨不同事务 API 的一致编程模型，例如 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA)。</li>
<li>支持声明式事务管理。</li>
<li>用于编程事务管理的 API 比复杂事务 API（如 JTA）更简单。</li>
<li>与 Spring 的数据访问抽象完美集成。</li>
</ul>
<h2 id="Spring-框架的事务支持模型的优点"><a href="#Spring-框架的事务支持模型的优点" class="headerlink" title="Spring 框架的事务支持模型的优点"></a>Spring 框架的事务支持模型的优点</h2><p>传统上 Java EE 开发对事务管理有两种选择：全局事务或本地事务，两者都有很大的局限性。</p>
<h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 JTA 管理全局事务，这是一个繁琐的 API（部分原因在于其异常模型）。此外，JTA UserTransaction 通常需要来自 JNDI，这意味着您还需要使用 JNDI 才能使用 JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为 JTA 通常仅在应用程序服务器环境中可用。</p>
<p>以前，使用全局事务的首选方式是通过 EJB CMT（容器管理事务）。 CMT 是一种声明式事务管理（不同于程序化事务管理）。 EJB CMT 消除了对与事务相关的 JNDI 查找的需要，尽管使用 EJB 本身就需要使用 JNDI。它消除了大部分（但不是全部）编写 Java 代码来控制事务的需要。其明显的缺点是 CMT 与 JTA 和应用程序服务器环境相关联。此外，它仅在选择在 EJB 中实现业务逻辑（或至少在事务性 EJB 外观之后）时才可用。一般来说，EJB 的负面影响是如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>本地事务是指定资源的，例如与 JDBC 连接关联的事务。本地事务可能更容易使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用 JDBC 连接管理事务的代码不能在全局 JTA 事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个资源的正确性（值得注意的是，大多数应用程序使用单个事务资源。）。另一个缺点是本地事务对编程模型具有侵入性。</p>
<h4 id="Spring-框架的一致性编程模型"><a href="#Spring-框架的一致性编程模型" class="headerlink" title="Spring 框架的一致性编程模型"></a>Spring 框架的一致性编程模型</h4><p>Spring 解决了全局和本地事务的缺点。它允许开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以从不同环境中的不同事务管理策略中受益。 Spring 提供声明式和编程式事务管理。大多数用户更喜欢声明式事务管理，我们在大多数情况下都推荐这种方式。</p>
<p>通过程序化事务管理，开发人员可以使用 Spring 事务抽象，它可以在任何底层事务基础上运行。使用首选的声明性模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖 Spring 事务 API 或任何其他事务 API。</p>
<h2 id="理解-Spring-框架事务抽象"><a href="#理解-Spring-框架事务抽象" class="headerlink" title="理解 Spring 框架事务抽象"></a>理解 Spring 框架事务抽象</h2><p>Spring 事务的关键是事务策略的概念。事务策略由 <code>TransactionManager</code> 定义，特别是用于命令式事务管理的 <code>org.springframework.transaction.PlatformTransactionManager</code> 接口和用于响应式事务管理的 <code>org.springframework.transaction.ReactiveTransactionManager</code> 接口。以下清单显示了 <code>PlatformTransactionManager</code> API 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PlatformTransactionManager</code> 是一个 SPI 接口，所以使用者可以以编程方式使用它。因为 <code>PlatformTransactionManager</code> 是一个接口，所以可以根据需要轻松地 MOCK 或存根。它不依赖于查找策略，例如 JNDI。 <code>PlatformTransactionManager</code> 实现的定义与 Spring IoC 容器中的任何其他对象（或 bean）一样。仅此一项优势就使 Spring 事务成为有价值的抽象，即使您使用 JTA 也是如此。与直接使用 JTA 相比，您可以更轻松地测试事务代码。</p>
<p>同样，为了与 Spring 的理念保持一致，任何 <code>PlatformTransactionManager</code> 接口的方法可以抛出的 <code>TransactionException</code> 都是未经检查的（也就是说，它扩展了 <code>java.lang.RuntimeException</code> 类）。事务架构故障几乎总是致命的。极少数情况下，应用程序可以从事务失败中恢复，开发人员可以选择捕获和处理 <code>TransactionException</code>。重点是开发人员并非被迫这样做。</p>
<p><code>getTransaction(..)</code> 方法根据 <code>TransactionDefinition</code> 参数返回一个 <code>TransactionStatus</code> 对象。如果当前调用堆栈中存在匹配的事务，则返回的 <code>TransactionStatus</code> 可能表示新事务或可以表示现有事务。后一种情况的含义是，与 Java EE 事务上下文一样，<code>TransactionStatus</code> 与执行线程相关联。</p>
<p>Spring 还为使用响应式类型或 Kotlin 协程的响应式应用程序提供了事务管理抽象。以下清单显示了 org.springframework.transaction.ReactiveTransactionManager 定义的事务策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReactiveTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    Mono&lt;ReactiveTransaction&gt; <span class="title function_">getReactiveTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">commit</span><span class="params">(ReactiveTransaction status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">rollback</span><span class="params">(ReactiveTransaction status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应式事务管理器主要是一个 SPI，所以使用者可以以编程方式使用它。因为 <code>ReactiveTransactionManager</code> 是一个接口，所以可以根据需要轻松地 MOCK 或存根。</p>
<p><code>TransactionDefinition</code> 接口指定：</p>
<ul>
<li><strong>传播</strong>：通常，事务范围内的所有代码都在该事务中运行。但是，您可以指定在事务上下文已存在时运行事务方法时的行为。例如，代码可以在现有事务中继续运行（常见情况），或者可以暂停现有事务并创建新事务。 Spring 提供了 EJB CMT 熟悉的所有事务传播选项。要了解 Spring 中事务传播的语义，请参阅事务传播。</li>
<li><strong>隔离</strong>：此事务与其他事务的工作隔离的程度。例如，这个事务可以看到来自其他事务的未提交的写入吗？</li>
<li><strong>超时</strong>：此事务在超时并被底层事务基础设施自动回滚之前运行多长时间。</li>
<li><strong>只读状态</strong>：当您的代码读取但不修改数据时，您可以使用只读事务。在某些情况下，只读事务可能是一种有用的优化，例如当您使用 Hibernate 时。</li>
</ul>
<p>这些设置反映了标准事务概念。如有必要，请参阅讨论事务隔离级别和其他核心事务概念的资源。了解这些概念对于使用 Spring 或任何事务管理解决方案至关重要。</p>
<p><code>TransactionStatus</code> 接口为事务代码提供了一种简单的方式来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对所有事务 API 都是通用的。以下清单显示了 <code>TransactionStatus</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span> <span class="keyword">extends</span> <span class="title class_">TransactionExecution</span>, SavepointManager, Flushable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCompleted</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论您在 Spring 中选择声明式还是编程式事务管理，定义正确的 <code>TransactionManager</code> 实现都是绝对必要的。您通常通过依赖注入来定义此实现。</p>
<p><code>TransactionManager</code> 实现通常需要了解它们工作的环境：JDBC、JTA、Hibernate 等。以下示例展示了如何定义本地 <code>PlatformTransactionManager</code> 实现（在本例中，使用纯 JDBC。）</p>
<p>您可以通过创建类似于以下内容的 bean 来定义 JDBC 数据源：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后相关的 <code>PlatformTransactionManager</code> bean 定义具有对 <code>DataSource</code> 定义的引用。它应该类似于以下示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您在 Java EE 容器中使用 JTA，那么您可以使用通过 JNDI 获得的容器 DataSource 以及 Spring 的 JtaTransactionManager。以下示例显示了 JTA 和 JNDI 查找版本的外观：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/jee</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/jee/spring-jee.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;jdbc/jpetstore&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JtaTransactionManager 不需要了解 DataSource（或任何其他特定资源），因为它使用容器的全局事务管理基础架构。</p>
<blockquote>
<p>前面的 <code>dataSource</code> bean 定义使用 jee 命名空间中的 <code>&lt;jndi-lookup/&gt;</code> 标记。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#xsd-schemas-jee">The JEE Schema</a>。</p>
</blockquote>
<blockquote>
<p>如果您使用 JTA，那么无论您使用哪种数据访问技术，无论是 JDBC、Hibernate JPA 还是任何其他受支持的技术，您的事务管理器定义都应该看起来相同。这是因为 JTA 事务是全局事务，它可以征用任何事务资源。</p>
</blockquote>
<p>在所有 Spring 事务设置中，应用程序代码不需要更改。您可以仅通过更改配置来更改事务的管理方式，即使该更改意味着从本地事务转移到全局事务，反之亦然。</p>
<h2 id="将资源与事务同步"><a href="#将资源与事务同步" class="headerlink" title="将资源与事务同步"></a>将资源与事务同步</h2><p>如何创建不同的事务管理器以及它们如何链接到需要同步到事务的相关资源（例如 DataSourceTransactionManager 到 JDBC DataSource、HibernateTransactionManager 到 Hibernate SessionFactory 等等）现在应该很清楚了。本节描述应用程序代码（直接或间接地，通过使用 JDBC、Hibernate 或 JPA 等持久性 API）如何确保正确创建、重用和清理这些资源。本节还讨论了如何（可选地）通过相关的 TransactionManager 触发事务同步。</p>
<h3 id="High-level-同步方式"><a href="#High-level-同步方式" class="headerlink" title="High-level 同步方式"></a>High-level 同步方式</h3><p>推荐使用 Spring 最高级别的基于模板的持久性集成 API，或者使用本地 ORM API 和事务感知工厂 bean 或代理来管理本地资源工厂。这些事务感知解决方案负责处理资源的创建、重用、清理，资源的可选事务同步以及异常映射。因此，用户访问数据时不用编写代码来处理这些任务，从而可以完全聚焦于自身的业务逻辑。通常，您使用本机 ORM API 或通过使用 <code>JdbcTemplate</code> 进行 JDBC 访问。</p>
<h3 id="Low-level-同步方式"><a href="#Low-level-同步方式" class="headerlink" title="Low-level 同步方式"></a>Low-level 同步方式</h3><p><code>DataSourceUtils</code>（用于 JDBC）、<code>EntityManagerFactoryUtils</code>（用于 JPA）、<code>SessionFactoryUtils</code>（用于 Hibernate）等类存在于较低级别。当您希望应用程序代码直接处理本机持久性 API 的资源类型时，您可以使用这些类来确保获得正确的 Spring 管理的实例，事务（可选）同步，以及流程中发生的异常是正确映射到一致的 API。</p>
<p>例如，在 JDBC 的情况下，您可以使用 Spring 的 <code>org.springframework.jdbc.datasource.DataSourceUtils</code> 类代替传统的 JDBC 方法调用 DataSource 上的 <code>getConnection()</code> 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DataSourceUtils.getConnection(dataSource);</span><br></pre></td></tr></table></figure>

<p>如果现有事务已经具有与其同步（链接）的连接，则返回该实例。否则，方法调用会触发新连接的创建，该连接（可选地）与任何现有事务同步，并可供随后在同一事务中重用。如前所述，任何 <code>SQLException</code> 都包装在 Spring <code>CannotGetJdbcConnectionException</code> 中，这是 Spring 的未检查 <code>DataAccessException</code> 类型的层次结构之一。这种方法为您提供了比从 <code>SQLException</code> 轻松获得的更多信息，并确保跨数据库甚至跨不同持久性技术的可移植性。</p>
<p>这种方法在没有 Spring 事务管理的情况下也可以工作（事务同步是可选的），因此无论您是否使用 Spring 进行事务管理，都可以使用它。</p>
<p>当然，一旦您使用了 Spring 的 JDBC 支持、JPA 支持或 Hibernate 支持，您通常不喜欢使用 <code>DataSourceUtils</code> 或其他辅助类，因为与直接使用相关 API 相比，通过 Spring 抽象工作要快乐得多。例如，如果您使用 Spring <code>JdbcTemplate</code> 或 <code>jdbc.object</code> 包来简化对 JDBC 的使用，则正确的连接检索会在后台发生，您无需编写任何特殊代码。</p>
<h3 id="TransactionAwareDataSourceProxy"><a href="#TransactionAwareDataSourceProxy" class="headerlink" title="TransactionAwareDataSourceProxy"></a><code>TransactionAwareDataSourceProxy</code></h3><p>在最低级别存在 <code>TransactionAwareDataSourceProxy</code> 类。这是目标 <code>DataSource</code> 的代理，它包装目标 <code>DataSource</code> 以增加对 Spring 管理事务的认识。在这方面，它类似于由 Java EE 服务器提供的事务 JNDI 数据源。</p>
<p>您几乎不需要或不想使用此类，除非必须调用现有代码并传递标准 JDBC <code>DataSource</code> 接口实现。在这种情况下，这段代码可能是可用的，但正在参与 Spring 管理的事务。您可以使用前面提到的更高级别的抽象来编写新代码。</p>
<h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><blockquote>
<p>大多数 Spring 用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。</p>
</blockquote>
<p>Spring 框架的声明式事务管理是通过 Spring AOP 实现的。然而，由于事务方面代码随 Spring 发行版一起提供并且可以以样板方式使用，因此通常不必理解 AOP 概念即可有效地使用此代码。</p>
<p>Spring 框架的声明式事务管理类似于 EJB CMT，因为您可以指定事务行为（或缺少它）到单个方法级别。如有必要，您可以在事务上下文中进行 <code>setRollbackOnly()</code> 调用。两种类型的事务管理之间的区别是：</p>
<ul>
<li>与绑定到 JTA 的 EJB CMT 不同，Spring 框架的声明式事务管理适用于任何环境。通过调整配置文件，它可以使用 JDBC、JPA 或 Hibernate 处理 JTA 事务或本地事务。</li>
<li>您可以将 Spring 声明式事务管理应用于任何类，而不仅仅是诸如 EJB 之类的特殊类。</li>
<li>Spring 提供声明性回滚规则，这是一个没有 EJB 等效功能的特性。提供了对回滚规则的编程和声明性支持。</li>
<li>Spring 允许您使用 AOP 自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意 advice 以及事务性 advice。使用 EJB CMT，您无法影响容器的事务管理，除非使用 <code>setRollbackOnly()</code>。</li>
<li>Spring 不像高端应用服务器那样支持跨远程调用传播事务上下文。如果您需要此功能，我们建议您使用 EJB。但是，在使用这种特性之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。</li>
</ul>
<p>回滚规则的概念很重要。它们让您指定哪些异常（和 throwable）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在 Java 代码中。因此，尽管您仍然可以在 TransactionStatus 对象上调用 setRollbackOnly() 来回滚当前事务，但通常您可以指定 MyApplicationException 必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础架构。例如，它们通常不需要导入 Spring 事务 API 或其他 Spring API。</p>
<p>尽管 EJB 容器默认行为会在系统异常（通常是运行时异常）上自动回滚事务，但 EJB CMT 不会在应用程序异常（即除 java.rmi.RemoteException 之外的检查异常）上自动回滚事务。虽然声明式事务管理的 Spring 默认行为遵循 EJB 约定（回滚仅在未经检查的异常上自动），但自定义此行为通常很有用。</p>
<h3 id="Spring-声明式事务管理的实现"><a href="#Spring-声明式事务管理的实现" class="headerlink" title="Spring 声明式事务管理的实现"></a>Spring 声明式事务管理的实现</h3><p>关于 Spring 框架的声明式事务支持，最重要的概念是这种支持是通过 AOP 代理启用的，并且事务 advice 是由元数据驱动的（目前是基于 XML 或基于注释的）。 AOP 与事务元数据的结合产生了一个 AOP 代理，它使用 <code>TransactionInterceptor</code> 和适当的 <code>TransactionManager</code> 实现来驱动围绕方法调用的事务。</p>
<p>Spring 的 <code>TransactionInterceptor</code> 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型的方法，例如 Publisher 或 Kotlin Flow（或它们的子类型）有资格进行响应式事务管理。包括 void 在内的所有其他返回类型都使用代码路径进行命令式事务管理。</p>
<p>事务管理风格会影响需要哪个事务管理器。命令式事务需要 <code>PlatformTransactionManager</code>，而响应式事务使用 <code>ReactiveTransactionManager</code> 实现。</p>
<blockquote>
<p><code>@Transactional</code> 通常与 <code>PlatformTransactionManager</code> 管理的线程绑定事务一起使用，将事务公开给当前执行线程中的所有数据访问操作。注意：这不会传播到方法中新启动的线程。</p>
<p>由 <code>ReactiveTransactionManager</code> 管理的反应式事务使用 Reactor 上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一个反应式管道中的同一个 Reactor 上下文中执行。</p>
</blockquote>
<p>下图显示了在事务代理上调用方法的概念视图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220927093737.png"></p>
<h3 id="声明式事务示例"><a href="#声明式事务示例" class="headerlink" title="声明式事务示例"></a>声明式事务示例</h3><p>考虑以下接口及其伴随的实现。此示例使用 Foo 和 Bar 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，DefaultFooService 类在每个已实现方法的主体中抛出 <code>UnsupportedOperationException</code> 实例这一事实很好。该行为使您可以看到正在创建的事务，然后回滚以响应 <code>UnsupportedOperationException</code> 实例。</p>
<p>以下清单显示了 FooService 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the service interface that we want to make transactional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> x.y.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line"></span><br><span class="line">    Foo <span class="title function_">getFoo</span><span class="params">(String fooName)</span>;</span><br><span class="line"></span><br><span class="line">    Foo <span class="title function_">getFoo</span><span class="params">(String fooName, String barName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertFoo</span><span class="params">(Foo foo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateFoo</span><span class="params">(Foo foo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了上述接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFooService</span> <span class="keyword">implements</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName, String barName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 FooService 接口的前两个方法 getFoo(String) 和 getFoo(String, String) 必须在具有只读语义的事务上下文中运行，并且其他方法 insertFoo(Foo) 和 updateFoo(Foo )，必须在具有读写语义的事务上下文中运行。以下配置将在接下来的几段中详细说明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- from the file &#x27;context.xml&#x27; --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- the transactional advice (what &#x27;happens&#x27;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- the transactional semantics... --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- all methods starting with &#x27;get&#x27; are read-only --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ensure that the above transactional advice runs for any execution</span></span><br><span class="line"><span class="comment">        of an operation defined by the FooService interface --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;fooServiceOperation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.FooService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;fooServiceOperation&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- don&#x27;t forget the DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;scott&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tiger&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- similarly, don&#x27;t forget the TransactionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>检查前面的配置。它假定您要使服务对象 fooService bean 具有事务性。要应用的事务语义封装在 <code>&lt;tx:advice/&gt;</code> 定义中。<code>&lt;tx:advice/&gt;</code> 定义读作“所有以 get 开头的方法都将在只读事务的上下文中运行，所有其他方法都将以默认事务语义运行”。<code>&lt;tx:advice/&gt;</code> 标签的 <code>transaction-manager</code> 属性设置为将驱动事务的 TransactionManager bean 的名称（在本例中为 txManager bean）。</p>
<blockquote>
<p>如果要连接的 TransactionManager 的 bean 名称具有名称 transactionManager，则可以省略事务 advice (tx:advice&#x2F;) 中的 transaction-manager 属性。如果要连接的 TransactionManager bean 有任何其他名称，则必须显式使用 transaction-manager 属性，如前面的示例所示。</p>
</blockquote>
<p><code>&lt;aop:config/&gt;</code> 定义确保由 <code>txAdvice</code> bean 定义的事务性建议在程序中的适当位置运行。首先，您定义一个切入点，该切入点与 <code>FooService</code> 接口 (fooServiceOperation) 中定义的任何操作的执行相匹配。然后，您使用一个 adviser 将切入点与 <code>txAdvice</code> 相关联。结果表明，在执行 fooServiceOperation 时，会运行 <code>txAdvice</code> 定义的建议。</p>
<p>一个常见的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;fooServiceMethods&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;fooServiceMethods&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面显示的配置用于围绕从 fooService bean 定义创建的对象创建事务代理。代理配置了事务 advice，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、暂停、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;context.xml&quot;</span>);</span><br><span class="line">        <span class="type">FooService</span> <span class="variable">fooService</span> <span class="operator">=</span> ctx.getBean(FooService.class);</span><br><span class="line">        fooService.insertFoo(<span class="keyword">new</span> <span class="title class_">Foo</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回滚一个声明性事务"><a href="#回滚一个声明性事务" class="headerlink" title="回滚一个声明性事务"></a>回滚一个声明性事务</h3><p>Spring 框架中，触发事务回滚的推荐方式是在事务上下文的代码中抛出异常。Spring 事务框架会捕获任何未处理的异常，并确定是否将事务标记为回滚。</p>
<p>在其默认配置中，Spring 事务框架只会将存在运行时且未经检查异常的事务标记为回滚。也就是说，当抛出的异常是 <code>RuntimeException</code> 的实例或子类时。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的检查异常不会导致默认配置中的回滚。</p>
<p>您可以通过指定回滚规则，明确指定哪些异常类型将导致事务回滚。</p>
<blockquote>
<p>回滚规则约定在抛出指定异常时是否应回滚事务，并且规则基于模式。模式可以是完全限定的类名或异常类型的完全限定类名的子字符串（必须是 <code>Throwable</code> 的子类），目前不支持通配符。例如，<code>javax.servlet.ServletException</code> 或 <code>ServletException</code> 的值将匹配 <code>javax.servlet.ServletException</code> 及其子类。</p>
<p>回滚规则可以通过 <code>rollback-for</code> 和 <code>no-rollback-for</code> 属性在 XML 中配置，这允许将模式指定为字符串。使用 <code>@Transactional</code> 时，可以通过 <code>rollbackFor</code> &#x2F; <code>noRollbackFor</code> 和<code>rollbackForClassName</code> &#x2F; <code>noRollbackForClassName</code> 属性配置回滚规则，它们允许将模式分别指定为类引用或字符串。当异常类型被指定为类引用时，其完全限定名称将用作模式。因此，<code>@Transactional(rollbackFor = example.CustomException.class)</code> 等价于 <code>@Transactional(rollbackForClassName = &#39;example.CustomException&#39;)</code>。</p>
</blockquote>
<p>以下 XML 片段演示了如何通过 <code>rollback-for</code> 属性提供异常模式来为已检查的、特定的 <code>Exception</code> 类型配置回滚：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;NoProductInStockException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。下面的例子告诉 Spring 事务框架，即使在面对未处理的 InstrumentNotFoundException 时也要提交伴随事务。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;updateStock&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;InstrumentNotFoundException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 Spring Framework 事务框架捕获到异常，并检查配置的回滚规则以确定是否将事务标记为回滚时，由最重要的匹配规则决定。因此，在以下配置的情况下，除 <code>InstrumentNotFoundException</code> 之外的任何异常都会导致伴随事务的回滚。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Throwable&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;InstrumentNotFoundException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且将您的代码与 Spring Framework 的事务基础设施紧密耦合。以下示例显示如何以编程方式指示所需的回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resolvePosition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// some business logic...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoProductInStockException ex) &#123;</span><br><span class="line">        <span class="comment">// trigger rollback programmatically</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要，可以使用程序化回滚，但它的使用与实现干净的基于 POJO 的架构背道而驰。</p>
<h3 id="为不同的-Bean-配置不同的事务语义"><a href="#为不同的-Bean-配置不同的事务语义" class="headerlink" title="为不同的 Bean 配置不同的事务语义"></a>为不同的 Bean 配置不同的事务语义</h3><p>考虑您有许多服务层对象的场景，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义具有不同 <code>&lt;aop:advisor/&gt;</code> 元素和不同 <code>advice-ref</code> 属性值的切点来实现这一点。</p>
<p>作为一个比较点，首先假设您的所有服务层类都定义在根 x.y.service 包中。 要使作为该包（或子包）中定义的类的实例并且名称以 Service 结尾的所有 bean 都具有默认的事务配置，您可以编写以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceOperation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service..*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceOperation&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- these two beans will be transactional... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.extras.SimpleBarService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... and these two beans won&#x27;t --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.xyz.SomeService&quot;</span>/&gt;</span> <span class="comment">&lt;!-- (not in the right package) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;barManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.SimpleBarManager&quot;</span>/&gt;</span> <span class="comment">&lt;!-- (doesn&#x27;t end in &#x27;Service&#x27;) --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other transaction infrastructure beans such as a TransactionManager omitted... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下示例显示了如何使用完全不同的事务设置配置两个不同的 bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;defaultServiceOperation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;noTxServiceOperation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.ddl.DefaultDdlManager.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;defaultServiceOperation&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;defaultTxAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;noTxServiceOperation&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;noTxAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this bean will be transactional (see the &#x27;defaultServiceOperation&#x27; pointcut) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherFooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.ddl.DefaultDdlManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;defaultTxAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;noTxAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other transaction infrastructure beans such as a TransactionManager omitted... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="lt-tx-advice-gt-配置"><a href="#lt-tx-advice-gt-配置" class="headerlink" title="&lt;tx:advice/&gt; 配置"></a><code>&lt;tx:advice/&gt;</code> 配置</h3><p><code>&lt;tx:advice/&gt;</code> 的默认配置为：</p>
<ul>
<li><p>传播设置是 <code>REQUIRED</code></p>
</li>
<li><p>隔离级别为 <code>DEFAULT</code></p>
</li>
<li><p>事务是 read-write</p>
</li>
<li><p>事务超时默认为底层事务系统的默认超时，如果不支持超时，则为无。</p>
</li>
<li><p>任何 <code>RuntimeException</code> 都会触发回滚，而任何已检查的 <code>Exception</code> 都不会</p>
</li>
</ul>
<p><code>&lt;tx:advice/&gt;</code> 配置属性</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">是否必要</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">Yes</td>
<td align="left"></td>
<td align="left">与事务属性关联的方法名称。支持通配符，如：<code>get*</code>、<code>handle*</code>、<code>on*Event</code></td>
</tr>
<tr>
<td align="left"><code>propagation</code></td>
<td align="left">No</td>
<td align="left"><code>REQUIRED</code></td>
<td align="left">事务传播行为</td>
</tr>
<tr>
<td align="left"><code>isolation</code></td>
<td align="left">No</td>
<td align="left"><code>DEFAULT</code></td>
<td align="left">事务隔离级别。仅适用于 <code>REQUIRED</code> 或 <code>REQUIRES_NEW</code> 的传播设置。</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">No</td>
<td align="left">-1</td>
<td align="left">事务超时时间（单位：秒）。仅适用于 <code>REQUIRED</code> 或 <code>REQUIRES_NEW</code> 的传播设置。</td>
</tr>
<tr>
<td align="left"><code>read-only</code></td>
<td align="left">No</td>
<td align="left">false</td>
<td align="left">read-write 或 read-only 事务。</td>
</tr>
<tr>
<td align="left"><code>rollback-for</code></td>
<td align="left">No</td>
<td align="left"></td>
<td align="left">触发回滚的 <code>Exception</code> 实例列表（通过逗号分隔）。</td>
</tr>
<tr>
<td align="left"><code>no-rollback-for</code></td>
<td align="left">No</td>
<td align="left"></td>
<td align="left">不触发回滚的 <code>Exception</code> 实例列表（通过逗号分隔）。</td>
</tr>
</tbody></table>
<h3 id="使用-Transactional-注解"><a href="#使用-Transactional-注解" class="headerlink" title="使用 @Transactional 注解"></a>使用 <code>@Transactional</code> 注解</h3><p>除了基于 XML 的声明式事务配置方法之外，您还可以使用基于注解的方法。</p>
<p>下面是一个使用 <code>@Transactional</code> 注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFooService</span> <span class="keyword">implements</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName, String barName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所述在类级别使用，<code>@Transactional</code> 注解表明声明类（及其子类）的所有方法都使用默认事务配置。 或者，可以单独为每个方法指定注解。请注意，类级别的注解不适用于类层次结构中的祖先类； 在这种情况下，继承的方法需要在本地重新声明才能参与子类级别的注解。</p>
<p>当上面的 POJO 类在 Spring 上下文中定义为 bean 时，您可以通过 <code>@Configuration</code> 类中的 <code>@EnableTransactionManagement</code> 注解使 bean 实例具有事务性。</p>
<p>在 XML 配置中， <code>&lt;tx:annotation-driven/&gt;</code> 标签提供了类似的便利：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- from the file &#x27;context.xml&#x27; --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- a TransactionManager is still required --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- (this dependency is defined somewhere else) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Transactional-配置"><a href="#Transactional-配置" class="headerlink" title="@Transactional 配置"></a><code>@Transactional</code> 配置</h4><table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-multiple-tx-mgrs-with-attransactional">value</a></td>
<td align="left"><code>String</code></td>
<td align="left">Optional qualifier that specifies the transaction manager to be used.</td>
</tr>
<tr>
<td align="left"><code>transactionManager</code></td>
<td align="left"><code>String</code></td>
<td align="left">Alias for <code>value</code>.</td>
</tr>
<tr>
<td align="left"><code>label</code></td>
<td align="left">Array of <code>String</code> labels to add an expressive description to the transaction.</td>
<td align="left">Labels may be evaluated by transaction managers to associate implementation-specific behavior with the actual transaction.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation">propagation</a></td>
<td align="left"><code>enum</code>: <code>Propagation</code></td>
<td align="left">Optional propagation setting.</td>
</tr>
<tr>
<td align="left"><code>isolation</code></td>
<td align="left"><code>enum</code>: <code>Isolation</code></td>
<td align="left">Optional isolation level. Applies only to propagation values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left"><code>int</code> (in seconds of granularity)</td>
<td align="left">Optional transaction timeout. Applies only to propagation values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</td>
</tr>
<tr>
<td align="left"><code>timeoutString</code></td>
<td align="left"><code>String</code> (in seconds of granularity)</td>
<td align="left">Alternative for specifying the <code>timeout</code> in seconds as a <code>String</code> value — for example, as a placeholder.</td>
</tr>
<tr>
<td align="left"><code>readOnly</code></td>
<td align="left"><code>boolean</code></td>
<td align="left">Read-write versus read-only transaction. Only applicable to values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</td>
</tr>
<tr>
<td align="left"><code>rollbackFor</code></td>
<td align="left">Array of <code>Class</code> objects, which must be derived from <code>Throwable.</code></td>
<td align="left">Optional array of exception types that must cause rollback.</td>
</tr>
<tr>
<td align="left"><code>rollbackForClassName</code></td>
<td align="left">Array of exception name patterns.</td>
<td align="left">Optional array of exception name patterns that must cause rollback.</td>
</tr>
<tr>
<td align="left"><code>noRollbackFor</code></td>
<td align="left">Array of <code>Class</code> objects, which must be derived from <code>Throwable.</code></td>
<td align="left">Optional array of exception types that must not cause rollback.</td>
</tr>
<tr>
<td align="left"><code>noRollbackForClassName</code></td>
<td align="left">Array of exception name patterns.</td>
<td align="left">Optional array of exception name patterns that must not cause rollback.</td>
</tr>
</tbody></table>
<h4 id="多事务管理器场景下使用-Transactional"><a href="#多事务管理器场景下使用-Transactional" class="headerlink" title="多事务管理器场景下使用 @Transactional"></a>多事务管理器场景下使用 <code>@Transactional</code></h4><p>某些情况下，应用程序中可能需要接入多个数据源，相应的，也需要多个独立的事务管理器。使用者可以使用 <code>@Transactional</code> 注释的 value 或 <code>transactionManager</code> 属性来选择性地指定要使用的 <code>TransactionManager</code> 的标识。这可以是 bean 名称或事务管理器 bean 的限定符值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;order&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSomething</span><span class="params">(String name)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;account&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;reactive-account&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">doSomethingReactive</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面展示如何定义 <code>TransactionManager</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;order&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;account&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;reactive-account&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>TransactionalService</code> 上的各个方法在单独的事务管理器下运行，由 order、account 和 reactive-account 限定符区分。 如果没有找到明确指定的 <code>TransactionManager</code> bean，则仍使用默认的 <code>&lt;tx:annotation-driven&gt;</code> 目标 bean 名称。</p>
<h4 id="自定义组合注解"><a href="#自定义组合注解" class="headerlink" title="自定义组合注解"></a>自定义组合注解</h4><p>如果您发现在许多不同的方法上重复使用 <code>@Transactional</code> 相同的属性，可以使用 Spring 的元注解自定义组合注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Transactional(transactionManager = &quot;order&quot;, label = &quot;causal-consistency&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Transactional(transactionManager = &quot;account&quot;, label = &quot;retryable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OrderTx</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSomething</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AccountTx</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但我们也可以包括传播行为、回滚规则、超时和其他特性。</p>
<h4 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h4><p>在 Spring 管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220928114544.png"></p>
<p><code>PROPAGATION_REQUIRED</code> 强制执行物理事务，如果尚不存在事务，则在当前范围的本地执行或参与更大范围定义的现有“外部”事务。 这是同一线程内的常见调用堆栈安排中的一个很好的默认设置（例如，委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。</p>
<p>当传播设置为 PROPAGATION_REQUIRED 时，将为应用该设置的每个方法创建一个逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准 PROPAGATION_REQUIRED 行为的情况下，所有这些范围都映射到同一个物理事务。因此，在内部事务范围内设置的仅回滚标记确实会影响外部事务实际提交的机会。</p>
<p>但是，在内部事务范围设置了仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围静默触发）是意外的。此时会引发相应的 <code>UnexpectedRollbackException</code>。这是预期的行为，因此事务的调用者永远不会被误导以为执行了提交，而实际上并没有执行。因此，如果内部事务（外部调用者不知道）默默地将事务标记为仅回滚，外部调用者仍会调用提交。外部调用者需要接收 <code>UnexpectedRollbackException</code> 以清楚地指示执行了回滚。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220928115243.png"></p>
<p>PROPAGATION_REQUIRES_NEW 与 PROPAGATION_REQUIRED 相比，始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，而不是继承外部事务的特性。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>了解 Spring 事务抽象概述了核心类，并描述了如何从各种来源配置和获取 DataSource 实例。</p>
<p>将资源与事务同步描述了应用程序代码如何确保正确地创建、重用和清理资源。</p>
<p>声明式事务管理描述了对声明式事务管理的支持。</p>
<p>程序化事务管理涵盖对程序化（即显式编码）事务管理的支持。</p>
<p>事务绑定事件描述了如何在事务中使用应用程序事件。</p>
<p>本章还讨论了最佳实践、应用服务器集成和常见问题的解决方案。</p>
<p>Spring 事务抽象的关键是事务策略的概念。事务策略由 <code>TransactionManager</code> 定义，特别是用于命令式事务管理的 <code>org.springframework.transaction.PlatformTransactionManager</code> 接口和用于响应式事务管理的 <code>org.springframework.transaction.ReactiveTransactionManager</code> 接口。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220922073737.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/">Spring 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html">Spring 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/data.html">Spring Boot 官方文档</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/be5227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/be5227/" class="post-title-link" itemprop="url">数据库连接池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-21 23:58:06" itemprop="dateCreated datePublished" datetime="2022-09-21T23:58:06+08:00">2022-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><blockquote>
<p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。——摘自百度百科</p>
</blockquote>
<h2 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h2><p>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p>
<h2 id="为什么需要数据库连接池"><a href="#为什么需要数据库连接池" class="headerlink" title="为什么需要数据库连接池"></a>为什么需要数据库连接池</h2><h3 id="不使用数据库连接池"><a href="#不使用数据库连接池" class="headerlink" title="不使用数据库连接池"></a>不使用数据库连接池</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220921231353.png"></p>
<p>不使用数据库连接池的<strong>步骤</strong>：</p>
<ol>
<li>TCP 建立连接的三次握手</li>
<li>MySQL 认证的三次握手</li>
<li>真正的 SQL 执行</li>
<li>MySQL 的关闭</li>
<li>TCP 的四次握手关闭</li>
</ol>
<p>不使用数据库连接池的特性：</p>
<ul>
<li><strong>优点</strong>：实现简单</li>
<li><strong>缺点</strong>：<ul>
<li>网络 IO 较多</li>
<li>数据库的负载较高</li>
<li>响应时间较长及 QPS 较低</li>
<li>应用频繁的创建连接和关闭连接，导致临时对象较多，GC 频繁</li>
<li>在关闭连接后，会出现大量 TIME_WAIT 的 TCP 状态（在 2 个 MSL 之后关闭）</li>
</ul>
</li>
</ul>
<h3 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220921231500.png"></p>
<p>使用数据库连接池的步骤：只有第一次访问的时候，需要建立连接。 但是之后的访问，均会<strong>复用</strong>之前创建的连接，直接执行 SQL 语句。</p>
<p>使用数据库连接池的<strong>优点</strong>：</p>
<ul>
<li>减少了网络开销</li>
<li>系统的性能会有一个实质的提升</li>
<li>没有了 TIME_WAIT 状态</li>
</ul>
<h2 id="数据库连接池如何工作"><a href="#数据库连接池如何工作" class="headerlink" title="数据库连接池如何工作"></a>数据库连接池如何工作</h2><p>数据库连接池工作的核心在于以下几点：</p>
<ol>
<li><p><strong>创建连接池</strong>：与线程池等池化对象类似，数据库连接池会在进程启动之初，根据配置初始化，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，以避免创建、关闭所带来的系统开销。</p>
</li>
<li><p><strong>使用、管理连接池中</strong>：连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。合理的策略可以保证数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。通常，数据库连接池的管理策略如下：</p>
<ol>
<li>当请求数据库连接时，首先查看连接池中是否有空闲连接。</li>
<li>如果存在空闲连接，则将连接分配给客户使用。</li>
<li>如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数。若未达到，就重新创建一个连接，并分配给请求的客户；如果达到，就按设定的最大等待时间进行等待，若超出最大等待时间，则抛出异常给客户。</li>
<li>当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值。如果超过，就从连接池中删除该连接；否则保留为其他客户服务。</li>
</ol>
</li>
<li><p><strong>关闭连接池</strong>：当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。</p>
</li>
</ol>
<h2 id="数据库连接池的核心参数"><a href="#数据库连接池的核心参数" class="headerlink" title="数据库连接池的核心参数"></a>数据库连接池的核心参数</h2><p>使用数据库连接池，需要为其配置一些参数，以控制其工作。</p>
<p>通常，数据库连接池都会包含以下核心参数：</p>
<ul>
<li><strong>最小连接数</strong>：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.</li>
<li><strong>最大连接数</strong>：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作</li>
<li>最大空闲时间</li>
<li>获取连接超时时间</li>
<li>超时重试连接次数</li>
</ul>
<h2 id="数据库连接池的问题"><a href="#数据库连接池的问题" class="headerlink" title="数据库连接池的问题"></a>数据库连接池的问题</h2><p><strong>并发问题</strong>：为了保证连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。</p>
<p><strong>事务处理</strong>：我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-OR-NOTHING”原则,即对于一组 SQL 语句要么全做，要么全不做。我们知道当 2 个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。</p>
<p><strong>连接池的分配与释放</strong>：连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户。</p>
<p><strong>连接池的配置与维护</strong>：连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。 如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</p>
<h2 id="数据库连接池技术选型"><a href="#数据库连接池技术选型" class="headerlink" title="数据库连接池技术选型"></a>数据库连接池技术选型</h2><p>常见的数据库连接池：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">HikariCP</a>：HiKariCP 号称是跑的最快的连接池，并且是 SpringBoot 框架的默认连接池。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/druid">Druid</a>：Druid 是阿里巴巴开源的数据库连接池。Druid 内置强大的监控功能，监控特性不影响性能。功能强大，能防 SQL 注入，内置 Loging 能诊断 Hack 应用行为。</li>
<li><a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-dbcp/">DBCP</a>： 由 Apache 开发的一个 Java 数据库连接池。<code>commons-dbcp2</code> 基于 <code>commons-pool2</code> 来实现底层的对象池机制。单线程，性能较差，适用于小型系统。官方自 2021 年后没有再更新。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/swaldman/c3p0">C3P0</a>：开源的 JDBC 连接池，实现了数据源和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。单线程，性能较差，适用于小型系统。官方自 2019 年后再没有更新。</li>
<li>Tomcat-jdbc：Tomcat 在 7.0 以前使用 DBCP 做为连接池组件，从 7.0 后新增了 Tomcat jdbc pool 模块，基于 Tomcat JULI，使用 Tomcat 日志框架，完全兼容 dbcp，通过异步方式获取连接，支持高并发应用环境，超级简单核心文件只有 8 个，支持 JMX，支持 XA Connection。</li>
</ul>
<p>来自 Druid 的竞品对比（<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D%EF%BC%89%EF%BC%9A">https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D）：</a></p>
<table>
<thead>
<tr>
<th>功能类别</th>
<th>功能</th>
<th>Druid</th>
<th>HikariCP</th>
<th>DBCP</th>
<th>Tomcat-jdbc</th>
<th>C3P0</th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>PSCache</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>LRU</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>SLB 负载均衡支持</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>稳定性</td>
<td>ExceptionSorter</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>扩展</td>
<td>扩展</td>
<td>Filter</td>
<td></td>
<td></td>
<td>JdbcIntercepter</td>
<td></td>
</tr>
<tr>
<td>监控</td>
<td>监控方式</td>
<td>jmx&#x2F;log&#x2F;http</td>
<td>jmx&#x2F;metrics</td>
<td>jmx</td>
<td>jmx</td>
<td>jmx</td>
</tr>
<tr>
<td>支持 SQL 级监控</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>Spring&#x2F;Web 关联监控</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td></td>
<td>诊断支持</td>
<td>LogFilter</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>连接泄露诊断</td>
<td>logAbandoned</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>安全</td>
<td>SQL 防注入</td>
<td>是</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>支持配置加密</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<p>从数据库连接池最重要的性能角度来看：HikariCP 应该性能最好；Druid 也不错，并且有更多、更久的生产实践，更为可靠；而其他常见的数据库连接池性能远远不如。</p>
<p>从功能角度来看：Druid 功能最全面，除基本的数据库连接池能力以外，还支持 sql 级监控、扩展、SQL 防注入以及监控等功能。</p>
<p>综合来看：HikariCP 是 Spring Boot 首选数据库连接池，对于 Spring Boot 项目来说，无疑适配性最好。而非 Spring Boot 项目，可以优先考虑 Druid，在国内有大规模应用，中文社区支持良好。</p>
<h2 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h2><p>HiKariCP 号称是跑的最快的连接池，并且是 SpringBoot 框架的默认连接池。</p>
<p>HiKariCP 为了提升性能，做了很多细节上的优化，例如：</p>
<ul>
<li>使用 FastList 替代 ArrayList，通过初始化的默认值，减少了越界检查的操作</li>
<li>优化并精简了字节码，通过使用 Javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令</li>
<li>实现了无锁的 ConcurrentBag，减少了并发场景下的锁竞争</li>
</ul>
<p>HikariCP 关键配置：</p>
<ul>
<li><code>maximum-pool-size</code>：池中最大连接数（包括空闲和正在使用的连接）。默认值是 10，这个一般预估应用的最大连接数，后期根据监测得到一个最大值的一个平均值。要知道，最大连接并不是越多越好，一个 connection 会占用系统的带宽和存储。但是 当连接池没有空闲连接并且已经到达最大值，新来的连接池请求（HikariPool#getConnection）会被阻塞直到<code>connectionTimeout</code>（毫秒），超时后便抛出 SQLException。</li>
<li><code>minimum-idle</code>：池中最小空闲连接数量。默认值 10，小于池中最大连接数，一般根据系统大部分情况下的数据库连接情况取一个平均值。Hikari 会尽可能、尽快地将空闲连接数维持在这个数量上。如果为了获得最佳性能和对峰值需求的响应能力，我们也不妨让他和最大连接数保持一致，使得 HikariCP 成为一个固定大小的数据库连接池。</li>
<li><code>connection-timeout</code>：连接超时时间。默认值为 30s，可以接收的最小超时时间为 250ms。但是连接池请求也可以自定义超时时间（com.zaxxer.hikari.pool.HikariPool#getConnection(long)）。</li>
<li><code>idle-timeout</code>：空闲连接存活最大时间，默认 600000（十分钟）</li>
<li><code>max-lifetime</code>：连接池中连接的最大生命周期。当连接一致处于闲置状态时，超过 8 小时数据库会主动断开连接。为了防止大量的同一时间处于空闲连接因为数据库方的闲置超时策略断开连接（可以理解为连接雪崩），一般将这个值设置的比数据库的“闲置超时时间”小几秒，以便这些连接断开后，HikariCP 能迅速的创建新一轮的连接。</li>
<li><code>pool-name</code>：连接池的名字。一般会出现在日志和 JMX 控制台中。默认值：auto-genenrated。建议取一个合适的名字，便于监控。</li>
<li><code>auto-commit</code>：是否自动提交池中返回的连接。默认值为 true。一般是有必要自动提交上一个连接中的事物的。如果为 false，那么就需要应用层手动提交事物。</li>
</ul>
<p>参考配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接池名称</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.pool-name</span> = <span class="string">SpringTutorialHikariPool</span></span><br><span class="line"><span class="comment"># 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span> = <span class="string">10</span></span><br><span class="line"><span class="comment"># 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span> = <span class="string">10</span></span><br><span class="line"><span class="comment"># 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span> = <span class="string">60000</span></span><br><span class="line"><span class="comment"># 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime&gt;0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒</span></span><br><span class="line"><span class="comment"># 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span> = <span class="string">600000</span></span><br><span class="line"><span class="comment"># 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span> = <span class="string">1800000</span></span><br></pre></td></tr></table></figure>

<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><p>Druid 是阿里巴巴开源的数据库连接池。Druid 连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防 SQL 注入，内置 Loging 能诊断 Hack 应用行为。</p>
<p>Druid 关键配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库访问配置</span></span><br><span class="line"><span class="comment"># 主数据源，默认的</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/druid</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 下面为连接池的补充设置，应用到上面所有数据源中</span></span><br><span class="line"><span class="comment"># 初始化大小，最小，最大</span></span><br><span class="line"><span class="attr">spring.datasource.initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.datasource.minIdle</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.datasource.maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line"><span class="attr">spring.datasource.maxWait</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line"><span class="attr">spring.datasource.timeBetweenEvictionRunsMillis</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line"><span class="attr">spring.datasource.minEvictableIdleTimeMillis</span>=<span class="string">300000</span></span><br><span class="line"><span class="attr">spring.datasource.validationQuery</span>=<span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line"><span class="attr">spring.datasource.testWhileIdle</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.testOnBorrow</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.datasource.testOnReturn</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line"><span class="attr">spring.datasource.poolPreparedStatements</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.maxPoolPreparedStatementPerConnectionSize</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span></span><br><span class="line"><span class="attr">spring.datasource.filters</span>=<span class="string">stat,wall,log4j</span></span><br><span class="line"><span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line"><span class="attr">spring.datasource.connectionProperties</span>=<span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span></span><br><span class="line"><span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br><span class="line"><span class="comment">#spring.datasource.useGlobalDataSourceStat=true</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/crankz/article/details/82874158">数据库连接池学习笔记（一）：原理介绍+常用连接池介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MzEzMDI1OQ==&mid=2651814835&idx=1&sn=cb775d3926ce39d12fa420a292c1f83d&scene=0#wechat_redirect">高性能数据库连接池的内幕</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">HikariCP</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/druid">druid</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1ee347/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1ee347/" class="post-title-link" itemprop="url">《MySQL 实战 45 讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-20 19:20:08" itemprop="dateCreated datePublished" datetime="2022-07-20T19:20:08+08:00">2022-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>33k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《MySQL-实战-45-讲》笔记"><a href="#《MySQL-实战-45-讲》笔记" class="headerlink" title="《MySQL 实战 45 讲》笔记"></a>《MySQL 实战 45 讲》笔记</h1><h2 id="基础架构：一条-SQL-查询语句是如何执行的？"><a href="#基础架构：一条-SQL-查询语句是如何执行的？" class="headerlink" title="基础架构：一条 SQL 查询语句是如何执行的？"></a>基础架构：一条 SQL 查询语句是如何执行的？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720195101.png"></p>
<ol>
<li><strong>连接器</strong>：连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
<li><strong>查询缓存</strong>：命中缓存，则直接返回结果。弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。</li>
<li><strong>分析器</strong><ul>
<li><strong>词法分析</strong>：解析 SQL 关键字</li>
<li><strong>语法分析</strong>：生成一颗对应的语法解析树</li>
</ul>
</li>
<li><strong>优化器</strong><ul>
<li>根据语法树<strong>生成多种执行计划</strong></li>
<li><strong>索引选择</strong>：根据策略选择最优方式</li>
</ul>
</li>
<li><strong>执行器</strong><ul>
<li>校验读写权限</li>
<li>根据执行计划，调用存储引擎的 API 来执行查询</li>
</ul>
</li>
<li><strong>存储引擎</strong>：存储数据，提供读写接口</li>
</ol>
<h2 id="日志系统：一条-SQL-更新语句是如何执行的？"><a href="#日志系统：一条-SQL-更新语句是如何执行的？" class="headerlink" title="日志系统：一条 SQL 更新语句是如何执行的？"></a>日志系统：一条 SQL 更新语句是如何执行的？</h2><p>更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：</p>
<ul>
<li>redo log（重做日志）</li>
<li>binlog（归档日志）</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 采用了 WAL 技术（全程是 Write-Ahead Logging），它的关键点就是先写日志，再写磁盘。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720203348.png"></p>
<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p>
<p>redo log 和 binlog 的差异：</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>再来看一下：update 语句时的内部流程</p>
<ol>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720210120.png"></p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为什么日志需要“两阶段提交”</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。</p>
<ol>
<li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<ul>
<li>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</li>
<li>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li>
</ul>
</li>
<li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<h2 id="事务隔离：为什么你改了我还看不见？"><a href="#事务隔离：为什么你改了我还看不见？" class="headerlink" title="事务隔离：为什么你改了我还看不见？"></a>事务隔离：为什么你改了我还看不见？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220721072721.png"></p>
<h2 id="深入浅出索引"><a href="#深入浅出索引" class="headerlink" title="深入浅出索引"></a>深入浅出索引</h2><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>适用：只能用于等值查询</p>
<p>哈希索引的限制</p>
<ul>
<li><strong>无法用于排序</strong>：因为哈希索引数据不是按照索引值顺序存储的。</li>
<li><strong>不支持部分索引匹配查找</strong>：因为哈希索引时使用索引列的全部内容来进行哈希计算的。</li>
<li><strong>不能用索引中的值来避免读取行</strong>：因为哈希索引只包含哈希值和行指针，不存储字段。</li>
<li><strong>只支持等值比较查询</strong>（包括 &#x3D;、IN()、&lt;&#x3D;&gt;）；不支持任何范围查询</li>
<li>哈希索引非常快，除非有很多哈希冲突：<ul>
<li>出现哈希冲突时，必须遍历链表中所有行指针，逐行比较匹配</li>
<li>如果哈希冲突多的话，维护索引的代价会很高</li>
</ul>
</li>
</ul>
<p>哈希索引的应用</p>
<p>Mysql 中，只有 Memory 存储引擎显示支持哈希索引。</p>
<h4 id="有序数组索引"><a href="#有序数组索引" class="headerlink" title="有序数组索引"></a>有序数组索引</h4><p>有序数组索引在等值查询和范围查询场景中的性能都非常优秀。</p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，更新数据的时候，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，<strong>有序数组索引只适用于静态存储引擎</strong>。</p>
<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h4><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为 InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
<p>根据叶子节点的内容，索引类型分为主键索引（聚簇索引）和非主键索引（非聚簇索引）。</p>
<ul>
<li><strong>聚簇索引</strong>：叶子节点存储行数据。<ul>
<li>可以把相关数据保存在一起</li>
<li>数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用叶节点中的主键值</li>
</ul>
</li>
<li><strong>非聚簇索引</strong>：叶子节点存储主键。访问需要两次索引查找。<ul>
<li>第一次获得对应主键值</li>
<li>第二次去聚簇索引中查找对应行，即回表</li>
</ul>
</li>
</ul>
<p>B+ 树为了维护索引有序性，在插入新值的时候需要做动态调整。</p>
<ul>
<li>插入位置如果不是末尾，需要挪动后面的数据，空出位置。</li>
<li>更糟的情况是，如果待插入位置所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。<ul>
<li>这种情况下，性能自然会受影响。</li>
<li>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</li>
</ul>
</li>
<li>如果相邻的两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</li>
</ul>
<p>由于每个非主键索引的叶子节点上都是主键的值。<strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong>。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>什么场景适合用业务字段直接做主键的呢？</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>为什么不用二叉树？</p>
<p>要考虑尽量减少磁盘扫描。</p>
<h3 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h3><ul>
<li>索引基本原则<ul>
<li>索引不是越多越好，不要为所有列都创建索引</li>
<li>要尽量避免冗余和重复索引</li>
<li>要考虑删除未使用的索引</li>
<li>尽量的扩展索引，不要新建索引</li>
<li>频繁作为 WHERE 过滤条件的列应该考虑添加索引</li>
</ul>
</li>
<li>独立索引<ul>
<li>索引列不能是表达式的一部分，也不能是函数的参数</li>
<li>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</li>
</ul>
</li>
<li>前缀索引和索引选择性<ul>
<li>索引的选择性是指：不重复的索引值和数据表记录总数的比值。</li>
<li>选择性越高，查询效率越高使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li>
<li>order by 无法使用前缀索引，无法把前缀索引用作覆盖索引</li>
</ul>
</li>
<li>最左前缀匹配原则<ul>
<li>将选择性高的列或基数大的列优先排在多列索引最前列</li>
<li>匹配联合索引最左前缀的时候，如果遇到了范围查询，比如（&lt;）（&gt;）和 between 等，就会停止匹配。</li>
</ul>
</li>
<li>覆盖索引：索引上的信息足够满足查询请求，不需要回表查询数据。</li>
<li>使用索引扫描来排序：ORDER BY 的字段作为索引，这样命中索引的查询结果，不需要额外排序</li>
<li>&#x3D; 和 in 可以乱序：不需要考虑 &#x3D;、IN 等的顺序，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</li>
</ul>
<h2 id="全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><p><strong>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。</p>
<p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都 select 出来存成文本。</p>
<p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<p><strong>表锁的语法是 lock tables … read&#x2F;write。</strong>与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p><strong>另一类表级的锁是 MDL（metadata lock)。</strong>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。</p>
<h2 id="行锁功过：怎么减少行锁对性能的影响？"><a href="#行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="行锁功过：怎么减少行锁对性能的影响？"></a>行锁功过：怎么减少行锁对性能的影响？</h2><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p>
<p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为<strong>死锁</strong>。</p>
<p>当出现死锁以后，有两种策略：</p>
<ul>
<li><strong>进入等待，直到超时</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。<ul>
<li>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着如果此策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</li>
<li>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</li>
</ul>
</li>
<li><strong>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行</strong>。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。<ul>
<li>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</li>
<li>极端情况下，如果所有事务都要更新同一行：每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</li>
</ul>
</li>
</ul>
<p>减少死锁的主要方向，就是控制访问相同资源的并发事务量。</p>
<h2 id="事务到底是隔离的还是不隔离的"><a href="#事务到底是隔离的还是不隔离的" class="headerlink" title="事务到底是隔离的还是不隔离的"></a>事务到底是隔离的还是不隔离的</h2><h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726083656.png"></p>
<p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。</p>
<p>图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p>
<p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>
<p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726085300.png"></p>
<p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p><strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726085703.png"></p>
<h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726090537.png"></p>
<p><strong>事务的可重复读的能力是怎么实现的？</strong></p>
<p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<h2 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h2><p>普通索引和唯一索引的<strong>查询性能相差微乎其微</strong>。</p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>
<p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</p>
<h3 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h3><p>change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。</p>
<p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p>
<ul>
<li>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。</li>
<li>如果一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。</li>
</ul>
<h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>
<p>在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</p>
<p>特别地，在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726192619.png"></p>
<p>图 - 带 change buffer 的更新过程</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726192712.png"></p>
<p>图 - 带 change buffer 的读过程</p>
<p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</strong></p>
<p>由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。</p>
<h2 id="MySQL-为什么有时候会选错索引"><a href="#MySQL-为什么有时候会选错索引" class="headerlink" title="MySQL 为什么有时候会选错索引"></a>MySQL 为什么有时候会选错索引</h2><p>选择索引是优化器的工作。</p>
<p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。但是，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p>
<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p>
<p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>
<p><strong>如果发现 explain 的结果预估的 rows 值跟实际情况差距比较大，可以采用 analyze table t 命令来重新统计索引信息</strong>。</p>
<p>对于其他优化器误判的情况，你可以在应用端用 force index 来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。</p>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726194835.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726194844.png"></p>
<p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p>
<p>可以通过下面的方式来测试不同前缀长度的区分度：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>

<p>使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。</p>
<p>需要注意：使用前缀索引就用不上覆盖索引对查询性能的优化了，必须回表才能拿到该索引字段的完整信息。</p>
<p>如果前缀的区分度不够好的情况时如何处理？</p>
<p><strong>第一种方式是使用倒序存储</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>第二种方式是使用 hash 字段</strong></p>
<p>可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure>

<p>然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc=crc32(<span class="string">&#x27;input_id_card_string&#x27;</span>) and id_card=<span class="string">&#x27;input_id_card_string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这两种方式的对比：</p>
<ul>
<li>它们的<strong>相同点</strong>是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在 [ID_X, ID_Y] 的所有市民了。同样地，hash 字段的方式也只能支持等值查询。</li>
<li>它们的<strong>区别</strong>：<ul>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>
<li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>
<li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ul>
</li>
</ul>
<p>小结：</p>
<ol>
<li>直接创建完整索引，这样可能比较占用空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ol>
<h2 id="为什么我的-MySQL-会“抖”一下？"><a href="#为什么我的-MySQL-会“抖”一下？" class="headerlink" title="为什么我的 MySQL 会“抖”一下？"></a>为什么我的 MySQL 会“抖”一下？</h2><p>利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。</p>
<p>但是，由此也带来了内存脏页的问题。脏页会被后台线程自动 flush，也会由于数据页淘汰而触发 flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。</p>
<h2 id="为什么表数据删掉一半，表文件大小不变？"><a href="#为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="为什么表数据删掉一半，表文件大小不变？"></a>为什么表数据删掉一半，表文件大小不变？</h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p>
<ol>
<li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li>
<li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li>
</ol>
<p>我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
<p>要删掉 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p>
<p>如果删掉了一个数据页上的所有记录，则整个数据页就可以被复用了。</p>
<p>如果把整个表的数据删除，则所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p>
<p>delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。页分裂完成后，就可能产生空洞。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p>
<p>也就是说，经过大量增删改的表，都是可能是存在空洞的。</p>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>那么，如何收缩表空间，去除空洞呢？</p>
<p>可以使用 <code>alter table A engine=InnoDB</code> 命令来重建表。MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726203135.png"></p>
<p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。</p>
<p>在<strong>MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。</strong></p>
<ol>
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；</li>
<li>用临时文件替换表 A 的数据文件。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220726203250.png"></p>
<p>对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。</p>
<p>需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用 GitHub 开源的 gh-ost 来做。</p>
<p>optimize table、analyze table 和 alter table 这三种方式重建表的区别：</p>
<ul>
<li>从 MySQL 5.6 版本开始，alter table t engine &#x3D; InnoDB（也就是 recreate）默认的就是上面图 4 的流程了；</li>
<li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</li>
<li>optimize table t 等于 recreate+analyze。</li>
</ul>
<h2 id="count-这么慢，我该怎么办？"><a href="#count-这么慢，我该怎么办？" class="headerlink" title="count(*)这么慢，我该怎么办？"></a>count(*)这么慢，我该怎么办？</h2><p>不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>
<li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p><strong>为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢</strong></p>
<p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220727084306.png"></p>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。</p>
<ul>
<li>MyISAM 表虽然 count(*) 很快，但是不支持事务；</li>
<li>show table status 命令虽然返回很快，但是不准确；</li>
<li>InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<h3 id="保存计数"><a href="#保存计数" class="headerlink" title="保存计数"></a>保存计数</h3><p>可以使用 Redis 保存计数，但存在丢失更新一集数据不一致问题。</p>
<p>可以使用数据库其他表保存计数，但要用事务进行控制，增&#x2F;删数据时，同步改变计数。</p>
<h3 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h3><p><strong>对于 count(主键 id) 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
<p><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<p><strong>对于 count(字段) 来说</strong>：</p>
<ul>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>
</ul>
<p><strong>但是 count(*) 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>
<p>所以结论是：按照效率排序的话，<code>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</code>，所以我建议你，尽量使用 count(*)。</p>
<h2 id="order-by-是怎么工作的？"><a href="#order-by-是怎么工作的？" class="headerlink" title="order by 是怎么工作的？"></a><code>order by</code> 是怎么工作的？</h2><p>用 explain 命令查看执行计划时，Extra 这个字段中的“Using filesort”表示的就是需要排序。</p>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句执行流程如下所示 ：</p>
<ol>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li>
<li>从索引 city 找到第一个满足 city&#x3D;’杭州’条件的主键 id，也就是图中的 ID_X；</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li>
<li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li>
<li>按照排序结果取前 1000 行返回给客户端。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220728090300.png"></p>
<p>按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<p>外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</strong></p>
<h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>如果表的字段太多，导致单行太大，那么全字段排序的效率就不够好。</p>
<p>这种情况下，Mysql 可以采用 rowid 排序，相比于全字段排序，它的主要差异在于：</p>
<p>取行数据时，不取出整行，而只是取出 id 和用于排序的字段。当排序结束后，再根据 id 取出要查询的字段返回给客户端。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220728090919.png"></p>
<h3 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h3><p>如果内存足够大，Mysql 会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p>
<p>如果内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p>
<p>并不是所有的 order by 语句，都需要排序操作的。MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong>如果能保证排序字段命中索引，那么就无需再排序了。</p>
<p><strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p>
<h2 id="为什么这些-SQL-语句逻辑相同，性能却差异巨大？"><a href="#为什么这些-SQL-语句逻辑相同，性能却差异巨大？" class="headerlink" title="为什么这些 SQL 语句逻辑相同，性能却差异巨大？"></a>为什么这些 SQL 语句逻辑相同，性能却差异巨大？</h2><h3 id="函数操作会破坏索引有序性"><a href="#函数操作会破坏索引有序性" class="headerlink" title="函数操作会破坏索引有序性"></a>函数操作会破坏索引有序性</h3><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>由于在 t_modified 字段加了 month() 函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把 SQL 语句改成基于字段本身的范围查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>下面两个 SQL 的执行流程相同：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>交易编号 tradeid 这个字段上，本来就有索引，但是 explain 的结果却显示，这条语句需要走全表扫描。这是由于这条语句隐式增加了转换函数，而对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/* 操作步骤 */</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/* 步骤信息 */</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tradelog l, trade_detail d</span><br><span class="line"><span class="keyword">WHERE</span> d.tradeid <span class="operator">=</span> l.tradeid <span class="keyword">AND</span> l.id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"># 等价于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)<span class="operator">=</span>$L2.tradeid.value;</span><br><span class="line"></span><br><span class="line"># 不需要做字符编码转换</span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> l.operator</span><br><span class="line"><span class="keyword">FROM</span> tradelog l, trade_detail d</span><br><span class="line"><span class="keyword">WHERE</span> d.tradeid <span class="operator">=</span> l.tradeid <span class="keyword">AND</span> d.id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做比较。</p>
<h2 id="为什么我只查一行的语句，也执行这么慢？"><a href="#为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="为什么我只查一行的语句，也执行这么慢？"></a>为什么我只查一行的语句，也执行这么慢？</h2><h3 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h3><p>查询结果长时间不返回。</p>
<p>一般碰到这种情况的话，大概率是表被锁住了。接下来分析原因的时候，一般都是首先执行一下 show processlist 命令，看看当前语句处于什么状态。</p>
<p>使用 show processlist 命令查看 Waiting for table metadata lock 的示意图</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220801160916.png"></p>
<p>出现<strong>这个状态表示的是，现在有一个线程正在表 t 上请求或者持有 MDL 写锁，把 select 语句堵住了。</strong></p>
<h2 id="幻读是什么，幻读有什么问题？"><a href="#幻读是什么，幻读有什么问题？" class="headerlink" title="幻读是什么，幻读有什么问题？"></a>幻读是什么，幻读有什么问题？</h2><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p>
<h3 id="幻读是什么"><a href="#幻读是什么" class="headerlink" title="幻读是什么"></a>幻读是什么</h3><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<p>说明：</p>
<ul>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
<li>幻读专指“新插入的行”。</li>
</ul>
<h3 id="幻读有什么问题"><a href="#幻读有什么问题" class="headerlink" title="幻读有什么问题"></a>幻读有什么问题</h3><ul>
<li>语义上的破坏</li>
<li>数据一致性的问题</li>
<li>即使把所有记录都加上锁，还是阻止不了新插入的记录</li>
</ul>
<h3 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h3><ul>
<li>间隙锁（<code>gap lock</code>）</li>
<li><code>select * from t where d=5 for update</code>，不止给数据库已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新纪录</li>
<li>next-key lock 是前开后闭区间</li>
<li>间隙锁和行锁合称为 <code>next-key lock</code></li>
<li>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</li>
<li><strong>间隙锁是在可重复读隔离级别下才会生效的</strong>，所以把隔离级别设置为读提交的话，就没有间隙锁了。但同时，要解决可能出现的数据和日志不一致的问题，需要把<code>binlog</code>格式设置为<code>row</code>。</li>
</ul>
<p>间隙锁和<code>next-key lock</code>的引入，帮我们解决了幻读问题，但同时也带来了一些困扰</p>
<ul>
<li>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响并发度的</li>
</ul>
<h2 id="为什么我只改一行的语句，锁这么多？"><a href="#为什么我只改一行的语句，锁这么多？" class="headerlink" title="为什么我只改一行的语句，锁这么多？"></a>为什么我只改一行的语句，锁这么多？</h2><p><strong>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol>
<li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<h2 id="MySQL-有哪些“饮鸩止渴”提高性能的方法？"><a href="#MySQL-有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="MySQL 有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL 有哪些“饮鸩止渴”提高性能的方法？</h2><h4 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h4><p>短连接模式就是连接到数据库后，执行很少的 SQL 语句就断开，下次需要的时候再重连。</p>
<ul>
<li>MySQL 建立连接的成本很高。<ul>
<li>除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</li>
</ul>
</li>
<li>短连接模型存在一个风险：一旦数据库处理速度很慢，连接数就会暴涨。</li>
<li><strong><code>max_connections</code> 控制一个 MySQL 实例同时存在的连接数的上限</strong>。<ul>
<li>超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</li>
</ul>
</li>
</ul>
<h4 id="解决方法-1：先处理掉那些占着连接但是不工作的线程"><a href="#解决方法-1：先处理掉那些占着连接但是不工作的线程" class="headerlink" title="解决方法 1：先处理掉那些占着连接但是不工作的线程"></a>解决方法 1：先处理掉那些占着连接但是不工作的线程</h4><ul>
<li><code>show processlist</code> 查看 <code>sleep</code> 的线程，然后干掉空闲的连接。注意：可能会误杀事务。</li>
<li>应该优先断开事务外空闲的连接。<ul>
<li>通过查 <code>information_schema</code> 库的 <code>innodb_trx</code> 表判断是否处于事务中。</li>
</ul>
</li>
<li>再考虑断开事务内空闲太久的连接。</li>
</ul>
<h4 id="解决方法-2：减少连接过程的消耗"><a href="#解决方法-2：减少连接过程的消耗" class="headerlink" title="解决方法 2：减少连接过程的消耗"></a>解决方法 2：减少连接过程的消耗</h4><p>如果想短时间创建大量数据库连接，有一种做法是跳过权限验证。</p>
<p>跳过权限验证的方法是：重启数据库，并使用 <code>–skip-grant-tables</code> 参数启动。</p>
<p>注意：此方法风险极高，不建议使用。</p>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><p>一般有三种可能：</p>
<ol>
<li>索引没有设计好；</li>
<li>SQL 语句没写好；</li>
<li>MySQL 选错了索引。<ul>
<li>可以通过 <code>force index</code> 强制使用某个索引</li>
</ul>
</li>
</ol>
<h3 id="QPS-突增问题"><a href="#QPS-突增问题" class="headerlink" title="QPS 突增问题"></a>QPS 突增问题</h3><p>有时候由于业务突然出现高峰，或者应用程序 bug，导致某个语句的 QPS 突然暴涨，也可能导致 MySQL 压力过大，影响服务。</p>
<p>应对方法：</p>
<ol>
<li>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li>
<li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</li>
<li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成”select 1”返回。<ul>
<li>这个方法是用于止血的，但风险很高，不建议使用。</li>
</ul>
</li>
</ol>
<p>个人观点：以上方法都是基于 DBA 视角的处理方式。实际环境中，应该做好数据库 QPS、CPU 监控，如果发现请求量激增，快要达到瓶颈，可以先紧急弹性扩容，保障业务不损失。然后排查原因，是否是新业务设计不当导致、是否是大数据在也业务高峰期进行数据分析导致，等等。</p>
<h2 id="Mysql-是怎么保证数据不丢的"><a href="#Mysql-是怎么保证数据不丢的" class="headerlink" title="Mysql 是怎么保证数据不丢的"></a>Mysql 是怎么保证数据不丢的</h2><p>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。</p>
<h3 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h3><p>binglog 写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220802060429.png"></p>
<p>一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。</p>
<p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。</p>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<ol>
<li>sync_binlog&#x3D;0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog&#x3D;1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog&#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ol>
<h3 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h3><p>redo log 要先写到 redo log buffer</p>
<p>innodb_flush_log_at_trx_commit 参数用于控制 redo log buffer 写入 page cache 和写入磁盘的时机</p>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。</p>
<p>还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。</p>
<ol>
<li>一种是，redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。</li>
<li>另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</li>
</ol>
<h3 id="如果-MySQL-出现了-IO-性能瓶颈，可以通过哪些方法来提升性能"><a href="#如果-MySQL-出现了-IO-性能瓶颈，可以通过哪些方法来提升性能" class="headerlink" title="如果 MySQL 出现了 IO 性能瓶颈，可以通过哪些方法来提升性能"></a>如果 MySQL 出现了 IO 性能瓶颈，可以通过哪些方法来提升性能</h3><p>WAL 机制主要得益于两个方面：</p>
<ol>
<li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</li>
</ol>
<p>有三种方法提升 Mysql IO 性能：</p>
<ul>
<li><p>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</p>
<ul>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ul>
</li>
<li><p>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</p>
</li>
<li><p>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</p>
</li>
</ul>
<h2 id="Mysql-是怎么保证主备一致的"><a href="#Mysql-是怎么保证主备一致的" class="headerlink" title="Mysql 是怎么保证主备一致的"></a>Mysql 是怎么保证主备一致的</h2><h3 id="MySQL-主备的基本原理"><a href="#MySQL-主备的基本原理" class="headerlink" title="MySQL 主备的基本原理"></a>MySQL 主备的基本原理</h3><p>MySQL 主备切换流程</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220802062247.png"></p>
<p>客户端的读写都直接访问主库，备库只是将主库的更新都同步过来，到本地执行。</p>
<p>建议将备库设为 readonly 模式：</p>
<ul>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；</li>
<li>可以用 readonly 状态，来判断节点的角色。</li>
</ul>
<p>readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p>
<p>备库跟主库之间维持了一个长连接。主库内部有一个线程，专门用于服务备库的这个长连接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库上通过 change master 命令，设置主库的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li>
<li>主库校验完用户名、密码后，开始按照备库传过来的位置，从本地读取 binlog，发给备库。</li>
<li>备库拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<h3 id="binlog-三种格式对比"><a href="#binlog-三种格式对比" class="headerlink" title="binlog 三种格式对比"></a>binlog 三种格式对比</h3><p>binlog 有两种格式，一种是 statement，一种是 row</p>
<p>当 binlog_format&#x3D;statement 时，binlog 里面记录的就是 SQL 语句的原文。</p>
<p>当 binlog_format&#x3D;row 时，binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p>
<ol>
<li>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</li>
<li>Delete_rows event，用于定义删除的行为。</li>
</ol>
<p>为什么会有 mixed 这种 binlog 格式的存在场景？</p>
<ul>
<li><p>有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。</p>
</li>
<li><p>row 格式很占空间</p>
</li>
<li><p>mixed 格式的 binlog，是指 MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</p>
</li>
</ul>
<h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>如果两个节点互为主备，就可能出现循环复制问题。</p>
<p>如何解决循环复制问题：</p>
<ol>
<li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<h2 id="Mysql-是怎么保证高可用的"><a href="#Mysql-是怎么保证高可用的" class="headerlink" title="Mysql 是怎么保证高可用的"></a>Mysql 是怎么保证高可用的</h2><h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值。</p>
<p>show slave status 命令可用于显示备库延迟（seconds_behind_master），其计算方式如下：</p>
<ol>
<li>每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。</li>
</ol>
<p>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。</p>
<h3 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h3><ul>
<li>备库的机器性能比主库的机器性能差。<ul>
<li>一般应采用对称部署。</li>
</ul>
</li>
<li>备库的压力大。<ul>
<li>因为一般会采用读写分离架构，备库承担读请求，反而导致备库压力过大。</li>
<li>解决方法：<ul>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li>
<li>通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。</li>
</ul>
</li>
</ul>
</li>
<li>大事务<ul>
<li>不要一次性地用 delete 语句删除太多数据</li>
<li>大表 DDL：计划内的 DDL，建议使用 gh-ost 方案</li>
<li>备库的并行复制</li>
</ul>
</li>
</ul>
<h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><ol>
<li>判断备库现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li>
<li>把主库改成只读状态，即把 readonly 设置为 true；</li>
<li>判断备库的 seconds_behind_master 的值，直到这个值变成 0 为止；</li>
<li>把备库改成可读写状态，也就是把 readonly 设置为 false；</li>
<li>把业务请求切到备库。</li>
</ol>
<p>这个切换流程，一般是由专门的 HA 系统来完成的，我们暂时称之为可靠性优先流程。</p>
<h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><p>如果强行把步骤 4、5 调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库，并且让备库可以读写，那么系统几乎就没有不可用时间了。</p>
<p>我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220802065420.png"></p>
<h2 id="备库为什么会延迟好几个小时"><a href="#备库为什么会延迟好几个小时" class="headerlink" title="备库为什么会延迟好几个小时"></a>备库为什么会延迟好几个小时</h2><h3 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220802070053.png"></p>
<p>每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。hash 表的 key 是“库名. 表名”，value 是一个数字，表示队列中有多少个事务修改这个表。</p>
<p>在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。</p>
<p>事务在分发时，有三种情况：</p>
<ol>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</li>
</ol>
<p>这种方案在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个 worker，分配一个 hash 表。只是要实现按行分发，这时候的 key，就必须是“库名 + 表名 + 唯一键的值”。</p>
<p>这个“唯一键”只有主键 id 是不够的，还需要考虑唯一键。即 key 应该是“库名 + 表名 + 索引 a 的名字 +a 的值”。因此，coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项:</p>
<ol>
<li>key&#x3D;hash_func(db1+t1+“PRIMARY”+2), value&#x3D;2; 这里 value&#x3D;2 是因为修改前后的行 id 值不变，出现了两次。</li>
<li>key&#x3D;hash_func(db1+t1+“a”+2), value&#x3D;1，表示会影响到这个表 a&#x3D;2 的行。</li>
<li>key&#x3D;hash_func(db1+t1+“a”+1), value&#x3D;1，表示会影响到这个表 a&#x3D;1 的行。</li>
</ol>
<p>可见，<strong>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</strong></p>
<h3 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h3><p>官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是按库并行。</p>
<h3 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h3><p>MariaDB 的并行复制策略利用的就是这个特性：</p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行；</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li>
</ol>
<p>在实现上，MariaDB 是这么做的：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ol>
<h3 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h3><p>由参数 slave-parallel-type 来控制并行复制策略：</p>
<ol>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</li>
<li>配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略。不过，MySQL 5.7 这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。</li>
</ol>
<h2 id="主库出问题了，从库怎么办？"><a href="#主库出问题了，从库怎么办？" class="headerlink" title="主库出问题了，从库怎么办？"></a>主库出问题了，从库怎么办？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220803070027.png"></p>
<p>A 和 A’互为主备， 从库 B、C、D 指向的是主库 A</p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST<span class="operator">=</span>$host_name</span><br><span class="line">MASTER_PORT<span class="operator">=</span>$port</span><br><span class="line">MASTER_USER<span class="operator">=</span>$user_name</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span>$password</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span>$master_log_name</span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span>$master_log_pos</span><br></pre></td></tr></table></figure>

<ul>
<li>MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</li>
<li>最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。</li>
</ul>
<p>主备切换时，由于找不到精确的同步位点，所以只能采用直接跳过指定错误这种方法来创建从库和新主库的主备关系。</p>
<ul>
<li>通过 sql_slave_skip_counter 跳过事务</li>
<li>通过 slave_skip_errors 忽略错误</li>
</ul>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><p>GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。GTID 由两部分组成：<code>GTID=server_uuid:gno</code></p>
<ul>
<li><strong>server_uuid</strong>：是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li>
<li><strong>gno</strong>：是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。</li>
</ul>
<p>启动 Mysql 时，加上参数 gtid_mode&#x3D;on 和 enforce_gtid_consistency&#x3D;on 就可以启动 GTID 模式。在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。</p>
<p>在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line"><span class="attribute">MASTER_HOST</span>=<span class="variable">$host_name</span></span><br><span class="line"><span class="attribute">MASTER_PORT</span>=<span class="variable">$port</span></span><br><span class="line"><span class="attribute">MASTER_USER</span>=<span class="variable">$user_name</span></span><br><span class="line"><span class="attribute">MASTER_PASSWORD</span>=<span class="variable">$password</span></span><br><span class="line"><span class="attribute">master_auto_position</span>=1</span><br></pre></td></tr></table></figure>

<p>找位点的工作，由 Mysql 内部完成。</p>
<h2 id="读写分离有哪些坑"><a href="#读写分离有哪些坑" class="headerlink" title="读写分离有哪些坑"></a>读写分离有哪些坑</h2><p>读写分离的主要目标就是分摊主库的压力。</p>
<p>还有一种架构是，在 MySQL 和客户端之间有一个中间代理层 proxy，客户端只连接 proxy， 由 proxy 根据请求类型和上下文决定请求的分发路由。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220803071504.png"></p>
<p>客户端直连 vs. 带 proxy 的读写分离</p>
<ul>
<li>客户端直连方案：因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。<ul>
<li>你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
</ul>
</li>
<li>带 proxy 的架构：对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。</li>
</ul>
<p>解决主从延迟的方案：</p>
<ul>
<li>强制走主库方案；</li>
<li>sleep 方案；</li>
<li>判断主备无延迟方案；</li>
<li>配合 semi-sync 方案；</li>
<li>等主库位点方案；</li>
<li>等 GTID 方案。</li>
</ul>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类。</p>
<ol>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li>
</ol>
<h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。</p>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>show slave status 结果里的 seconds_behind_master 参数的值，可以用来衡量主备延迟时间的长短。</p>
<p>所以<strong>第一种确保主备无延迟的方法是，</strong>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。</p>
<p><strong>第二种方法，</strong>对比位点确保主备无延迟：</p>
<ul>
<li>Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li>
<li>Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li>
</ul>
<p>如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<p><strong>第三种方法，</strong>对比 GTID 集合确保主备无延迟：</p>
<ul>
<li>Auto_Position&#x3D;1 ，表示这对主备关系使用了 GTID 协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<p>可见，对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。</p>
<h3 id="配合-semi-sync"><a href="#配合-semi-sync" class="headerlink" title="配合 semi-sync"></a>配合 semi-sync</h3><p>semi-sync replication 即半同步复制。</p>
<p>semi-sync 做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p>
<p>semi-sync 配合判断主备无延迟的方案，存在两个问题：</p>
<ol>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ol>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select master<span class="constructor">_pos_wait(<span class="params">file</span>, <span class="params">pos</span>[, <span class="params">timeout</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>命令的逻辑如下：</p>
<ol>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</li>
</ol>
<h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><p>如果你的数据库开启了 GTID 模式</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">wait_for_executed_gtid_set</span>(<span class="params">gtid_set, <span class="number">1</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这条命令的逻辑是：</p>
<ol>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ol>
<h2 id="如何判断一个数据库是不是出问题了"><a href="#如何判断一个数据库是不是出问题了" class="headerlink" title="如何判断一个数据库是不是出问题了"></a>如何判断一个数据库是不是出问题了</h2><h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><p>select 1 成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p>
<h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况，我们需要找一个访问 InnoDB 的场景。一般的做法是，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check;</span><br></pre></td></tr></table></figure>

<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。</p>
<p>更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p>
<h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `health_check` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(id, t_modified) <span class="keyword">values</span> (@<span class="variable">@server</span>_id, now()) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure>

<p>由于 MySQL 规定了主库和备库的 server_id 必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p>
<p><strong>更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定慢的问题呢？</strong></p>
<p>IO 利用率 100% 表示系统的 IO 是在工作的，每个请求都有机会获得 IO 资源，执行自己的任务。而我们的检测使用的 update 命令，需要的资源很少，所以可能在拿到 IO 资源的时候就可以提交成功，并且在超时时间 N 秒未到达之前就返回给了检测系统。</p>
<p>检测系统一看，update 命令没有超时，于是就得到了“系统正常”的结论。</p>
<h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>MySQL 5.6 版本以后提供的 performance_schema 库，就在 file_summary_by_event_name 表里统计了每次 IO 请求的时间。</p>
<p>打开 redo log 的时间监控</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> setup_instruments <span class="keyword">set</span> ENABLED<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span>, Timed<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%wait/io/file/innodb/innodb_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过 MAX_TIMER 的值来判断数据库是否出问题了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> event_name,MAX_TIMER_WAIT  <span class="keyword">FROM</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> event_name <span class="keyword">in</span> (<span class="string">&#x27;wait/io/file/innodb/innodb_log_file&#x27;</span>,<span class="string">&#x27;wait/io/file/sql/binlog&#x27;</span>) <span class="keyword">and</span> MAX_TIMER_WAIT<span class="operator">&gt;</span><span class="number">200</span><span class="operator">*</span><span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure>

<p>发现异常后，取到你需要的信息，再通过下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure>

<p>把之前的统计信息清空。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值了。</p>
<h2 id="答疑文章（二）：用动态的观点看加锁"><a href="#答疑文章（二）：用动态的观点看加锁" class="headerlink" title="答疑文章（二）：用动态的观点看加锁"></a>答疑文章（二）：用动态的观点看加锁</h2><h2 id="误删数据后除了跑路还能怎么办？"><a href="#误删数据后除了跑路还能怎么办？" class="headerlink" title="误删数据后除了跑路还能怎么办？"></a>误删数据后除了跑路还能怎么办？</h2><h3 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h3><p>事后处理：</p>
<ul>
<li>使用 delete 语句误删了数据行，可以用 Flashback 工具通过闪回把数据恢复回来。</li>
<li>Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保 binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。</li>
</ul>
<p>事前预防：</p>
<ul>
<li>把 sql_safe_updates 参数设置为 on。这样一来，如果我们忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话，这条语句的执行就会报错。</li>
<li>代码上线前，必须经过 SQL 审计。</li>
</ul>
<h3 id="误删库-x2F-表"><a href="#误删库-x2F-表" class="headerlink" title="误删库 &#x2F; 表"></a>误删库 &#x2F; 表</h3><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份 binlog。</p>
<p>恢复数据的流程如下：</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</li>
<li>用备份恢复出一个临时库；</li>
<li>从日志备份里面，取出凌晨 0 点之后的日志；</li>
<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>
</ol>
<h4 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h4><p>一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p>
<p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。只要在延迟时间内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行 stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p>
<h4 id="预防误删库-x2F-表的方法"><a href="#预防误删库-x2F-表的方法" class="headerlink" title="预防误删库 &#x2F; 表的方法"></a>预防误删库 &#x2F; 表的方法</h4><p>第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：</p>
<ul>
<li>我们只给业务开发同学 DML 权限，而不给 truncate&#x2F;drop 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持。</li>
<li>即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li>
</ul>
<p>第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p>
<ul>
<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li>
<li>改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li>
</ul>
<h3 id="rm-删除数据"><a href="#rm-删除数据" class="headerlink" title="rm 删除数据"></a>rm 删除数据</h3><p>对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p>
<p>这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p>
<h2 id="为什么还有-kill-不掉的语句"><a href="#为什么还有-kill-不掉的语句" class="headerlink" title="为什么还有 kill 不掉的语句"></a>为什么还有 kill 不掉的语句</h2><p>MySQL 中有两个 kill 命令：一个是 kill query + 线程 id，表示终止这个线程中正在执行的语句；一个是 kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</p>
<h3 id="收到-kill-以后，线程做什么？"><a href="#收到-kill-以后，线程做什么？" class="headerlink" title="收到 kill 以后，线程做什么？"></a>收到 kill 以后，线程做什么？</h3><p><strong>当用户执行 kill query thread_id_B 时，MySQL 里处理 kill 命令的线程做了两件事：</strong></p>
<ol>
<li>把 session B 的运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；</li>
<li>给 session B 的执行线程发一个信号。</li>
</ol>
<p>kill 不掉语句的情况</p>
<ul>
<li><strong>线程没有执行到判断线程状态的逻辑</strong></li>
<li><strong>终止逻辑耗时较长</strong><ul>
<li>超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li>
<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。</li>
<li>DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。</li>
</ul>
</li>
</ul>
<h3 id="关于客户端的误解"><a href="#关于客户端的误解" class="headerlink" title="关于客户端的误解"></a>关于客户端的误解</h3><p><strong>如果库里面的表特别多，连接就会很慢。</strong></p>
<p>客户端在连接成功后，需要多做一些操作：</p>
<ol>
<li>执行 show databases；</li>
<li>切到 db1 库，执行 show tables；</li>
<li>把这两个命令的结果用于构建一个本地的哈希表。</li>
</ol>
<p><strong>我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。</strong></p>
<h2 id="我查了这么多数据会不会把数据库内存打爆"><a href="#我查了这么多数据会不会把数据库内存打爆" class="headerlink" title="我查了这么多数据会不会把数据库内存打爆"></a>我查了这么多数据会不会把数据库内存打爆</h2><h3 id="全表扫描对-server-层的影响"><a href="#全表扫描对-server-层的影响" class="headerlink" title="全表扫描对 server 层的影响"></a>全表扫描对 server 层的影响</h3><p><strong>MySQL 是“边读边发的”</strong></p>
<p>InnoDB 的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表 t 的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p>
<p>查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，并不会把内存打爆。</p>
<h3 id="全表扫描对-InnoDB-的影响"><a href="#全表扫描对-InnoDB-的影响" class="headerlink" title="全表扫描对 InnoDB 的影响"></a>全表扫描对 InnoDB 的影响</h3><p>对于 InnoDB 引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于 InnoDB 对 LRU 算法做了改进，冷数据的全表扫描，对 Buffer Pool 的影响也能做到可控。</p>
<h2 id="到底可不可以使用-join"><a href="#到底可不可以使用-join" class="headerlink" title="到底可不可以使用 join"></a>到底可不可以使用 join</h2><ol>
<li>如果可以使用被驱动表的索引，join 语句还是有其优势的；</li>
<li>不能使用被驱动表的索引，只能使用 Block Nested-Loop Join 算法，这样的语句就尽量不要使用；</li>
<li>在使用 join 的时候，应该让小表做驱动表。</li>
</ol>
<h2 id="join-语句如何优化"><a href="#join-语句如何优化" class="headerlink" title="join 语句如何优化"></a>join 语句如何优化</h2><p><strong>大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p>
<h3 id="MRR"><a href="#MRR" class="headerlink" title="MRR"></a>MRR</h3><p>MRR 优化后的语句执行流程：</p>
<ol>
<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li>
<li>将 read_rnd_buffer 中的 id 进行递增排序；</li>
<li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li>
</ol>
<p>这里，read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p>
<p><strong>MRR 能够提升性能的核心</strong>在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。临时表在使用上有以下几个特点：</p>
<ol>
<li>建表语法是 create temporary table …。</li>
<li>一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的。</li>
<li>临时表可以与普通表同名。</li>
<li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li>
<li>show tables 命令不显示临时表。</li>
</ol>
<h2 id="为什么临时表可以重名"><a href="#为什么临时表可以重名" class="headerlink" title="为什么临时表可以重名"></a>为什么临时表可以重名</h2><p>临时表在使用上有以下几个特点：</p>
<ol>
<li>建表语法是 create temporary table …。</li>
<li>一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的。</li>
<li>临时表可以与普通表同名。</li>
<li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li>
<li>show tables 命令不显示临时表。</li>
</ol>
<p><strong>临时表特别适合 join 优化这种场景</strong>，原因是：</p>
<ol>
<li>不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。</li>
<li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li>
</ol>
<h3 id="临时表的应用"><a href="#临时表的应用" class="headerlink" title="临时表的应用"></a>临时表的应用</h3><p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p>
<p>分库分表两种实现思路：</p>
<p><strong>第一种思路是，</strong>在 proxy 层的进程代码中实现排序。</p>
<p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p>
<ol>
<li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高；</li>
<li>对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。</li>
</ol>
<p><strong>另一种思路就是，</strong>把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。</p>
<p>比如上面这条语句，执行流程可以类似这样：</p>
<ul>
<li>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified；</li>
<li>在各个分库上执行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> v,k,t_modified <span class="keyword">from</span> ht_x <span class="keyword">where</span> k <span class="operator">&gt;=</span> M <span class="keyword">order</span> <span class="keyword">by</span> t_modified <span class="keyword">desc</span> limit <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>把分库执行的结果插入到 temp_ht 表中；</li>
<li>执行</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> v <span class="keyword">from</span> temp_ht <span class="keyword">order</span> <span class="keyword">by</span> t_modified <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>得到结果。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220828152038.png"></p>
<p><strong>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表 temp_ht 放到 32 个分库中的某一个上。</strong></p>
<h2 id="什么时候会使用内部临时表"><a href="#什么时候会使用内部临时表" class="headerlink" title="什么时候会使用内部临时表"></a>什么时候会使用内部临时表</h2><ol>
<li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li>
<li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li>
<li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li>
<li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li>
</ol>
<h2 id="都说-InnoDB-好，那还要不要使用-Memory-引擎"><a href="#都说-InnoDB-好，那还要不要使用-Memory-引擎" class="headerlink" title="都说 InnoDB 好，那还要不要使用 Memory 引擎"></a>都说 InnoDB 好，那还要不要使用 Memory 引擎</h2><p>InnoDB 和 Memory 引擎的数据组织方式是不同的：</p>
<ul>
<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为<strong>索引组织表</strong>（Index Organizied Table）。</li>
<li>而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为<strong>堆组织表</strong>（Heap Organizied Table）。</li>
</ul>
<p>内存表不支持行锁，只支持表锁。</p>
<p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p>
<h2 id="自增主键为什么不是连续的"><a href="#自增主键为什么不是连续的" class="headerlink" title="自增主键为什么不是连续的"></a>自增主键为什么不是连续的</h2><p><strong>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。</strong></p>
<p>在 MyISAM 引擎里面，自增值是被写在数据文件上的。而在 InnoDB 中，自增值是被记录在内存的。</p>
<p>InnoDB 中，只保证了自增 id 是递增的，但不保证是连续的。这么做是处于性能考虑：语句执行失败也不回退自增 id。</p>
<h2 id="insert-语句的锁为什么这么多"><a href="#insert-语句的锁为什么这么多" class="headerlink" title="insert 语句的锁为什么这么多"></a>insert 语句的锁为什么这么多</h2><p>insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给 select 的表里扫描到的记录和间隙加读锁。</p>
<p>而如果 insert 和 select 的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化。</p>
<p>insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的 next-key lock(S 锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p>
<h2 id="怎么最快地复制一张表"><a href="#怎么最快地复制一张表" class="headerlink" title="怎么最快地复制一张表"></a>怎么最快地复制一张表</h2><h3 id="mysqldump-方法"><a href="#mysqldump-方法" class="headerlink" title="mysqldump 方法"></a>mysqldump 方法</h3><p>使用 mysqldump 命令将数据导出成一组 INSERT 语句。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h<span class="variable">$host</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> <span class="attribute">--add-locks</span>=0 --no-create-<span class="built_in">info</span> --single-transaction  <span class="attribute">--set-gtid-purged</span>=OFF db1 t <span class="attribute">--where</span>=<span class="string">&quot;a&gt;900&quot;</span> <span class="attribute">--result-file</span>=/client_tmp/t.sql</span><br></pre></td></tr></table></figure>

<p>这条命令中，主要参数含义如下：</p>
<ol>
<li>–single-transaction 的作用是，在导出数据的时候不需要对表 db1.t 加表锁，而是使用 START TRANSACTION WITH CONSISTENT SNAPSHOT 的方法；</li>
<li>–add-locks 设置为 0，表示在输出的文件结果里，不增加” LOCK TABLES <code>t</code> WRITE;” ；</li>
<li>–no-create-info 的意思是，不需要导出表结构；</li>
<li>–set-gtid-purged&#x3D;off 表示的是，不输出跟 GTID 相关的信息；</li>
<li>–result-file 指定了输出文件的路径，其中 client 表示生成的文件是在客户端机器上的。</li>
</ol>
<h3 id="导出-CSV-文件"><a href="#导出-CSV-文件" class="headerlink" title="导出 CSV 文件"></a>导出 CSV 文件</h3><p>另一种方法是直接将结果导出成.csv 文件</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> db1.t <span class="keyword">where</span> a&gt;<span class="number">900</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/server_tmp/t.csv&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><p>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；</li>
<li>执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</li>
<li>在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL 进程要有读写权限）；</li>
<li>执行 unlock tables，这时候 t.cfg 文件会被删除；</li>
<li>执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li>
</ol>
<h2 id="grant-之后为什么要跟着-flush-privilege"><a href="#grant-之后为什么要跟着-flush-privilege" class="headerlink" title="grant 之后为什么要跟着 flush privilege"></a>grant 之后为什么要跟着 flush privilege</h2><p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用 grant 和 revoke 语句，是不需要随后加上 flush privileges 语句的。</p>
<p>flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p>
<h2 id="要不要使用分区表"><a href="#要不要使用分区表" class="headerlink" title="要不要使用分区表"></a>要不要使用分区表</h2><h2 id="自增-ID-用完了怎么办"><a href="#自增-ID-用完了怎么办" class="headerlink" title="自增 ID 用完了怎么办"></a>自增 ID 用完了怎么办</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e438a7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e438a7/" class="post-title-link" itemprop="url">SQL Cheat Sheet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-16 14:17:08" itemprop="dateCreated datePublished" datetime="2022-07-16T14:17:08+08:00">2022-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SQL-Cheat-Sheet"><a href="#SQL-Cheat-Sheet" class="headerlink" title="SQL Cheat Sheet"></a>SQL Cheat Sheet</h1><h2 id="查找数据的查询"><a href="#查找数据的查询" class="headerlink" title="查找数据的查询"></a>查找数据的查询</h2><h3 id="SELECT-用于从数据库中选择数据"><a href="#SELECT-用于从数据库中选择数据" class="headerlink" title="SELECT: 用于从数据库中选择数据"></a><strong>SELECT</strong>: 用于从数据库中选择数据</h3><ul>
<li><code>SELECT</code> * <code>FROM</code> table_name;</li>
</ul>
<h3 id="DISTINCT-用于过滤掉重复的值并返回指定列的行"><a href="#DISTINCT-用于过滤掉重复的值并返回指定列的行" class="headerlink" title="DISTINCT: 用于过滤掉重复的值并返回指定列的行"></a><strong>DISTINCT</strong>: 用于过滤掉重复的值并返回指定列的行</h3><ul>
<li><code>SELECT DISTINCT</code> column_name;</li>
</ul>
<h3 id="WHERE-用于过滤记录-x2F-行"><a href="#WHERE-用于过滤记录-x2F-行" class="headerlink" title="WHERE: 用于过滤记录&#x2F;行"></a><strong>WHERE</strong>: 用于过滤记录&#x2F;行</h3><ul>
<li><code>SELECT</code> column1, column2 <code>FROM</code> table_name <code>WHERE</code> condition;</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> condition1 <code>AND</code> condition2;</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> condition1 <code>OR</code> condition2;</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE NOT</code> condition;</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> condition1 <code>AND</code> (condition2 <code>OR</code> condition3);</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE EXISTS</code> (<code>SELECT</code> column_name <code>FROM</code> table_name <code>WHERE</code> condition);</li>
</ul>
<h3 id="ORDER-BY-用于结果集的排序，升序（ASC）或者降序（DESC）"><a href="#ORDER-BY-用于结果集的排序，升序（ASC）或者降序（DESC）" class="headerlink" title="ORDER BY: 用于结果集的排序，升序（ASC）或者降序（DESC）"></a><strong>ORDER BY</strong>: 用于结果集的排序，升序（ASC）或者降序（DESC）</h3><ul>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>ORDER BY</code> column;</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>ORDER BY</code> column <code>DESC</code>;</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>ORDER BY</code> column1 <code>ASC</code>, column2 <code>DESC</code>;</li>
</ul>
<h3 id="SELECT-TOP-用于指定从表顶部返回的记录数"><a href="#SELECT-TOP-用于指定从表顶部返回的记录数" class="headerlink" title="SELECT TOP: 用于指定从表顶部返回的记录数"></a><strong>SELECT TOP</strong>: 用于指定从表顶部返回的记录数</h3><ul>
<li><code>SELECT TOP</code> number columns_names <code>FROM</code> table_name <code>WHERE</code> condition;</li>
<li><code>SELECT TOP</code> percent columns_names <code>FROM</code> table_name <code>WHERE</code> condition;</li>
<li>并非所有数据库系统都支持<code>SELECT TOP</code>。 MySQL 中是<code>LIMIT</code>子句</li>
<li><code>SELECT</code> column_names <code>FROM</code> table_name <code>LIMIT</code> offset, count;</li>
</ul>
<h3 id="LIKE-用于搜索列中的特定模式，WHERE-子句中使用的运算符"><a href="#LIKE-用于搜索列中的特定模式，WHERE-子句中使用的运算符" class="headerlink" title="LIKE: 用于搜索列中的特定模式，WHERE 子句中使用的运算符"></a><strong>LIKE</strong>: 用于搜索列中的特定模式，WHERE 子句中使用的运算符</h3><ul>
<li>% (percent sign) 是一个表示零个，一个或多个字符的通配符</li>
<li>_ (underscore) 是一个表示单个字符通配符</li>
<li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>LIKE</code> pattern;</li>
<li><code>LIKE</code> ‘a%’ （查找任何以“a”开头的值）</li>
<li><code>LIKE</code> ‘%a’ （查找任何以“a”结尾的值）</li>
<li><code>LIKE</code> ‘%or%’ （查找任何包含“or”的值）</li>
<li><code>LIKE</code> ‘_r%’ （查找任何第二位是“r”的值）</li>
<li><code>LIKE</code> ‘a*%*%’ （查找任何以“a”开头且长度至少为 3 的值）</li>
<li><code>LIKE</code> ‘[a-c]%’（查找任何以“a”或“b”或“c”开头的值）</li>
</ul>
<h3 id="IN-用于在-WHERE-子句中指定多个值的运算符"><a href="#IN-用于在-WHERE-子句中指定多个值的运算符" class="headerlink" title="IN: 用于在 WHERE 子句中指定多个值的运算符"></a><strong>IN</strong>: 用于在 WHERE 子句中指定多个值的运算符</h3><ul>
<li>本质上，IN 运算符是多个 OR 条件的简写</li>
<li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>IN</code> (value1, value2, …);</li>
<li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>IN</code> (<code>SELECT STATEMENT</code>);</li>
</ul>
<h3 id="BETWEEN-用于过滤给定范围的值的运算符"><a href="#BETWEEN-用于过滤给定范围的值的运算符" class="headerlink" title="BETWEEN: 用于过滤给定范围的值的运算符"></a><strong>BETWEEN</strong>: 用于过滤给定范围的值的运算符</h3><ul>
<li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>BETWEEN</code> value1 <code>AND</code> value2;</li>
<li><code>SELECT</code> * <code>FROM</code> Products <code>WHERE</code> (column_name <code>BETWEEN</code> value1 <code>AND</code> value2) <code>AND NOT</code> column_name2 <code>IN</code> (value3, value4);</li>
<li><code>SELECT</code> * <code>FROM</code> Products <code>WHERE</code> column_name <code>BETWEEN</code> #01&#x2F;07&#x2F;1999# AND #03&#x2F;12&#x2F;1999#;</li>
</ul>
<h3 id="NULL-代表一个字段没有值"><a href="#NULL-代表一个字段没有值" class="headerlink" title="NULL: 代表一个字段没有值"></a><strong>NULL</strong>: 代表一个字段没有值</h3><ul>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> column_name <code>IS NULL</code>;</li>
<li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> column_name <code>IS NOT NULL</code>;</li>
</ul>
<h3 id="AS-用于给表或者列分配别名"><a href="#AS-用于给表或者列分配别名" class="headerlink" title="AS: 用于给表或者列分配别名"></a><strong>AS</strong>: 用于给表或者列分配别名</h3><ul>
<li><code>SELECT</code> column_name <code>AS</code> alias_name <code>FROM</code> table_name;</li>
<li><code>SELECT</code> column_name <code>FROM</code> table_name <code>AS</code> alias_name;</li>
<li><code>SELECT</code> column_name <code>AS</code> alias_name1, column_name2 <code>AS</code> alias_name2;</li>
<li><code>SELECT</code> column_name1, column_name2 + ‘, ‘ + column_name3 <code>AS</code> alias_name;</li>
</ul>
<h3 id="UNION-用于组合两个或者多个-SELECT-语句的结果集的运算符"><a href="#UNION-用于组合两个或者多个-SELECT-语句的结果集的运算符" class="headerlink" title="UNION: 用于组合两个或者多个 SELECT 语句的结果集的运算符"></a><strong>UNION</strong>: 用于组合两个或者多个 SELECT 语句的结果集的运算符</h3><ul>
<li>每个 SELECT 语句必须拥有相同的列数</li>
<li>列必须拥有相似的数据类型</li>
<li>每个 SELECT 语句中的列也必须具有相同的顺序</li>
<li><code>SELECT</code> columns_names <code>FROM</code> table1 <code>UNION SELECT</code> column_name <code>FROM</code> table2;</li>
<li><code>UNION</code> 仅允许选择不同的值, <code>UNION ALL</code> 允许重复</li>
</ul>
<h3 id="ANY-ALL-用于检查-WHERE-或-HAVING-子句中使用的子查询条件的运算符"><a href="#ANY-ALL-用于检查-WHERE-或-HAVING-子句中使用的子查询条件的运算符" class="headerlink" title="ANY|ALL: 用于检查 WHERE 或 HAVING 子句中使用的子查询条件的运算符"></a><strong>ANY|ALL</strong>: 用于检查 WHERE 或 HAVING 子句中使用的子查询条件的运算符</h3><ul>
<li><code>ANY</code> 如果任何子查询值满足条件，则返回 true。</li>
<li><code>ALL</code> 如果所有子查询值都满足条件，则返回 true。</li>
<li><code>SELECT</code> columns_names <code>FROM</code> table1 <code>WHERE</code> column_name operator (<code>ANY</code>|<code>ALL</code>) (<code>SELECT</code> column_name <code>FROM</code> table_name <code>WHERE</code> condition);</li>
</ul>
<h3 id="GROUP-BY-通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列"><a href="#GROUP-BY-通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列" class="headerlink" title="GROUP BY: 通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列"></a><strong>GROUP BY</strong>: 通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列</h3><ul>
<li><code>SELECT</code> column_name1, COUNT(column_name2) <code>FROM</code> table_name <code>WHERE</code> condition <code>GROUP BY</code> column_name1 <code>ORDER BY</code> COUNT(column_name2) DESC;</li>
</ul>
<h3 id="HAVING-HAVING-子句指定-SELECT-语句应仅返回聚合值满足指定条件的行。它被添加到-SQL-语言中，因为-WHERE-关键字不能与聚合函数一起使用。"><a href="#HAVING-HAVING-子句指定-SELECT-语句应仅返回聚合值满足指定条件的行。它被添加到-SQL-语言中，因为-WHERE-关键字不能与聚合函数一起使用。" class="headerlink" title="HAVING: HAVING 子句指定 SELECT 语句应仅返回聚合值满足指定条件的行。它被添加到 SQL 语言中，因为 WHERE 关键字不能与聚合函数一起使用。"></a><strong>HAVING</strong>: HAVING 子句指定 SELECT 语句应仅返回聚合值满足指定条件的行。它被添加到 SQL 语言中，因为 WHERE 关键字不能与聚合函数一起使用。</h3><ul>
<li><code>SELECT</code> <code>COUNT</code>(column_name1), column_name2 <code>FROM</code> table <code>GROUP BY</code> column_name2 <code>HAVING</code> <code>COUNT(</code>column_name1<code>)</code> &gt; 5;</li>
</ul>
<h2 id="修改数据的查询"><a href="#修改数据的查询" class="headerlink" title="修改数据的查询"></a>修改数据的查询</h2><h3 id="INSERT-INTO-用于在表中插入新记录-x2F-行"><a href="#INSERT-INTO-用于在表中插入新记录-x2F-行" class="headerlink" title="INSERT INTO: 用于在表中插入新记录&#x2F;行"></a><strong>INSERT INTO</strong>: 用于在表中插入新记录&#x2F;行</h3><ul>
<li><code>INSERT INTO</code> table_name (column1, column2) <code>VALUES</code> (value1, value2);</li>
<li><code>INSERT INTO</code> table_name <code>VALUES</code> (value1, value2 …);</li>
</ul>
<h3 id="UPDATE-用于修改表中的现有记录-x2F-行"><a href="#UPDATE-用于修改表中的现有记录-x2F-行" class="headerlink" title="UPDATE: 用于修改表中的现有记录&#x2F;行"></a><strong>UPDATE</strong>: 用于修改表中的现有记录&#x2F;行</h3><ul>
<li><code>UPDATE</code> table_name <code>SET</code> column1 &#x3D; value1, column2 &#x3D; value2 <code>WHERE</code> condition;</li>
<li><code>UPDATE</code> table_name <code>SET</code> column_name &#x3D; value;</li>
</ul>
<h3 id="DELETE-用于删除表中的现有记录-x2F-行"><a href="#DELETE-用于删除表中的现有记录-x2F-行" class="headerlink" title="DELETE: 用于删除表中的现有记录&#x2F;行"></a><strong>DELETE</strong>: 用于删除表中的现有记录&#x2F;行</h3><ul>
<li><code>DELETE FROM</code> table_name <code>WHERE</code> condition;</li>
<li><code>DELETE</code> * <code>FROM</code> table_name;</li>
</ul>
<h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><h3 id="COUNT-返回出现次数"><a href="#COUNT-返回出现次数" class="headerlink" title="COUNT: 返回出现次数"></a><strong>COUNT</strong>: 返回出现次数</h3><ul>
<li><code>SELECT COUNT (DISTINCT</code> column_name<code>)</code>;</li>
</ul>
<h3 id="MIN-and-MAX-返回所选列的最小-x2F-最大值"><a href="#MIN-and-MAX-返回所选列的最小-x2F-最大值" class="headerlink" title="MIN() and MAX(): 返回所选列的最小&#x2F;最大值"></a><strong>MIN() and MAX()</strong>: 返回所选列的最小&#x2F;最大值</h3><ul>
<li><code>SELECT MIN (</code>column_names<code>) FROM</code> table_name <code>WHERE</code> condition;</li>
<li><code>SELECT MAX (</code>column_names<code>) FROM</code> table_name <code>WHERE</code> condition;</li>
</ul>
<h3 id="AVG-返回数字列的平均值"><a href="#AVG-返回数字列的平均值" class="headerlink" title="AVG(): 返回数字列的平均值"></a><strong>AVG()</strong>: 返回数字列的平均值</h3><ul>
<li><code>SELECT AVG (</code>column_name<code>) FROM</code> table_name <code>WHERE</code> condition;</li>
</ul>
<h3 id="SUM-返回数值列的总和"><a href="#SUM-返回数值列的总和" class="headerlink" title="SUM(): 返回数值列的总和"></a><strong>SUM()</strong>: 返回数值列的总和</h3><ul>
<li><code>SELECT SUM (</code>column_name<code>) FROM</code> table_name <code>WHERE</code> condition;</li>
</ul>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="INNER-JOIN-内连接，返回在两张表中具有匹配值的记录"><a href="#INNER-JOIN-内连接，返回在两张表中具有匹配值的记录" class="headerlink" title="INNER JOIN: 内连接，返回在两张表中具有匹配值的记录"></a><strong>INNER JOIN</strong>: 内连接，返回在两张表中具有匹配值的记录</h3><ul>
<li><code>SELECT</code> column_names <code>FROM</code> table1 <code>INNER JOIN</code> table2 <code>ON</code> table1.column_name&#x3D;table2.column_name;</li>
<li><code>SELECT</code> table1.column_name1, table2.column_name2, table3.column_name3 <code>FROM</code> ((table1 <code>INNER JOIN</code> table2 <code>ON</code> relationship) <code>INNER JOIN</code> table3 <code>ON</code> relationship);</li>
</ul>
<h3 id="LEFT-OUTER-JOIN-左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）"><a href="#LEFT-OUTER-JOIN-左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）" class="headerlink" title="LEFT (OUTER) JOIN: 左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）"></a><strong>LEFT (OUTER) JOIN</strong>: 左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）</h3><ul>
<li><code>SELECT</code> column_names <code>FROM</code> table1 <code>LEFT JOIN</code> table2 <code>ON</code> table1.column_name&#x3D;table2.column_name;</li>
</ul>
<h3 id="RIGHT-OUTER-JOIN-右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录"><a href="#RIGHT-OUTER-JOIN-右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录" class="headerlink" title="RIGHT (OUTER) JOIN: 右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录"></a><strong>RIGHT (OUTER) JOIN</strong>: 右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录</h3><ul>
<li><code>SELECT</code> column_names <code>FROM</code> table1 <code>RIGHT JOIN</code> table2 <code>ON</code> table1.column_name&#x3D;table2.column_name;</li>
</ul>
<h3 id="FULL-OUTER-JOIN-全外连接，全连接是左右外连接的并集-连接表包含被连接的表的所有记录-如果缺少匹配的记录-以-NULL-填充。"><a href="#FULL-OUTER-JOIN-全外连接，全连接是左右外连接的并集-连接表包含被连接的表的所有记录-如果缺少匹配的记录-以-NULL-填充。" class="headerlink" title="FULL (OUTER) JOIN: 全外连接，全连接是左右外连接的并集. 连接表包含被连接的表的所有记录, 如果缺少匹配的记录, 以 NULL 填充。"></a><strong>FULL (OUTER) JOIN</strong>: 全外连接，全连接是左右外连接的并集. 连接表包含被连接的表的所有记录, 如果缺少匹配的记录, 以 NULL 填充。</h3><ul>
<li><code>SELECT</code> column_names <code>FROM</code> table1 <code>FULL OUTER JOIN</code> table2 <code>ON</code> table1.column_name&#x3D;table2.column_name;</li>
</ul>
<h3 id="Self-JOIN-自连接，表自身连接"><a href="#Self-JOIN-自连接，表自身连接" class="headerlink" title="Self JOIN: 自连接，表自身连接"></a><strong>Self JOIN</strong>: 自连接，表自身连接</h3><ul>
<li><code>SELECT</code> column_names <code>FROM</code> table1 T1, table1 T2 <code>WHERE</code> condition;</li>
</ul>
<h2 id="视图查询"><a href="#视图查询" class="headerlink" title="视图查询"></a>视图查询</h2><h3 id="CREATE-创建视图"><a href="#CREATE-创建视图" class="headerlink" title="CREATE: 创建视图"></a><strong>CREATE</strong>: 创建视图</h3><ul>
<li><code>CREATE VIEW</code> view_name <code>AS SELECT</code> column1, column2 <code>FROM</code> table_name <code>WHERE</code> condition;</li>
</ul>
<h3 id="SELECT-检索视图"><a href="#SELECT-检索视图" class="headerlink" title="SELECT: 检索视图"></a><strong>SELECT</strong>: 检索视图</h3><ul>
<li><code>SELECT</code> * <code>FROM</code> view_name;</li>
</ul>
<h3 id="DROP-删除视图"><a href="#DROP-删除视图" class="headerlink" title="DROP: 删除视图"></a><strong>DROP</strong>: 删除视图</h3><ul>
<li><code>DROP VIEW</code> view_name;</li>
</ul>
<h2 id="修改表的查询"><a href="#修改表的查询" class="headerlink" title="修改表的查询"></a>修改表的查询</h2><h3 id="ADD-添加字段"><a href="#ADD-添加字段" class="headerlink" title="ADD: 添加字段"></a><strong>ADD</strong>: 添加字段</h3><ul>
<li><code>ALTER TABLE</code> table_name <code>ADD</code> column_name column_definition;</li>
</ul>
<h3 id="MODIFY-修改字段数据类型"><a href="#MODIFY-修改字段数据类型" class="headerlink" title="MODIFY: 修改字段数据类型"></a><strong>MODIFY</strong>: 修改字段数据类型</h3><ul>
<li><code>ALTER TABLE</code> table_name <code>MODIFY</code> column_name column_type;</li>
</ul>
<h3 id="DROP-删除字段"><a href="#DROP-删除字段" class="headerlink" title="DROP: 删除字段"></a><strong>DROP</strong>: 删除字段</h3><ul>
<li><code>ALTER TABLE</code> table_name <code>DROP COLUMN</code> column_name;</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/34699b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/34699b/" class="post-title-link" itemprop="url">《SQL 必知必会》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-16 10:46:05" itemprop="dateCreated datePublished" datetime="2022-07-16T10:46:05+08:00">2022-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《SQL-必知必会》笔记"><a href="#《SQL-必知必会》笔记" class="headerlink" title="《SQL 必知必会》笔记"></a>《SQL 必知必会》笔记</h1><h2 id="SQL-语法基础"><a href="#SQL-语法基础" class="headerlink" title="SQL 语法基础"></a>SQL 语法基础</h2><h3 id="SQL-语言划分"><a href="#SQL-语言划分" class="headerlink" title="SQL 语言划分"></a>SQL 语言划分</h3><p>SQL 语言按照功能划分成以下的 4 个部分：</p>
<ul>
<li><strong>DDL</strong>，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</li>
<li><strong>DML</strong>，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li>
<li><strong>DCL</strong>，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。</li>
<li><strong>DQL</strong>，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。</li>
</ul>
<h3 id="DB、DBS-和-DBMS-的区别"><a href="#DB、DBS-和-DBMS-的区别" class="headerlink" title="DB、DBS 和 DBMS 的区别"></a>DB、DBS 和 DBMS 的区别</h3><p>DB、DBS 和 DBMS 的区别：</p>
<ul>
<li>DBMS 的英文全称是 DataBase Management System，数据库管理系统，实际上它可以对多个数据库进行管理，所以你可以理解为 DBMS &#x3D; 多个数据库（DB） + 管理程序。</li>
<li>DB 的英文是 DataBase，也就是数据库。数据库是存储数据的集合，你可以把它理解为多个数据表。</li>
<li>DBS 的英文是 DataBase System，数据库系统。它是更大的概念，包括了数据库、数据库管理系统以及数据库管理人员 DBA。</li>
</ul>
<p>NoSql 不同时期的释义</p>
<ul>
<li>1970：NoSQL &#x3D; We have no SQL</li>
<li>1980：NoSQL &#x3D; Know SQL</li>
<li>2000：NoSQL &#x3D; No SQL!</li>
<li>2005：NoSQL &#x3D; Not only SQL</li>
<li>2013：NoSQL &#x3D; No, SQL!</li>
</ul>
<h3 id="Oracle-中的-SQL-是如何执行的"><a href="#Oracle-中的-SQL-是如何执行的" class="headerlink" title="Oracle 中的 SQL 是如何执行的"></a>Oracle 中的 SQL 是如何执行的</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220716105947.png"></p>
<ol>
<li><strong>语法检查</strong>：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</li>
<li><strong>语义检查</strong>：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</li>
<li><strong>权限检查</strong>：看用户是否具备访问该数据的权限。</li>
<li><strong>共享池检查</strong>：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？<ul>
<li>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是<strong>软解析</strong>。</li>
<li>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是<strong>硬解析</strong>。</li>
</ul>
</li>
<li><strong>优化器</strong>：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</li>
<li><strong>执行器</strong>：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。</li>
</ol>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。它主要缓存 SQL 语句和执行计划。</p>
<p>而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>
<h3 id="MySQL-中的-SQL-是如何执行的"><a href="#MySQL-中的-SQL-是如何执行的" class="headerlink" title="MySQL 中的 SQL 是如何执行的"></a>MySQL 中的 SQL 是如何执行的</h3><p>MySQL 是典型的 C&#x2F;S 架构，即 Client&#x2F;Server 架构，服务器端程序使用的 mysqld。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220716110905.png"></p>
<p>Mysql 可分为三层：</p>
<ol>
<li><strong>连接层</strong>：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li>
<li><strong>SQL 层</strong>：对 SQL 语句进行查询处理；</li>
<li><strong>存储引擎层</strong>：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220716111103.png"></p>
<p>SQL 层的结构</p>
<ol>
<li><strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</li>
<li><strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</li>
<li><strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。</li>
<li><strong>执行器</strong>：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</li>
</ol>
<p>与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<ol>
<li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li>
<li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ol>
<h3 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h3><p>SELECT 的作用是从一个表或多个表中检索出想要的数据行。</p>
<blockquote>
<ul>
<li><code>SELECT</code> 语句用于从数据库中查询数据。</li>
<li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>
<li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。<ul>
<li><code>ASC</code> ：升序（默认）</li>
<li><code>DESC</code> ：降序</li>
</ul>
</li>
</ul>
</blockquote>
<p>查询单列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>查询多列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, continent, region <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>查询所有列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>查询不同的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span>(continent) <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>限制查询结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回前 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 返回第 3 ~ 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-性能优化"><a href="#SQL-性能优化" class="headerlink" title="SQL 性能优化"></a>SQL 性能优化</h2><h3 id="性能优化维度"><a href="#性能优化维度" class="headerlink" title="性能优化维度"></a>性能优化维度</h3><p>我个人理解的性能优化维度与文章有所不同：</p>
<ul>
<li>选择适合的数据库</li>
<li>配置优化</li>
<li>硬件优化</li>
<li>优化表设计</li>
<li>优化查询</li>
<li>使用缓存</li>
<li>读写分离+分库分表</li>
</ul>
<h3 id="范式设计"><a href="#范式设计" class="headerlink" title="范式设计"></a>范式设计</h3><p>范式定义：</p>
<ul>
<li><strong>1NF</strong>：指的是数据库表中的任何属性都是原子性的，不可再分。</li>
<li><strong>2NF</strong>：指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。</li>
<li><strong>3NF</strong>：在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。</li>
<li><strong>BCNF</strong>：在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</li>
</ul>
<p><strong>范式化的目标是尽力减少冗余列，节省空间</strong>。</p>
<p><strong>反范式化的目标是适当增加冗余列，以避免关联查询</strong>。<br>范式化优点</p>
<ul>
<li>更节省空间</li>
<li>更新操作更快</li>
<li>更少需要 <code>DISTINCT</code> 或 <code>GROUP BY</code> 语句</li>
</ul>
<p>范式化缺点</p>
<ul>
<li>增加了关联查询，而关联查询代价很高</li>
</ul>
<h3 id="索引的适用场景"><a href="#索引的适用场景" class="headerlink" title="索引的适用场景"></a>索引的适用场景</h3><p>我认为，文章对于索引的适用场景讲解的不好。应该先讲清楚索引的优点和缺点，再结合其特性，来阐述适用场景。</p>
<h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p><strong>索引的优点</strong></p>
<ul>
<li>大大减少了服务器需要扫描的数据量</li>
<li>可以帮助服务器避免排序和临时表</li>
<li>可以将随机 I&#x2F;O 变为顺序 I&#x2F;O</li>
</ul>
<p><strong>索引的缺点</strong></p>
<ul>
<li>创建和维护索引要耗费时间，这会随着数据量的增加而增加。</li>
<li>占用额外物理空间</li>
<li>写操作时很可能需要更新索引，导致数据库的写操作性能降低</li>
</ul>
<h4 id="索引的适用场景-1"><a href="#索引的适用场景-1" class="headerlink" title="索引的适用场景"></a>索引的适用场景</h4><p><strong>适用场景</strong></p>
<ul>
<li>频繁读操作（SELECT）</li>
<li>表的数据量比较大</li>
<li>列名经常出现在 WHERE 或连接（JOIN）条件中</li>
</ul>
<p><strong>不适用场景</strong></p>
<ul>
<li>频繁写操作（INSERT&#x2F;UPDATE&#x2F;DELETE）</li>
<li>列名不经常出现在 WHERE 或连接（JOIN）条件中</li>
<li>索引会经常无法命中，没有意义</li>
<li>非常小的表（比如不到 1000 行）：简单的全表扫描更高效</li>
<li>特大型的表：索引的代价很高昂，可以用分区或 Nosql</li>
</ul>
<h3 id="索引使用什么数据结构"><a href="#索引使用什么数据结构" class="headerlink" title="索引使用什么数据结构"></a>索引使用什么数据结构</h3><p>索引常见的数据结构</p>
<p>（1）哈希</p>
<p>只能用于等值查询。</p>
<p>Mysql 中，只有 Memory 存储引擎显示支持哈希索引。</p>
<p>哈希结构的缺点</p>
<ul>
<li>哈希索引数据不是按照索引值顺序存储的——无法用于排序</li>
<li>哈希索引使用索引列的全部内容来进行哈希计算的——不支持联合索引的最左侧原则（即联合索引的部分索引）</li>
<li>只支持等值比较查询<ul>
<li>不支持范围查询</li>
<li>不支持模糊查询</li>
</ul>
</li>
<li>可能出现哈希冲突<ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行</li>
<li>如果哈希冲突多的话，维护索引的代价会很高</li>
</ul>
</li>
</ul>
<p>（2）B 树</p>
<p>非叶子节点包含索引和数据。</p>
<p>（3）空间数据索引（R 树）</p>
<p>（4）全文索引</p>
<h3 id="从数据页的角度理解-B-树查询"><a href="#从数据页的角度理解-B-树查询" class="headerlink" title="从数据页的角度理解 B+树查询"></a>从数据页的角度理解 B+树查询</h3><p><strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720055715.png"></p>
<p>一个表空间包括了一个或多个段，一个段包括了一个或多个区，一个区包括了多个页，而一个页中可以有多行记录：</p>
<p>区（Extent）是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D;1MB。</p>
<p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
<h3 id="从磁盘-I-x2F-O-的角度理解-SQL-查询的成本"><a href="#从磁盘-I-x2F-O-的角度理解-SQL-查询的成本" class="headerlink" title="从磁盘 I&#x2F;O 的角度理解 SQL 查询的成本"></a>从磁盘 I&#x2F;O 的角度理解 SQL 查询的成本</h3><ol>
<li>位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li>批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多 10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ol>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li><strong>行锁</strong>就是按照行的粒度对数据进行锁定。锁定力度小，发生锁冲突概率低，可以实现的并发度高，但是对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。</li>
<li><strong>页锁</strong>就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</li>
<li><strong>表锁</strong>就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。不过好处在于对锁的使用开销小，加锁会很快。</li>
</ul>
<p>不同的数据库和存储引擎支持的锁粒度不同：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720062633.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720063540.png"></p>
<h3 id="数据库工作流"><a href="#数据库工作流" class="headerlink" title="数据库工作流"></a>数据库工作流</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720093559.png"></p>
<h3 id="如何使用性能分析工具定位-SQL-执行慢的原因？"><a href="#如何使用性能分析工具定位-SQL-执行慢的原因？" class="headerlink" title="如何使用性能分析工具定位 SQL 执行慢的原因？"></a>如何使用性能分析工具定位 SQL 执行慢的原因？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720093823.png"></p>
<h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p>Mysql 支持两种复制：基于行的复制和基于语句的复制。</p>
<p>这两种方式都是在主库上记录二进制日志，然后在从库重放日志的方式来实现异步的数据复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。</p>
<p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/mysql/master-slave.png" />
</div>

<p>如何解决主从同步时的数据一致性问题？</p>
<p><strong>异步复制</strong></p>
<p>异步模式就是客户端提交 COMMIT 之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而 Binlog 还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p>
<p><strong>半异步复制</strong></p>
<p>原理是在客户端提交 COMMIT 之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了 Binlog，并且写入到中继日志中，再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。——其实是一种两阶段提交的思想。</p>
<p><strong>组复制</strong></p>
<p>这种复制技术是基于 Paxos 的状态机复制。</p>
<p>将多个节点共同组成一个复制组，在执行读写（RW）事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于（N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对只读（RO）事务则不需要经过组内同意，直接 COMMIT 即可。</p>
<p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
<h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>**<code>SQL 注入攻击（SQL injection）</code>**，是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p>
<p>攻击示例：</p>
<p>考虑以下简单的登录表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们的处理里面的 SQL 可能是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username:<span class="operator">=</span>r.Form.Get(&quot;username&quot;)</span><br><span class="line">password:<span class="operator">=</span>r.Form.Get(&quot;password&quot;)</span><br><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM user WHERE username=&#x27;&quot;<span class="operator">+</span>username<span class="operator">+</span>&quot;&#x27; AND password=&#x27;&quot;<span class="operator">+</span>password<span class="operator">+</span>&quot;&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>如果用户的输入的用户名如下，密码任意</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myuser<span class="string">&#x27; or &#x27;</span>foo<span class="string">&#x27; = &#x27;</span>foo<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure>

<p>那么我们的 SQL 变成了如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;foo&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;foo&#x27;</span> <span class="comment">--&#x27;&#x27; AND password=&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 SQL 里面 <code>--</code> 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p>
<p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM products WHERE name LIKE &#x27;%&quot;<span class="operator">+</span>prod<span class="operator">+</span>&quot;%&#x27;&quot;</span><br><span class="line">Db.Exec(<span class="keyword">sql</span>)</span><br></pre></td></tr></table></figure>

<p>如果攻击提交 <code>a%&#39; exec master..xp_cmdshell &#39;net user test testpass /ADD&#39; --</code> 作为变量 prod 的值，那么 sql 将会变成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM products WHERE name LIKE &#x27;%a%&#x27; exec master..xp_cmdshell &#x27;net user test testpass /ADD&#x27;--%&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p>
<p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p>
<h4 id="攻击手段和目的"><a href="#攻击手段和目的" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h4><ul>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如 <code>SELECT * FROM sys.tables</code>）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如 <code>ALTER LOGIN sa WITH PASSWORD=&#39;xxxxxx&#39;</code>）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin”可停止服务器的 IIS 服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。</li>
</ul>
<h4 id="应对手段"><a href="#应对手段" class="headerlink" title="应对手段"></a>应对手段</h4><ul>
<li><strong>使用参数化查询</strong> - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database&#x2F;sql 里面的查询函数 <code>Prepare</code> 和 <code>Query</code> ，或者 <code>Exec(query string, args ...interface&#123;&#125;)</code>。</li>
<li><strong>单引号转换</strong> - 在组合 SQL 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。</li>
</ul>
<blockquote>
<p>:point_right: 参考阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A">Wiki 词条 - SQL 注入攻击</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md">避免 SQL 注入</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jobbole.com/83092/">实例讲解 SQL 注入攻击</a></li>
</ul>
</blockquote>
<h2 id="认识-DBMS"><a href="#认识-DBMS" class="headerlink" title="认识 DBMS"></a>认识 DBMS</h2><p>内容对我意义不大，略</p>
<h2 id="SQL-项目实战"><a href="#SQL-项目实战" class="headerlink" title="SQL 项目实战"></a>SQL 项目实战</h2><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>SQL 可以帮我们进行数据处理，总的来说可以分成 OLTP 和 OLAP 两种方式。</p>
<ul>
<li><strong>OLTP</strong>：称之为联机事务处理。对数据进行增删改查，SQL 查询优化，事务处理等就属于 OLTP 的范畴。它对实时性要求高，需要将用户的数据有效地存储到数据库中，同时有时候针对互联网应用的需求，我们还需要设置数据库的主从架构保证数据库的高并发和高可用性。</li>
<li><strong>OLAP</strong>：称之为联机分析处理。它是对已经存储在数据库中的数据进行分析，帮我们得出报表，指导业务。它对数据的实时性要求不高，但数据量往往很大，存储在数据库（数据仓库）中的数据可能还存在数据质量的问题，比如数据重复、数据中有缺失值，或者单位不统一等，因此在进行数据分析之前，首要任务就是对收集的数据进行清洗，从而保证数据质量。</li>
</ul>
<h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720142031.png"></p>
<p>ETL 是英文 Extract、Transform 和 Load 的缩写，也就是将数据从不同的数据源进行抽取，然后通过交互转换，最终加载到目的地的过程。</p>
<ul>
<li>在 Extract 数据抽取这个过程中，需要做大量的工作，我们需要了解企业分散在不同地方的数据源都采用了哪种 DBMS，还需要了解这些数据源存放的数据结构等，是结构化数据，还是非结构化数据。在抽取中，我们也可以采用全量抽取和增量抽取两种方式。相比于全量抽取，增量抽取使用得更为广泛，它可以帮我们动态捕捉数据源的数据变化，并进行同步更新。</li>
<li>在 Transform 数据转换的过程中，我们可以使用一些数据转换的组件，比如说数据字段的映射、数据清洗、数据验证和数据过滤等，这些模块可以像是在流水线上进行作业一样，帮我们完成各种数据转换的需求，从而将不同质量，不同规范的数据进行统一。</li>
<li>在 Load 数据加载的过程中，我们可以将转换之后的数据加载到目的地，如果目标是 RDBMS，我们可以直接通过 SQL 进行加载，或者使用批量加载的方式进行加载。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/192">极客时间 - SQL 必知必会</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/9708e2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/9708e2/" class="post-title-link" itemprop="url">《RocketMQ 技术内幕》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:58:58" itemprop="dateCreated datePublished" datetime="2022-07-12T16:58:58+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《RocketMQ-技术内幕》笔记"><a href="#《RocketMQ-技术内幕》笔记" class="headerlink" title="《RocketMQ 技术内幕》笔记"></a>《RocketMQ 技术内幕》笔记</h1><h2 id="读源代码前的准备"><a href="#读源代码前的准备" class="headerlink" title="读源代码前的准备"></a>读源代码前的准备</h2><h3 id="RocketMQ-源代码的目录结构"><a href="#RocketMQ-源代码的目录结构" class="headerlink" title="RocketMQ 源代码的目录结构"></a>RocketMQ 源代码的目录结构</h3><ul>
<li><code>broker</code>：broker 模块（broker 启动进程） 。</li>
<li><code>client</code>：消息客户端，包含生产者、消息消费者相关类。</li>
<li><code>common</code>：公共包。</li>
<li><code>dev</code>：开发者信息（非源代码） 。</li>
<li><code>distribution</code>：部署实例文件夹（非源代码） 。</li>
<li><code>example</code>：RocketMQ 示例代码。</li>
<li><code>filter</code>：消息过滤相关基础类。</li>
<li><code>filter</code>：消息过滤服务器实现相关类（Filter 启动进程） 。</li>
<li><code>logappender</code>：日志实现相关类。</li>
<li><code>namesrv</code>：N ameServer 实现相关类（Names 巳 rver 启动进程） 。</li>
<li><code>openmessaging</code>：消息开放标准，正在制定中。</li>
<li><code>remoting</code>：远程通信模块，基于 Netty 。</li>
<li><code>srvutil</code>：服务器工具类。</li>
<li><code>store</code>：消息存储实现相关类。</li>
<li><code>style</code>：checkstyle 相关实现。</li>
<li><code>test</code>：测试相关类。</li>
<li><code>tools</code>：工具类，监控命令相关实现类。</li>
</ul>
<h3 id="RocketMQ-的设计理念和目标"><a href="#RocketMQ-的设计理念和目标" class="headerlink" title="RocketMQ 的设计理念和目标"></a>RocketMQ 的设计理念和目标</h3><h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h4><p>RocketMQ 设计基于主题的发布与订阅模式， 其核心功能包括：消息发送、消息存储( Broker ）、消息消费。其整体设计追求简单与性能第一，主要体现在如下三个方面：</p>
<ul>
<li>自研 NameServer，而不是用 ZooKeeper 作为注册中心。因为 ZooKeeper 采用 CAP 模型中的 CP 模型，其实并不适用于注册中心的业务模式。</li>
<li>RocketMQ 的消息存储文件设计成文件组的概念，组内单个文件大小固定，方便引入内存映射机制，所有主<br>题的消息存储基于顺序写， 极大地提供了消息写性能，同时为了兼顾消息消费与消息查找，引入了消息消费队列文件与索引文件。</li>
<li>容忍存在设计缺陷，适当将某些工作下放给 RocketMQ 使用者。消息中间件的实现者经常会遇到一个难题：如何保证消息一定能被消息消费者消费，并且保证只消费一次。RocketMQ 的设计者给出的解决办法是不解决这个难题，而是退而求其次，只保证消息被消费者消费，但设计上允许消息被重复消费，这样极大地简化了消息中间件的内核，使得实现消息发送高可用变得非常简单与高效，消息重复问题由消费者在消息消费时实现幂等。</li>
</ul>
<h4 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h4><ul>
<li><strong>架构模式</strong>：RocketMQ 与大部分消息中间件一样，采用发布订阅模式，基本的参与组件主要包括：消息发送者、消息服务器（消息存储）、消息消费、路由发现。</li>
<li><strong>顺序消息</strong>：所谓顺序消息，就是消息消费者按照消息达到消息存储服务器的顺序消费。RocketMQ 可以严格保证消息有序。</li>
<li><strong>消息过滤</strong>：消息过滤是指在消息消费时，消息消费者可以对同一主题下的消息按照规则只消费自己感兴趣的消息。RocketMQ 消息过滤支持在服务端与消费端的消息过滤机制。</li>
<li>消息在 Broker 端过滤。Broker 只将消息消费者感兴趣的消息发送给消息消费者。</li>
<li>消息在消息消费端过滤，消息过滤方式完全由消息消费者自定义，但缺点是有很多无用的消息会从 Broker 传输到消费端。</li>
<li><strong>消息存储</strong>：消息中间件的一个核心实现是消息的存储，对消息存储一般有如下两个维度的考量：消息堆积能力和消息存储性能。RocketMQ 追求消息存储的高性能，引人内存映射机制，所有主题的消息顺序存储在同一个文件中。同时为了避免消息无限在消息存储服务器中累积，引入了消息文件过期机制与文件存储空间报警机制。</li>
<li><strong>消息高可用性</strong>：<ul>
<li>通常影响消息可靠性的有以下几种情况。<ol>
<li>Broker 正常关机。</li>
<li>Broker 异常 Crash 。</li>
<li>OS Crash 。</li>
<li>机器断电，但是能立即恢复供电情况。</li>
<li>机器无法开机（可能是 CPU 、主板、内存等关键设备损坏） 。</li>
<li>磁盘设备损坏。</li>
</ol>
</li>
<li>针对上述情况，情况 1~4 的 RocketMQ 在同步刷盘机制下可以确保不丢失消息，在异步刷盘模式下，会丢失少量消息。情况 5-6 属于单点故障，一旦发生，该节点上的消息全部丢失，如果开启了异步复制机制， RoketMQ 能保证只丢失少量消息， RocketMQ 在后续版本中将引人双写机制，以满足消息可靠性要求极高的场合。</li>
</ul>
</li>
<li><strong>消息到达（ 消费）低延迟</strong>：RocketMQ 在消息不发生消息堆积时，以长轮询模式实现准实时的消息推送模式。</li>
<li><strong>确保消息必须被消费一次</strong>：RocketMQ 通过消息消费确认机制（ACK）来确保消息至少被消费一次，但由于 ACK 消息有可能丢失等其他原因， RocketMQ 无法做到消息只被消费一次，有重复消费的可能。</li>
<li><strong>回溯消息</strong>：回溯消息是指消息消费端已经消费成功的消息，由于业务要求需要重新消费消息。RocketMQ 支持按时间回溯消息，时间维度可精确到毫秒，可以向前或向后回溯。</li>
<li><strong>消息堆积</strong>：消息中间件的主要功能是异步解耦，必须具备应对前端的数据洪峰，提高后端系统的可用性，必然要求消息中间件具备一定的消息堆积能力。RocketMQ 消息存储使用磁盘文件（内存映射机制），并且在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用。RocketMQ 消息存储文件并不是永久存储在消息服务器端，而是提供了过期机制，默认保留 3 天。</li>
<li><strong>定时消息</strong>：定时消息是指消息发送到 Broker 后， 不能被消息消费端立即消费，要到特定的时间点或者等待特定的时间后才能被消费。如果要支持任意精度的定时消息消费，必须在消息服务端对消息进行排序，势必带来很大的性能损耗，故 RocketMQ 不支持任意进度的定时消息，而只支持特定延迟级别。</li>
<li><strong>消息重试机制</strong>：消息重试是指消息在消费时，如果发送异常，消息中间件需要支持消息重新投递，RocketMQ 支持消息重试机制。</li>
</ul>
<h2 id="RocketMQ-路由中心-NameServer"><a href="#RocketMQ-路由中心-NameServer" class="headerlink" title="RocketMQ 路由中心 NameServer"></a>RocketMQ 路由中心 NameServer</h2><h3 id="NameServer-架构设计"><a href="#NameServer-架构设计" class="headerlink" title="NameServer 架构设计"></a>NameServer 架构设计</h3><p>Broker 消息服务器在启动时向所有 NameServer 注册，生产者（Producer）在发送消息之前先从 NameServer 获取 Broker 服务器地址列表，然后根据负载算法从列表中选择一台消息服务器进行消息发送。NameServer 与每台 Broker 服务器保持长连接，并间隔 30s 检测 Broker 是否存活，如果检测到 Broker 宕机， 则从路由注册表中将其移除。但是路由变化不会马上通知生产者，为什么要这样设计呢？这是为了降低 NameServer 实现的复杂性，在消息发送端提供容错机制来保证消息发送的高可用性。</p>
<p>NameServer 本身的高可用可通过部署多台 NameServer 服务器来实现，但彼此之间互不通信，也就是说 NameServer 服务器之间在某一时刻的数据并不会完全相同，但这对消息发送不会造成任何影响。</p>
<h3 id="NameServer-启动流程"><a href="#NameServer-启动流程" class="headerlink" title="NameServer 启动流程"></a>NameServer 启动流程</h3><ol>
<li>加载配置，然后根据配置初始化 <code>NamesrvController</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">createNamesrvController</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, JoranException &#123;</span><br><span class="line">    System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">    <span class="comment">//PackageConflictDetect.detectFastjson();</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> ServerUtil.buildCommandlineOptions(<span class="keyword">new</span> <span class="title class_">Options</span>());</span><br><span class="line">    commandLine = ServerUtil.parseCmdLine(<span class="string">&quot;mqnamesrv&quot;</span>, args, buildCommandlineOptions(options), <span class="keyword">new</span> <span class="title class_">PosixParser</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == commandLine) &#123;</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化 NamesrvConfig 配置和 NettyServerConfig 配置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvConfig</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line">    nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 加载配置文件中的配置</span></span><br><span class="line">    <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;c&#x27;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> commandLine.getOptionValue(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">            MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">            namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;load config properties file OK, %s%n&quot;</span>, file);</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 加载启动命令中的配置</span></span><br><span class="line">    <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;p&#x27;</span>)) &#123;</span><br><span class="line">        <span class="type">InternalLogger</span> <span class="variable">console</span> <span class="operator">=</span> InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">        MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">        MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 强制必须设置环境变量 ROCKETMQ_HOME</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == namesrvConfig.getRocketmqHome()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Please set the %s variable in your environment to match the location of the RocketMQ installation%n&quot;</span>, MixAll.ROCKETMQ_HOME_ENV);</span><br><span class="line">        System.exit(-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 打印配置项</span></span><br><span class="line">    <span class="type">LoggerContext</span> <span class="variable">lc</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">    <span class="type">JoranConfigurator</span> <span class="variable">configurator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoranConfigurator</span>();</span><br><span class="line">    configurator.setContext(lc);</span><br><span class="line">    lc.reset();</span><br><span class="line">    configurator.doConfigure(namesrvConfig.getRocketmqHome() + <span class="string">&quot;/conf/logback_namesrv.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">    MixAll.printObjectProperties(log, namesrvConfig);</span><br><span class="line">    MixAll.printObjectProperties(log, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvController</span>(namesrvConfig, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remember all configs to prevent discard</span></span><br><span class="line">    controller.getConfiguration().registerConfig(properties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据启动属性创建 NamesrvController 实例，并初始化该实例， NameServerController 实例为 NameServer 核心控制器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载KV 配置</span></span><br><span class="line">    <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 NettyRemotingServer 网络处理对象</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryImpl</span>(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册进程</span></span><br><span class="line">    <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启两个定时任务（心跳检测）</span></span><br><span class="line">    <span class="comment">// 任务一：NameServer 每隔 1O 秒扫描一次 Broker，移除不活跃的 Broker</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 任务二：NameServer 每隔 1O 分钟打印一次 KV 配置</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 TLS 模式，加载证书，开启安全模式</span></span><br><span class="line">    <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">        <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWatchService = <span class="keyword">new</span> <span class="title class_">FileWatchService</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                    TlsSystemConfig.tlsServerCertPath,</span><br><span class="line">                    TlsSystemConfig.tlsServerKeyPath,</span><br><span class="line">                    TlsSystemConfig.tlsServerTrustCertPath</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileWatchService</span>.Listener() &#123;</span><br><span class="line">                    <span class="type">boolean</span> certChanged, keyChanged = <span class="literal">false</span>;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(String path)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;The trust certificate changed, reload the ssl context&quot;</span>);</span><br><span class="line">                            reloadServerSslContext();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerCertPath)) &#123;</span><br><span class="line">                            certChanged = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerKeyPath)) &#123;</span><br><span class="line">                            keyChanged = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (certChanged &amp;&amp; keyChanged) &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;The certificate and private key changed, reload the ssl context&quot;</span>);</span><br><span class="line">                            certChanged = keyChanged = <span class="literal">false</span>;</span><br><span class="line">                            reloadServerSslContext();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reloadServerSslContext</span><span class="params">()</span> &#123;</span><br><span class="line">                        ((NettyRemotingServer) remotingServer).loadSslContext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;FileWatchService created error, can&#x27;t load the certificate dynamically&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注册 JVM 钩子函数并启动服务器，以便监昕 Broker 、生产者的网络请求。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 JVM 钩子函数并启动服务器，以便监昕Broker、 生产者的网络请求</span></span><br><span class="line"><span class="comment">// 如果代码中使用了线程池，一种优雅停机的方式就是注册一个 JVM 钩子函数，在 JVM 进程关闭之前，先将线程池关闭，及时释放资源</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ShutdownHookThread</span>(log, <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        controller.shutdown();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="NameServer-路由注册、故障剔除"><a href="#NameServer-路由注册、故障剔除" class="headerlink" title="NameServer 路由注册、故障剔除"></a>NameServer 路由注册、故障剔除</h3><p>NameServer 主要作用是为生产者和消息消费者提供关于主题 Topic 的路由信息，那么 NameServer 需要存储路由的基础信息，还要能够管理 Broker 节点，包括路由注册、路由删除等功能。</p>
<h4 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h4><p>NameServer 路由实现类：org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager。它主要存储了以下信息：</p>
<ul>
<li><code>topicQueueTable</code>：Topic 消息队列路由信息，消息发送时根据路由表进行负载均衡。</li>
<li><code>brokerAddrTable</code>：Broker 基础信息， 包含 brokerName 、所属集群名称、主备 Broker 地址。</li>
<li><code>clusterAddrTable</code>：Broker 集群信息，存储集群中所有 Broker 名称。</li>
<li><code>brokerLiveTable</code>：Broker 状态信息。NameServer 每次收到心跳包时会替换该信息。</li>
<li><code>filterServerTable</code>：Broker 上的 FilterServer 列表，用于类模式消息过滤。</li>
</ul>
<p>RocketMQ 基于订阅发布机制，一个 Topic 拥有多个消息队列，一个 Broker 为每一主题默认创建 4 个读队列 4 个写队列。多个 Broker 组成一个集群，BrokerName 由相同的多台 Broker 组成 Master-Slave 架构， brokerId 为 0 代表 Master，大于 0 表示 Slave。BrokerLiveInfo 中的 lastUpdateTimestamp 存储上次收到 Broker 心跳包的时间。</p>
<h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><p>RocketMQ 路由注册是通过 Broker 与 NameServer 的心跳功能实现的。Broker 启动时向集群中所有的 NameServer 发送心跳语句，每隔 30s 向集群中所有 NameServer 发送心跳包， NameServer 收到 Broker 心跳包时会更新 brokerLiveTable 缓存中 BrokerLiveInfo 的 lastUpdateTimestamp ，然后 NameServer 每隔 10s 扫描 brokerLiveTable ，如果连续 120s 没有收到心跳包， NameServer 将移除该 Broker 的路由信息同时关闭 Socket 连接。</p>
<p>（1）Broker 发送心跳包</p>
<p>Broker 会遍历 NameServer 列表， 依次向所有 NameServer 发送心跳包。</p>
<p>（2）NameServer 处理心跳包</p>
<ul>
<li>路由注册需要加写锁，防止并发修改 RouteInfoManager 中的路由表。</li>
<li>判断 Broker 所属集群是否存在，如果不存在，则创建，然后将 broker 加入到 Broker 集群。</li>
<li>维护 BrokerData 信息，首先从 brokerAddrTable 根据 BrokerName 尝试获取 Broker 信息。<ul>
<li>如果不存在，则新建 BrokerData 并放入到 brokerAddrTable, registerFirst 设置为 true；</li>
<li>如果存在，直接将 registerFirst 设置为 false，表示非第一次注册。</li>
</ul>
</li>
<li>如果 Broker 为 Master，并且 Broker Topic 配置信息发生变化或者是初次注册，则需要创建或更新 Topic 路由元数据。填充 topicQueueTable，其实就是为默认主题自动注册路由信息，其中包含 MixAII.DEFAULT_TOPIC 的路由信息。当生产者发送主题时，如果该主题未创建并且 BrokerConfig 的 autoCreateTopicEnable 为 true 时，将返回 MixAII.DEFAULT_TOPIC 的路由信息。</li>
<li>更新 BrokerLiveInfo，存活 Broker 信息表，BrokeLiveInfo 是执行路由删除的重要依据。</li>
<li>注册 Broker 的过滤器 Server 地址列表，一个 Broker 上会关联多个 FilterServer 消息过滤服务器；如果此 Broker 为从节点，则需要查找该 Broker 的 Master 的节点信息，并更新对应的 masterAddr 属性。</li>
</ul>
<p>设计亮点： NameServe 与 Broker 保持长连接， Broker 状态存储在 brokerLiveTable 中，NameServer 每收到一个心跳包，将更新 brokerLiveTable 中关于 Broker 的状态信息以及路由表（topicQueueTable 、brokerAddrTable 、brokerLiveTable 、filterServerTable） 。更新上述路由表（HashTable）使用了锁粒度较少的读写锁，允许多个消息发送者（Producer ）并发读，保证消息发送时的高并发。但同一时刻 NameServer 只处理一个 Broker 心跳包，多个心跳包请求串行执行。</p>
<h4 id="路由删除"><a href="#路由删除" class="headerlink" title="路由删除"></a>路由删除</h4><p>Broker 每隔 30s 向 NameServe 发送一个心跳包，心跳包中包含 BrokerId 、Broker 地址、Broker 名称、Broker 所属集群名称、Broker 关联的 FilterServer 列表。但是如果 Broker 宕机，NameServer 无法收到心跳包，此时 NameServer 如何来剔除这些失效的 Broker 呢？ NameServer 会每隔 10s 扫描 brokerLiveTable 状态表，如果 BrokerLive 的 lastUpdateTimestamp 的时间戳距当前时间超过 120s ，则认为 Broker 失效，移除该 Broker，关闭与 Broker 连接，并同时更新 topicQueueTable 、brokerAddrTable 、brokerLiveTable 、filterServerTable 。</p>
<p>RocktMQ 有两个触发点来触发路由删除。</p>
<ul>
<li><p>NameServer 定时扫描 brokerLiveTable 检测上次心跳包与当前系统时间的时间差，如果时间戳大于 120s ，则需要移除该 Broker 信息。</p>
</li>
<li><p>Broker 在正常被关闭的情况下，会执行 unregisterBroker 指令。</p>
</li>
</ul>
<p>由于不管是何种方式触发的路由删除，路由删除的方法都是一样的，就是从 topicQueueTable 、rokerAddrTable 、brokerLiveTable 、filterServerTable 删除与该 Broker 相关的信息，但 RocketMQ 这两种方式维护路由信息时会抽取公共代码。</p>
<p>scanNotActiveBroker 在 NameServer 中每 10s 执行一次。逻辑很简单：遍历 brokerLiveInfo 路由表（HashMap），检测 BrokerLiveInfo 的 lastUpdateTimestamp。上次收到心跳包的时间如果超过当前时间 120s，NameServer 则认为该 Broker 已不可用，故需要将它移除，关闭 Channel，然后删除与该 Broker 相关的路由信息，路由表维护过程，需要申请写锁。</p>
<p>（1）申请写锁，根据 brokerAddress 从 brokerLiveTable 、filterServerTable 移除</p>
<p>（2）维护 brokerAddrTable 。遍历从 <code>HashMap&lt;String /* brokerName */, BrokerData&gt; brokerAddrTable</code>，从 BrokerData 的 <code>HashMap&lt;Long /* brokerId */, String /* broker address */&gt; brokerAddrs</code> 中，找到具体的 Broker ，从 BrokerData 中移除，如果移除后在 BrokerData 中不再包含其他 Broker，则在 brokerAddrTable 中移除该 brokerName 对应的条目。</p>
<p>（3）根据 brokerName，从 clusterAddrTable 中找到 Broker 并从集群中移除。如果移除后，集群中不包含任何 Broker，则将该集群从 clusterAddrTable 中移除。</p>
<p>（4）根据 brokerName，遍历所有主题的队列，如果队列中包含了当前 Broker 的队列， 则移除，如果 topic 只包含待移除 Broker 的队列的话，从路由表中删除该 topic。</p>
<h4 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h4><p>RocketMQ 路由发现是非实时的，当 Topic 路由出现变化后，NameServer 不主动推送给客户端，而是由客户端定时拉取主题最新的路由。根据主题名称拉取路由信息的命令编码为：GET_ROUTEINTO_BY_TOPIC 。</p>
<p>orderTopicConf ：顺序消息配置内容，来自于 kvConfig 。</p>
<p><code>List&lt;QueueData&gt; queueData</code>：topic 队列元数据。</p>
<p><code>List&lt;BrokerData&gt; brokerDatas</code>：topic 分布的 broker 元数据。</p>
<p><code>HashMap&lt;String/*brokerAdress*/,List&lt;String&gt; /*filterServer*/&gt;</code> ：broker 上过滤服务器地址列表。</p>
<p>NameServer 路由发现实现方法：<code>DefaultRequestProcessor#getRouteInfoByTopic</code></p>
<ol>
<li><p>调用 RouterlnfoManager 的方法，从路由表 topicQueueTable 、brokerAddrTable 、filterServerTable 中分别填充 TopicRouteData 中的 <code>List&lt;QueueData&gt;</code>、<code>List&lt;BrokerData&gt;</code> 和 filterServer 地址表。</p>
</li>
<li><p>如果找到主题对应的路由信息并且该主题为顺序消息，则从 NameServer KVconfig 中获取关于顺序消息相关的配置填充路由信息。</p>
</li>
</ol>
<p>如果找不到路由信息 CODE 则使用 TOPIC NOT_EXISTS ，表示没有找到对应的路由。</p>
<h2 id="RocketMQ-消息发送"><a href="#RocketMQ-消息发送" class="headerlink" title="RocketMQ 消息发送"></a>RocketMQ 消息发送</h2><h3 id="漫谈-RocketMQ-消息发送"><a href="#漫谈-RocketMQ-消息发送" class="headerlink" title="漫谈 RocketMQ 消息发送"></a>漫谈 RocketMQ 消息发送</h3><p>RocketMQ 支持 3 种消息发送方式：同步（sync） 、异步（async）、单向（oneway） 。</p>
<ul>
<li><strong>同步</strong>：发送者向 MQ 执行发送消息 API 时，同步等待， 直到消息服务器返回发送结果。</li>
<li><strong>异步</strong>：发送者向 MQ 执行发送消息 API 时，指定消息发送成功后的回掉函数，然后调用消息发送 API 后，立即返回，消息发送者线程不阻塞，直到运行结束，消息发送成功或失败的回调任务在一个新的线程中执行。</li>
<li><strong>单向</strong>：消息发送者向 MQ 执行发送消息 API 时，直接返回，不等待消息服务器的结果，也不注册回调函数，简单地说，就是只管发，不在乎消息是否成功存储在消息服务器上。</li>
</ul>
<p>RocketMQ 消息发送需要考虑以下几个问题。</p>
<ul>
<li>消息队列如何进行负载？</li>
<li>消息发送如何实现高可用？</li>
<li>批量消息发送如何实现一致性？</li>
</ul>
<h3 id="认识-RocketMQ-消息"><a href="#认识-RocketMQ-消息" class="headerlink" title="认识 RocketMQ 消息"></a>认识 RocketMQ 消息</h3><p>RocketMQ 消息的封装类是 <code>org.apache.rocketmq.common.message.Message</code>。其主要属性有：</p>
<ul>
<li><code>topic</code>：主题</li>
<li><code>properties</code>：属性容器。RocketMQ 会向其中添加一些扩展属性：<ul>
<li><code>tags</code>：消息标签，用于消息过滤。</li>
<li><code>keys</code>：消息索引，多个用空格隔开，RocketMQ 可以根据这些 key 快速检索到消息。</li>
<li><code>waitStoreMsgOK</code>：消息发送时是否等消息存储完成后再返回。</li>
<li><code>delayTimeLevel</code>：消息延迟级别，用于定时消息或消息重试。</li>
</ul>
</li>
<li><code>body</code>：消息体</li>
<li><code>transactionId</code>：事务 ID</li>
</ul>
<h3 id="生产者启动流程"><a href="#生产者启动流程" class="headerlink" title="生产者启动流程"></a>生产者启动流程</h3><p><code>DefaultMQProducer</code> 是默认的生产者实现类。它实现了 <code>MQAdmin</code> 的接口。</p>
<h4 id="初识-DefaultMQProducer-消息发送者"><a href="#初识-DefaultMQProducer-消息发送者" class="headerlink" title="初识 DefaultMQProducer 消息发送者"></a>初识 <code>DefaultMQProducer</code> 消息发送者</h4><h5 id="DefaultMQProducer-的主要方法"><a href="#DefaultMQProducer-的主要方法" class="headerlink" title="DefaultMQProducer 的主要方法"></a><code>DefaultMQProducer</code> 的主要方法</h5><ul>
<li><code>void createTopic(String key, String newTopic, int queueNum, int topicSysFlag)</code>：创建主题<ul>
<li><code>key</code>：目前未实际作用，可以与 newTopic 相同。</li>
<li><code>newTopic</code>：主题名称。</li>
<li><code>queueNum</code>：队列数量。</li>
<li><code>topicSysFlag</code>：主题系统标签，默认为 0 。</li>
</ul>
</li>
<li><code>long searchOffset(final MessageQueue mq, final long timestamp)</code>：根据时间戳从队列中查找其偏移量。</li>
<li><code>long maxOffset(final MessageQueue mq)</code>：查找该消息队列中最大的物理偏移量。</li>
<li><code>long minOffset(final MessageQueue mq)</code>：查找该消息队列中最小物理偏移量。</li>
<li><code>MessageExt viewMessage(final String offsetMsgld)</code>：根据消息偏移量查找消息。</li>
<li><code>QueryResult queryMessage(final String topic, final String key, final int maxNum, final long begin, final long end)</code>：根据条件查询消息。<ul>
<li><code>topic</code>：消息主题。</li>
<li><code>key</code>：消息索引字段。</li>
<li><code>maxNum</code>：本次最多取出消息条数。</li>
<li><code>begin</code>：开始时间。</li>
<li><code>end</code>：结束时间。</li>
</ul>
</li>
<li><code>MessageExt viewMessage(String topic,String msgld)</code>：根据主题与消息 ID 查找消息。</li>
<li><code>List&lt;MessageQueue&gt; fetchPublishMessageQueues(final String topic)</code>：查找该主题下所有的消息队列。</li>
<li><code>SendResult send(final Message msg)</code>：同步发送消息，具体发送到主题中的哪个消息队列由负载算法决定。</li>
<li><code>SendResult send(final Message msg, final long timeout)</code>：同步发送消息，如果发送超过 timeout 则抛出超时异常。</li>
<li><code>void send(final Message msg, final SendCallback sendCallback)</code>：异步发送消息， sendCallback 参数是消息发送成功后的回调方法。</li>
<li><code>void send(final Message msg, final SendCallback sendCallback, final long timeout)</code>：异步发送消息，如果发送超过 timeout 指定的值，则抛出超时异常。</li>
<li><code>void sendOneway(final Message msg)</code>：单向消息发送，就是不在乎发送结果，消息发送出去后该方法立即返回。</li>
<li><code>SendResult send(final Message msg, final MessageQueue mq)</code>：同步方式发送消息，发送到指定消息队列。</li>
<li><code>void send(final Message msg, final MessageQueue mq, final SendCallback sendCallback)</code>：异步方式发送消息，发送到指定消息队列。</li>
<li><code>void sendOneway(final Message msg, final MessageQueue mq)</code>：单向方式发送消息，发送到指定的消息队列。</li>
<li><code>SendResult send(final Message msg , final MessageQueueSelector selector, final Object arg)</code>：消息发送，指定消息选择算法，覆盖生产者默认的消息队列负载。</li>
<li><code>SendResult send(final Collection&lt;Message&gt; msgs, final MessageQueue mq, final long timeout)</code>：同步批量消息发送。</li>
</ul>
<h5 id="DefaultMQProducer-的核心属性"><a href="#DefaultMQProducer-的核心属性" class="headerlink" title="DefaultMQProducer 的核心属性"></a><code>DefaultMQProducer</code> 的核心属性</h5><ul>
<li><code>producerGroup</code>：生产者所属组，消息服务器在回查事务状态时会随机选择该组中任何一个生产者发起事务回查请求。</li>
<li><code>createTopicKey</code>：默认 topicKey 。</li>
<li><code>defaultTopicQueueNums</code>：默认主题在每一个 Broker 队列数量。</li>
<li><code>sendMsgTimeout</code>：发送消息默认超时时间， 默认 3s 。</li>
<li><code>compressMsgBodyOverHowmuch</code>：消息体超过该值则启用压缩，默认 4K。</li>
<li><code>retryTimesWhenSendFailed</code>：同步方式发送消息重试次数，默认为 2 ，总共执行 3 次。</li>
<li><code>retryTimesWhenSendAsyncFailed</code>：异步方式发送消息重试次数，默认为 2 。</li>
<li><code>retryAnotherBrokerWhenNotStoreOK</code>：消息重试时选择另外一个 Broker ，是否不等待存储结果就返回， 默认为 false 。</li>
<li><code>maxMessageSize</code>：允许发送的最大消息长度，默认为 4M ，眩值最大值为 2^32-1 。</li>
</ul>
<h4 id="生产者启动流程-1"><a href="#生产者启动流程-1" class="headerlink" title="生产者启动流程"></a>生产者启动流程</h4><p><code>DefaultMQProducerImpl#start()</code> 是生产者的启动方法，其主要工作流程如下：</p>
<ol>
<li>检查生产者组（<code>productGroup</code>）是否符合要求；并改变生产者的 <code>instanceName</code> 为进程 ID 。</li>
<li>获取或创建 <code>MQClientInstance</code> 实例。<ul>
<li>整个 JVM 实例中只存在一个 <code>MQClientManager</code> 实例（单例）。</li>
<li><code>MQClientManager</code> 中维护一个 <code>ConcurrentMap</code> 类型的缓存，用于保证同一个 <code>clientId</code> 只会创建一个 <code>MQClientInstance</code>。</li>
</ul>
</li>
<li>将当前生产者注册到 <code>MQClientInstance</code> 中，方便后续调用网络请求、进行心跳检测等。</li>
<li>启动 <code>MQClientInstance</code> ，如果 <code>MQClientInstance</code> 已经启动，则本次启动不会真正执行。</li>
<li>向所有 Broker 发送心跳。</li>
<li>启动一个定时任务，用于定期清理过时的发送请求。</li>
</ol>
<h3 id="消息发送基本流程"><a href="#消息发送基本流程" class="headerlink" title="消息发送基本流程"></a>消息发送基本流程</h3><p>消息发送的核心方法是 <code>DefaultMQProducerImpl#sendDefaultImpl</code>。</p>
<h4 id="消息长度验证"><a href="#消息长度验证" class="headerlink" title="消息长度验证"></a>消息长度验证</h4><p>消息发送之前，首先确保生产者处于运行状态，然后验证消息是否符合相应的规范，具体的规范要求是主题名称、消息体不能为空、消息长度不能等于 0 且默认不能超过允许发送消息的最大长度 4M（<code>maxMessageSize=l024 * 1024 * 4</code>） 。</p>
<h4 id="查找主题路由信息"><a href="#查找主题路由信息" class="headerlink" title="查找主题路由信息"></a>查找主题路由信息</h4><p>消息发送之前，首先需要获取主题的路由信息，只有获取了这些信息我们才知道消息要发送到具体的 Broker 节点。</p>
<p>tryToFindTopicPublishInfo 是查找主题的路由信息的方法。</p>
<p>如果生产者中缓存了 topic 的路由信息，或路由信息中包含了消息队列，则直接返回该路由信息。</p>
<p>如果没有缓存或没有包含消息队列， 则向 NameServer 查询该 topic 的路由信息。</p>
<p>如果最终未找到路由信息，则抛出异常：无法找到主题相关路由信息异常。</p>
<p><code>TopicPublishinfo</code> 的属性：</p>
<ul>
<li><code>orderTopic</code>：是否为顺序消息。</li>
<li><code>haveTopicRouterInfo</code>：是否有主题路由信息。</li>
<li><code>List&lt;MessageQueue&gt; messageQueueList</code>：Topic 的消息队列。</li>
<li><code>sendWhichQueue</code>：用于选择消息队列。每选择一次消息队列， 该值会自增 1。</li>
<li><code>topicRouteData</code>：主题路由数据。</li>
</ul>
<p><code>MQClientlnstance#updateTopicRouteInfoFromNameServer</code> 这个方法的功能是生产者更新和维护路由缓存。</p>
<ol>
<li>如果 <code>isDefault</code> 为 true，则使用默认主题去查询，如果查询到路由信息，则替换路由信息中读写队列个数为生产者默认的队列个数（<code>defaultTopicQueueNums</code>）；如果 <code>isDefault</code> 为 false，则使用参数 topic 去查询；如果未查询到路由信息，则返回 false ，表示路由信息未变化。</li>
<li>如果路由信息找到，与本地缓存中的路由信息进行对比，判断路由信息是否发生了改变，如果未发生变化，则直接返回 false 。</li>
<li>更新 <code>MQClientInstance</code> 的 Broker 地址缓存表。</li>
<li>根据 <code>topicRouteData</code> 中的 <code>List&lt;QueueData&gt;</code> 转换成 <code>topicPublishInfo</code> 的 <code>List&lt;MessageQueue&gt;</code> 列表。其具体实现在 <code>topicRouteData2TopicPublishInfo</code> 中， 然后会更新该 <code>MQClientInstance</code> 所管辖的所有消息，发送关于 topic 的路由信息。</li>
<li>循环遍历路由信息的 QueueData 信息，如果队列没有写权限，则继续遍历下一个 QueueData；根据 brokerName 找到 brokerData 信息，找不到或没有找到 Master 节点，则遍历下一个 QueueData；根据写队列个数，根据 topic ＋序号 创建 <code>MessageQueue</code> ，填充 <code>TopicPublishInfo</code> 的 <code>List&lt;QueueMessage&gt;</code>。</li>
</ol>
<h4 id="选择-Broker"><a href="#选择-Broker" class="headerlink" title="选择 Broker"></a>选择 Broker</h4><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><h2 id="RocketMQ-消息存储"><a href="#RocketMQ-消息存储" class="headerlink" title="RocketMQ 消息存储"></a>RocketMQ 消息存储</h2><h2 id="RocketMQ-消息消费"><a href="#RocketMQ-消息消费" class="headerlink" title="RocketMQ 消息消费"></a>RocketMQ 消息消费</h2><h2 id="消息过滤-FilterServer"><a href="#消息过滤-FilterServer" class="headerlink" title="消息过滤 FilterServer"></a>消息过滤 FilterServer</h2><h2 id="RocketMQ-主从同步"><a href="#RocketMQ-主从同步" class="headerlink" title="RocketMQ 主从同步"></a>RocketMQ 主从同步</h2><h2 id="RocketMQ-事务消息"><a href="#RocketMQ-事务消息" class="headerlink" title="RocketMQ 事务消息"></a>RocketMQ 事务消息</h2><h2 id="RocketMQ-实战"><a href="#RocketMQ-实战" class="headerlink" title="RocketMQ 实战"></a>RocketMQ 实战</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35626441/">RocketMQ 技术内幕</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/06f95a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/06f95a/" class="post-title-link" itemprop="url">《软件工程之美》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 13:20:31" itemprop="dateCreated datePublished" datetime="2022-07-12T13:20:31+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《软件工程之美》笔记"><a href="#《软件工程之美》笔记" class="headerlink" title="《软件工程之美》笔记"></a>《软件工程之美》笔记</h1><h2 id="到底应该怎样理解软件工程？"><a href="#到底应该怎样理解软件工程？" class="headerlink" title="到底应该怎样理解软件工程？"></a>到底应该怎样理解软件工程？</h2><p><strong>软件产品危机</strong>：软件产品质量低劣、软件维护工作量大、成本不断上升、进度不可控、程序人员无限度地增加。</p>
<p>软件工程，它是为研究和克服软件危机而生。</p>
<p><strong>软件工程的本质</strong>：用工程化方法去规范软件开发，让项目可以按时完成、成本可控、质量有保证。</p>
<p><strong>软件工程的核心</strong>：是围绕软件项目开发，对开发过程的组织，对方法的运用，对工具的使用。</p>
<p><strong>软件工程 &#x3D; 过程 + 方法 + 工具。</strong></p>
<h2 id="工程思维：把每件事都当作一个项目来推进"><a href="#工程思维：把每件事都当作一个项目来推进" class="headerlink" title="工程思维：把每件事都当作一个项目来推进"></a>工程思维：把每件事都当作一个项目来推进</h2><p><strong>有目的、有计划、有步骤地解决问题的方法就是工程方法。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712132650.png"></p>
<p>工程方法通常会分成六个阶段：想法、概念、计划、设计、开发和发布。</p>
<ul>
<li><strong>想法：</strong>想法阶段通常是想要解决问题。最开始问题通常是模糊的，所以需要清晰地定义好问题，研究其可行性，检查是否有可行的解决方案。</li>
<li><strong>概念：</strong>概念阶段就是用图纸、草图、模型等方式，提出一些概念性的解决方案。这些方案可能有多个，最终会确定一个解决方案。</li>
<li><strong>计划：</strong>计划阶段是关于如何实施的计划，通常会包含人员、任务、任务持续时间、任务的依赖关系，以及完成项目所需要的预算。</li>
<li><strong>设计：</strong>设计阶段就是要针对产品需求，将解决方案进一步细化，设计整体架构和划分功能模块，作为分工合作和开发实施的一个依据和参考。</li>
<li><strong>开发：</strong>开发阶段就是根据设计方案，将解决方案构建实施。开发阶段通常是一个迭代的过程，这个阶段通常会有构建、测试、调试和重新设计的迭代。</li>
<li><strong>发布：</strong>将最终结果包括文档发布。</li>
</ul>
<h2 id="瀑布模型：像工厂流水线一样把软件开发分层化"><a href="#瀑布模型：像工厂流水线一样把软件开发分层化" class="headerlink" title="瀑布模型：像工厂流水线一样把软件开发分层化"></a>瀑布模型：像工厂流水线一样把软件开发分层化</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712133102.png"></p>
<p>瀑布模型把整个项目过程分成了六个主要阶段：</p>
<ul>
<li><strong>问题的定义及规划</strong>：这个阶段是需求方和开发方共同确定软件开发目标，同时还要做可行性研究，以确定项目可行。这个阶段会产生需求文档和可行性研究报告。</li>
<li><strong>需求分析</strong>：对需求方提出的所有需求，进行详细的分析。这个阶段一般需要和客户反复确认，以保证能充分理解客户需求。最终会形成需求分析文档。</li>
<li><strong>软件设计</strong>：根据需求分析的结果，对整个软件系统进行抽象和设计，如系统框架设计，数据库设计等等。最后会形成架构设计文档。</li>
<li><strong>程序编码</strong>：将架构设计和界面设计的结果转换成计算机能运行的程序代码。</li>
<li><strong>软件测试</strong>：在编码完成后，对可运行的结果对照需求分析文档进行严密的测试。如果测试发现问题，需要修复。最终测试完成后，形成测试报告。</li>
<li><strong>运行维护</strong>：在软件开发完成，正式运行投入使用。后续需要继续维护，修复错误和增加功能。交付时需要提供使用说明文档。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712133357.png"></p>
<h2 id="瀑布模型之外，还有哪些开发模型？"><a href="#瀑布模型之外，还有哪些开发模型？" class="headerlink" title="瀑布模型之外，还有哪些开发模型？"></a>瀑布模型之外，还有哪些开发模型？</h2><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p><strong>快速原型模型，就是为了要解决客户的需求不明确和需求多变的问题。</strong></p>
<p>先迅速建造一个可以运行的软件原型，然后收集用户反馈，再反复修改确认，使开发出的软件能真正反映用户需求，这种开发模型就叫快速原型模型，也叫原型模型。</p>
<p>原型模型因为能快速修改，所以能快速对用户的反馈和变更作出响应，同时原型模型注重和客户的沟通，所以最终开发出来的软件能够真正反映用户的需求。</p>
<p>但这种快速原型开发往往是以牺牲质量为代价的。</p>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量模型是把待开发的软件系统模块化，然后在每个小模块的开发过程中，应用一个小瀑布模型，对这个模块进行需求分析、设计、编码和测试。相对瀑布模型而言，增量模型周期更短，不需要一次性把整个软件产品交付给客户，而是分批次交付。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712134154.png"></p>
<p>因为增量模型的根基是模块化，所以，<strong>如果系统不能模块化，那么将很难采用增量模型的模式来开发。</strong>另外，对模块的划分很抽象，这本身对于系统架构的水平是要求很高的。</p>
<p>基于这样的特点，增量模型主要适用于：<strong>需求比较清楚，能模块化的软件系统，并且可以按模块分批次交付。</strong></p>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型每次只设计和实现产品的一部分，然后逐步完成更多功能。每次设计和实现一个阶段叫做一个迭代。</p>
<p>在迭代模型中，整个项目被拆分成一系列小的迭代。通常一个迭代的时间都是固定的，不会太长，例如 2-4 周。每次迭代只实现一部分功能，做能在这个周期内完成的功能。</p>
<p>在一个迭代中都会包括需求分析、设计、实现和测试，类似于一个小瀑布模型。<strong>迭代结束时要完成一个可以运行的交付版本。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712134329.png"></p>
<p><strong>增量模型是按照功能模块来拆分；而迭代模型则是按照时间来拆分，看单位时间内能完成多少功能。</strong></p>
<h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><p>V 模型适合外包项目。V 模型本质上还是瀑布模型，只不过它是更重视对每个阶段验收测试的过程模型。</p>
<p>针对从需求定义一直到编码阶段，每个阶段都有对应的测试验收。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712134518.png"></p>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>如果你现在要做一个风险很高的项目，客户可能随时不给你钱了。这种情况下，如果采用传统瀑布模型，无疑风险很高，可能做完的时候才发现客户给不了钱，损失就很大了！</p>
<p>这种情况，基于增量模型或者迭代模型进行开发，就可以有效降低风险。你需要注意的是，在每次交付的时候，要同时做一个风险评估，如果风险过大就不继续后续开发了，及时止损。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712134638.png"></p>
<p>这种强调风险，以风险驱动的方式完善项目的开发模型就是螺旋模型。</p>
<h2 id="敏捷开发到底是想解决什么问题？"><a href="#敏捷开发到底是想解决什么问题？" class="headerlink" title="敏捷开发到底是想解决什么问题？"></a>敏捷开发到底是想解决什么问题？</h2><p>敏捷开发是一套价值观和原则。</p>
<p>瀑布模型面向的是过程，而敏捷开发面向的是人。</p>
<h2 id="大厂都在用哪些敏捷方法？（上）"><a href="#大厂都在用哪些敏捷方法？（上）" class="headerlink" title="大厂都在用哪些敏捷方法？（上）"></a>大厂都在用哪些敏捷方法？（上）</h2><h3 id="一切工作任务围绕-Ticket-开展"><a href="#一切工作任务围绕-Ticket-开展" class="headerlink" title="一切工作任务围绕 Ticket 开展"></a>一切工作任务围绕 Ticket 开展</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220712135814.png"></p>
<ul>
<li>每一个任务的状态都可以被跟踪起来：什么时候开始做的，谁在做，做完没有。</li>
<li>整个团队在做什么一目了然。</li>
<li>Ticket 和敏捷开发中的 Backlog（任务清单）正好结合起来，通过 Ticket 可以收集管理整个项目的 Backlog 和当前 Sprint（迭代）的 Backlog。</li>
</ul>
<h3 id="基于-Git-和-CI-的开发流程"><a href="#基于-Git-和-CI-的开发流程" class="headerlink" title="基于 Git 和 CI 的开发流程"></a>基于 Git 和 CI 的开发流程</h3><p>Git 本来只是源代码管理工具，但是其强大的分支管理和灵活的权限控制，结合一定的开发流程，却可以帮助你很好的控制代码质量。</p>
<h3 id="站立会议"><a href="#站立会议" class="headerlink" title="站立会议"></a>站立会议</h3><ul>
<li>每个人轮流介绍一下，昨天干了什么事情，今天计划做什么事情，工作上有没有障碍无法推进。有问题，记录到“问题停车场”。</li>
<li>检查最近的 Ticket，甄别一下优先级。有需要讨论的先收集到问题停车场。</li>
<li>针对未讨论的问题展开讨论，能在会议时间内解决的问题，就马上解决，不能解决的会后再私下讨论或者再组织会议。</li>
</ul>
<h2 id="大厂都在用哪些敏捷方法？（下）"><a href="#大厂都在用哪些敏捷方法？（下）" class="headerlink" title="大厂都在用哪些敏捷方法？（下）"></a>大厂都在用哪些敏捷方法？（下）</h2><p>在分工上：</p>
<ul>
<li>产品经理：写需求设计文档，将需求整理成 Ticket，随时和项目成员沟通确认需求；</li>
<li>开发人员：每天从看板上按照优先级从高到低领取 Ticket，完成日常开发任务；</li>
<li>测试人员：测试已经部署到测试环境的程序，如果发现 Bug，提交 Ticket；</li>
<li>项目经理：保障日常工作流程正常执行，让团队成员可以专注工作，提供必要的帮助，解决问题。</li>
</ul>
<p>如何完成需求和修复 Bug？</p>
<p>日常工作，是围绕 Ticket 来开展的。所有的需求、Bug、任务都作为 Ticket 提交到项目的 Backlog，每个 Sprint 的任务都以看板的形式展现出来。</p>
<p>每个人手头事情忙完后，就可以去看板上的“To Do”栏，按照优先级从高到低选取新的 Ticket。选取后移动到“In Progress”栏。</p>
<p>每周一部署生产环境</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023701">软件工程之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">46:19</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>




  <script src="/blog/js/third-party/pace.js"></script>

  




<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"aeeb3f9beb9de9d8a40e72b74dc3ab8e"}</script>
<script src="/blog/js/third-party/comments/gitalk.js"></script>

</body>
</html>
