<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/5/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">279</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">118</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">385</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">385</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">118</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">279</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d7cd88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d7cd88/" class="post-title-link" itemprop="url">数据结构与数据库索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-27 23:39:10" itemprop="dateCreated datePublished" datetime="2022-03-27T23:39:10+08:00">2022-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">数据库综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据结构与数据库索引"><a href="#数据结构与数据库索引" class="headerlink" title="数据结构与数据库索引"></a>数据结构与数据库索引</h1><blockquote>
<p>关键词：链表、数组、散列表、红黑树、B+ 树、LSM 树、跳表</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>数据库</strong>是“按照 <strong>数据结构</strong> 来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。</p>
<p>——上面这句定义对数据库的定义来自百度百科。通过这个定义，我们也能明显看出数据结构是实现数据库的基石。</p>
<p>从本质来看，数据库只负责两件事：读数据、写数据；而数据结构研究的是如何合理组织数据，尽可能提升读、写数据的效率，这恰好是数据库的核心问题。因此，数据结构与数据库这两个领域有非常多的交集。其中，数据库索引最能体现二者的紧密关联。</p>
<p><strong>索引是数据库为了提高查找效率的一种数据结构</strong>。索引基于原始数据衍生而来，它的主要作用是缩小检索的数据范围，提升查询性能。通俗来说，索引在数据库中的作用就像是一本书的目录索引。索引对于良好的性能非常关键，在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，<strong>索引优化应该是查询性能优化的最有效手段</strong>。</p>
<p>很多数据库允许单独添加和删除索引，而不影响数据库的内容，它只会影响查询性能。维护额外的结构势必会引入开销，特别是在新数据写入时。对于写入，它很难超过简单地追加文件方式的性能，因为那已经是最简单的写操作了。由于每次写数据时，需要更新索引，因此任何类型的索引通常都会降低写的速度。</p>
<p>本文以一些常见的数据库为例，分析它们的索引采用了什么样的数据结构，有什么利弊，为何如此设计。</p>
<h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>数组和链表分别代表了连续空间和不连续空间的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，实际上都是这两者的结合和变化。</p>
<p><strong>数组用连续的内存空间来存储数据</strong>。数组**支持随机访问，根据下标随机访问的时间复杂度为 <code>O(1)</code>**。但这并不代表数组的查找时间复杂度也是 <code>O(1)</code>。</p>
<ul>
<li>**对于无序数组，只能顺序查找，其时间复杂度为 <code>O(n)</code>**。</li>
<li>**对于有序数组，可以应用二分查找法，其时间复杂度为 <code>O(log n)</code>**。</li>
</ul>
<p>在有序数组上应用二分查找法如此高效，为什么几乎没有数据库直接使用数组作为索引？这是因为它的限制条件：<strong>数据有序</strong>——为了保证数据有序，每次添加、删除数组数据时，都必须要进行数据调整，来保证其有序，而 **数组的插入&#x2F;删除操作，时间复杂度为 <code>O(n)</code>**。此外，由于数组空间大小固定，每次扩容只能采用复制数组的方式。数组的这些特性，决定了它不适合用于数据频繁变化的应用场景。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220320115836.png" alt="img"></p>
<p><strong>链表用不连续的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链</strong>。</p>
<p>区别于数组，链表中的元素不是存储在内存中连续的一片区域，链表中的数据存储在每一个称之为「结点」复合区域里，在每一个结点除了存储数据以外，还保存了到下一个节点的指针（Pointer）。由于不必按顺序存储，**链表的插入&#x2F;删除操作，时间复杂度为 <code>O(1)</code>**，但是，链表只支持顺序访问，其 **查找时间复杂度为 <code>O(n)</code>**。其低效的查找方式，决定了链表不适合作为索引。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220320174829.png" alt="img"></p>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希表是一种以键 - 值（key-value）对形式存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。</p>
<p><strong>哈希表</strong> 使用 <strong>哈希函数</strong> 组织数据，以支持快速插入和搜索的数据结构。哈希表的本质是一个数组，其思路是：使用 Hash 函数将 Key 转换为数组下标，利用数组的随机访问特性，使得我们能在 <code>O(1)</code> 的时间代价内完成检索。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220320201844.png" alt="img"></p>
<p>有两种不同类型的哈希表：<strong>哈希集合</strong> 和 <strong>哈希映射</strong>。</p>
<ul>
<li><strong>哈希集合</strong> 是集合数据结构的实现之一，用于存储非重复值。</li>
<li><strong>哈希映射</strong> 是映射 数据结构的实现之一，用于存储键值对。</li>
</ul>
<p>哈希索引基于哈希表实现，<strong>只适用于等值查询</strong>。对于每一行数据，哈希索引都会将所有的索引列计算一个哈希码（<code>hashcode</code>），哈希码是一个较小的值。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>✔ 哈希索引的<strong>优点</strong>：</p>
<ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
</ul>
<p>❌ 哈希索引的<strong>缺点</strong>：</p>
<ul>
<li>哈希索引值包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li>
<li><strong>哈希索引数据不是按照索引值顺序存储的</strong>，所以<strong>无法用于排序</strong>。</li>
<li>哈希索引<strong>不支持部分索引匹配查找</strong>，因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li>哈希索引<strong>只支持等值比较查询</strong>，包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>；不支持任何范围查询，如 <code>WHERE price &gt; 100</code>。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong><ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
<li>如果哈希冲突多的话，维护索引的代价会很高。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为种种限制，所以哈希索引只适用于特定的场合。而一旦使用哈希索引，则它带来的性能提升会非常显著。例如，Mysql 中的 Memory 存储引擎就显示的支持哈希索引。</p>
</blockquote>
<h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h2><p>通常我们所说的 B 树索引是指 <code>B-Tree</code> 索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用 <code>B-Tree</code> 这个术语，是因为 MySQL 在 <code>CREATE TABLE</code> 或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 使用的是 <code>B+Tree</code>索引；而 MyISAM 使用的是 <code>B-Tree</code>索引。</p>
<p><code>B-Tree</code> 索引中的 B 是指 <code>balance</code>，意为平衡。需要注意的是，<code>B-Tree</code> 索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是 <code>O(log n)</code>。</p>
<p>当然为了维持 <code>O(log n)</code> 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 <code>O(log n)</code>。</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I&#x2F;O 消耗，相对于内存存取，I&#x2F;O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I&#x2F;O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I&#x2F;O 存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p>
<h3 id="B-Tree-索引-1"><a href="#B-Tree-索引-1" class="headerlink" title="B+Tree 索引"></a><code>B+Tree</code> 索引</h3><p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p>
<p>理解 <code>B+Tree</code>，只需要理解其最重要的两个特征即可：</p>
<ul>
<li>第一，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>其次，所有的叶子节点由指针连接。如下图为简化了的<code>B+Tree</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200304235424.jpg" alt="img"></p>
<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li><strong>聚簇索引（clustered）</strong>：又称为主键索引，其叶子节点存的是整行数据。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。<strong>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行</strong>。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引（secondary）</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。</li>
</ul>
<p><strong>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快</strong>。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</p>
<p><strong>聚簇索引和非聚簇索引的查询有什么区别</strong></p>
<ul>
<li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<hr>
<p>内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。</p>
<p>而磁盘是机械器件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取相应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10 万到 100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。</p>
<p>磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 <strong><code>512</code></strong> 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 <strong><code>4K</code></strong> 个字节。操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫作簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>假设有一个有序数组存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘中读到内存里，然后在内存中进行二分查找。如果下一步要读的元素在其他块中，则需要再将相应块从磁盘中读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。</p>
<p>由于磁盘相对于内存而言访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！</p>
<p>将索引和数据分离就是一种常见的设计思路。在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。但是，哈希表由于缺乏范围检索的能力，在一些场合也不适用。因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。</p>
<p>随着索引数据越来越大，直到无法完全加载到内存中，这是需要将索引数据也存入磁盘中。B+ 树给出了将树形索引的所有节点都存在磁盘上的高效检索方案。操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树型索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+ 树的一个关键设计，就是让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。</p>
<p>B+ 树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+ 树就能做到节点的空间利用率最大化。此外，B+ 树还将同一层的所有节点串成了有序的双向链表，这样一来，B+ 树就同时具备了良好的范围查询能力和灵活调整的能力了。</p>
<p>因此，B+ 树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，指的是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。</p>
<p>即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更<br>高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。</p>
<p>另外，这一节还有一个很重要的设计思想需要你掌握，那就是将索引和数据分离。通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在许多大规模系统中，都是使用这个设计思想来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一次实践。</p>
<p>MySQL 中的 B+ 树实现其实有两种，一种是 MyISAM 引擎，另一种是 InnoDB 引擎。它们的核心区别就在于，数据和索引是否是分离的。</p>
<p>在 MyISAM 引擎中，B+ 树的叶子节点仅存储了数据的位置指针，这是一种索引和数据分离的设计方案，叫作非聚集索引。如果要保证 MyISAM 的数据一致性，那我们需要在表级别上进行加锁处理。</p>
<p>在 InnoDB 中，B+ 树的叶子节点直接存储了具体数据，这是一种索引和数据一体的方案。叫作聚集索引。由于数据直接就存在索引的叶子节点中，因此 InnoDB 不需要给全表加锁来保证一致性，它只需要支持行级的锁就可以了。</p>
<h2 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h2><p>B+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。</p>
<p>操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：<strong>LSM 树</strong>（Log Structured Merge Trees）。</p>
<p>LSM 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<p>LSM 树具有以下 3 个特点：</p>
<ol>
<li>将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（Merge Trees）；</li>
<li>用批量写入代替随机写入，并且用预写日志 WAL 技术（Write AheadLog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；</li>
<li>数据采取类似日志追加写的方式写入（Log Structured）磁盘，以顺序写的方式提高写<br>入效率。</li>
</ol>
<p>LSM 树的这些特点，使得它相对于 B+ 树，在写入性能上有大幅提升。所以，许多 NoSQL 系统都使用 LSM 树作为检索引擎，而且还对 LSM 树进行了优化以提升检索性能。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间代价内完成查询。</p>
<p>尽管原理并不复杂，但是倒排索引是许多检索引擎的核心。比如说，数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。</p>
<h2 id="索引的维护"><a href="#索引的维护" class="headerlink" title="索引的维护"></a>索引的维护</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><ul>
<li><strong>数据压缩</strong>：一个是尽可能地将数据加载到内存中，因为内存的检索效率大大高于磁盘。那为了将数据更多地加载到内存中，索引压缩是一个重要的研究方向。</li>
<li><strong>分支处理</strong>：另一个是将大数据集合拆成多个小数据集合来处理。这其实就是分布式系统的核心思想。</li>
</ul>
<h3 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h3><p>（1）Double Buffer（双缓冲）机制</p>
<p>就是在内存中同时保存两份一样的索引，一个是索引 A，一个是索引 B。两个索引保持一个读、一个写，并且来回切换，最终完成高性能的索引更新。</p>
<p>优点：简单高效</p>
<p>缺点：达到一定数据量级后，会带来翻倍的内存开销，甚至有些索引存储在磁盘上的情况下，更是无法使用此机制。</p>
<p>（2）全量索引和增量索引</p>
<p>将新接收到的数据单独建立一个可以存在内存中的倒排索引，也就是增量索引。当查询发生的时候，我们会同时查询全量索引和增量索引，将合并的结果作为总的结果输出。</p>
<p>因为增量索引相对全量索引而言会小很多，内存资源消耗在可承受范围，所以我们可以使用 Double Buffer 机制<br>对增量索引进行索引更新。这样一来，增量索引就可以做到无锁访问。而全量索引本身就是只读的，也不需要加锁。因此，整个检索过程都可以做到无锁访问，也就提高了系统的检索效率。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/">《数据密集型应用系统设计》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cise.ufl.edu/~mschneid/Research/papers/HS05BoCh.pdf">Data Structures for Databases</a></li>
<li><a target="_blank" rel="noopener" href="https://people.csail.mit.edu/bradley/BenderKuszmaul-tutorial-xldb12.pdf">Data Structures and Algorithms for Big Databases</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/cba821/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/cba821/" class="post-title-link" itemprop="url">复杂度分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 23:25:17" itemprop="dateCreated datePublished" datetime="2022-03-20T23:25:17+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="为什么需要复杂度分析"><a href="#为什么需要复杂度分析" class="headerlink" title="为什么需要复杂度分析"></a>为什么需要复杂度分析</h2><p>衡量算法的优劣，有两种评估方式：事前估计和后期测试。</p>
<p>后期测试有性能测试、基准测试（Benchmark）等手段。</p>
<p>但是，后期测试有以下限制：</p>
<ul>
<li><strong>测试结果非常依赖测试环境</strong>。如：不同机型、不同编译器版本、不同硬件配置等等，都会影响测试结果。</li>
<li><strong>测试结果受数据规模的影响很大</strong>。</li>
</ul>
<p>所以，需要一种方法，可以不受环境或数据规模的影响，粗略地估计算法的执行效率。这种方法就是复杂度分析。</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h3><p>假设问题的规模为 n，则程序的时间复杂度表示为 <code>T(n)</code>。<strong>代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>。</p>
<p>当 n 增大时，T(n) 也随之增大，想要准确估计其变化比较困难。所以，可以采用大 O 时间复杂度来粗略估计其复杂度，其表达式为：**<code>T(n) = O(f(n))</code>**。</p>
<p><strong>大 O 表示法</strong>实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<h3 id="时间复杂度分析的要点"><a href="#时间复杂度分析的要点" class="headerlink" title="时间复杂度分析的要点"></a>时间复杂度分析的要点</h3><ul>
<li><strong>只关注循环执行次数最多的一段代码</strong></li>
<li><strong>加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></li>
<li><strong>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></li>
</ul>
<h3 id="最好、最坏和平均情况"><a href="#最好、最坏和平均情况" class="headerlink" title="最好、最坏和平均情况"></a>最好、最坏和平均情况</h3><ul>
<li><strong>最好情况时间复杂度</strong>（best case time complexity）：<strong>在最理想的情况下，执行代码的时间复杂度</strong>。例如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，此时最好情况时间复杂度为 1。</li>
<li><strong>最坏情况时间复杂度</strong>（worst case time complexity）：<strong>在最糟糕的情况下，执行代码的时间复杂度</strong>。例如：在最理想的情况下，要查找的变量 x 正好是数组的最后个元素，此时最好情况时间复杂度为 n。</li>
<li><strong>平均情况时间复杂度</strong>（average case time complexity）：平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</li>
</ul>
<h3 id="时间复杂度分析示例"><a href="#时间复杂度分析示例" class="headerlink" title="时间复杂度分析示例"></a>时间复杂度分析示例</h3><p>【示例】从 1 累加到 100 的时间复杂度是多少？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度计算：显然，这段代码执行了 100 次加法，其时间复杂度和 N 的大小完全一致</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">T(<span class="params">n</span>)</span> = <span class="constructor">O(<span class="params">n</span>)</span></span><br></pre></td></tr></table></figure>

<p>【示例】嵌套循环的时间复杂度是多少？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度计算：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span>(<span class="built_in">n</span>) = (M-<span class="number">1</span>)(<span class="built_in">N</span>-<span class="number">1</span>) = O(M*<span class="built_in">N</span>) ≈ O(<span class="built_in">N</span>^<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>【示例】递归函数的时间复杂度是多少？思考一下斐波那契数列 <code>f(n) = f(n-1) + f(n-2)</code> 的时间复杂度是多少？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220320110642.png" alt="img"></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">T</span><span class="params">(n)</span></span> = <span class="built_in">O</span>(<span class="number">2</span>^N)</span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。</p>
<p>类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>
<h2 id="复杂度量级"><a href="#复杂度量级" class="headerlink" title="复杂度量级"></a>复杂度量级</h2><p>复杂度有以下量级：</p>
<ul>
<li>**<code>O(1)</code>**：常数复杂度</li>
<li>**<code>O(log n)</code>**：对数复杂度</li>
<li>**<code>O(n)</code>**：线性复杂度</li>
<li>**<code>O(nlog n)</code>**：线性对数阶复杂度</li>
<li>**<code>O(n^2)</code>**：平方复杂度</li>
<li>**<code>O(n^3)</code>**：立方复杂度</li>
<li>**<code>O(n^k)</code>**：K 次方复杂度</li>
<li>**<code>O(2^n)</code>**：指数复杂度</li>
<li>**<code>O(n!)</code>**：阶乘复杂度</li>
</ul>
<p>在数据量比较小的时候，复杂度量级差异并不明显；但是，随着数据规模大小的变化，差异会逐渐突出。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220320160627.png" alt="img"></p>
<p><code>O(1)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br></pre></td></tr></table></figure>

<p><code>O(log n)</code> 对数复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; max; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>O(n)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; max; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>O(n^2)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>O(k^n)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= Math.pow(<span class="number">2</span>, max); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见数据结构的复杂度"><a href="#常见数据结构的复杂度" class="headerlink" title="常见数据结构的复杂度"></a>常见数据结构的复杂度</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200702071922.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/899690/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/899690/" class="post-title-link" itemprop="url">LSM树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-16 09:27:21" itemprop="dateCreated datePublished" datetime="2022-03-16T09:27:21+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h1><h2 id="什么是-LSM-树"><a href="#什么是-LSM-树" class="headerlink" title="什么是 LSM 树"></a>什么是 LSM 树</h2><p>LSM 树具有以下 3 个特点：</p>
<ol>
<li>将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（Merge Trees）；</li>
<li>用批量写入代替随机写入，并且用预写日志 WAL 技术（Write AheadLog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；</li>
<li>数据采取类似日志追加写的方式写入（Log Structured）磁盘，以顺序写的方式提高写<br>入效率。</li>
</ol>
<p>LSM 树的这些特点，使得它相对于 B+ 树，在写入性能上有大幅提升。所以，许多 NoSQL 系统都使用 LSM 树作为检索引擎，而且还对 LSM 树进行了优化以提升检索性能。</p>
<p>LSM 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<h3 id="如何将内存数据与磁盘数据合并"><a href="#如何将内存数据与磁盘数据合并" class="headerlink" title="如何将内存数据与磁盘数据合并"></a>如何将内存数据与磁盘数据合并</h3><p>可以参考两个有序链表归并排序的过程，将 C0 树和 C1 树的所有叶子节点中存储的数据，看作是两个有序链表，那滚动合并问题就变成了我们熟悉的两个有序链表的归并问题。不过由于涉及磁盘操作，那为了提高写入效率和检索效率，我们还需要针对磁盘的特性，在一些归并细节上进行优化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220316105440.png" alt="img"></p>
<p>由于磁盘具有顺序读写效率高的特性，因此，为了提高 C1 树中节点的读写性能，除了根节点以外的节点都要尽可能地存放到连续的块中，让它们能作为一个整体单位来读写。这种包含多个节点的块就叫作多页块（Multi-Pages Block）。</p>
<p>第一步，以多页块为单位，将 C1 树的当前叶子节点从前往后读入内存。读入内存的多页块，叫作清空块（Emptying Block），意思是处理完以后会被清空。</p>
<p>第二步，将 C0 树的叶子节点和清空块中的数据进行归并排序，把归并的结果写入内存的一个新块中，叫作填充块（Filling Block）。</p>
<p>第三步，如果填充块写满了，我们就要将填充块作为新的叶节点集合顺序写入磁盘。这个时候，如果 C0 树的叶子节点和清空块都没有遍历完，我们就继续遍历归并，将数据写入新的填充块。如果清空块遍历完了，我们就去 C1 树中顺序读取新的多页块，加载到清空块中。</p>
<p>第四步，重复第三步，直到遍历完 C0 树和 C1 树的所有叶子节点，并将所有的归并结果写入到磁盘。这个时候，我们就可以同时删除 C0 树和 C1 树中被处理过的叶子节点。这样就完成了滚动归并的过程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220316110736.png" alt="img"></p>
<h3 id="LSM-树是如何检索"><a href="#LSM-树是如何检索" class="headerlink" title="LSM 树是如何检索"></a>LSM 树是如何检索</h3><p>因为同时存在 C0 和 C1 树，所以要查询一个 key 时，我们会先到 C0 树中查询。如果查询到了则直接返回；如过没有查询到，则查询 C1 树。</p>
<p>需要注意一种特殊情况：删除操作。假设某数据在 C0 树中被删除了，但是在 C1 树中仍存在。这此时查询时，可以在 C1 树中查到这个 key，这其实是过期数据了，如何应对这种情况呢？对于被删除的数据，可以将这些数据的 key 插入到 C0 树中，并标记一个删除标志。如果查到了一个带着删除标志的 key，就直接返回查询失败。</p>
<h2 id="为什么需要-LSM-树"><a href="#为什么需要-LSM-树" class="headerlink" title="为什么需要 LSM 树"></a>为什么需要 LSM 树</h2><p>在关系型数据库中，通常使用 B+ 树作为索引。B+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。</p>
<p>操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：<strong>LSM 树</strong>（Log Structured Merge Trees）。</p>
<h2 id="WAL-技术"><a href="#WAL-技术" class="headerlink" title="WAL 技术"></a>WAL 技术</h2><p>LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<p>如果机器断电或系统崩溃了，那内存中还未写入磁盘的数据岂不就永远丢失了？这种情况我们该如何解决呢？</p>
<p>为了保证内存中的数据在系统崩溃后能恢复，可以使用 WAL 技术（Write Ahead Log，预写日志技术）将数据第一时间高效写入磁盘进行备份。</p>
<p>WAL 技术保存和恢复数据的具体步骤如下：</p>
<ol>
<li>内存中的程序在处理数据时，会先将对数据的修改作为一条记录，顺序写入磁盘的 log 文件作为备份。由于磁盘文件的顺序追加写入效率很高，因此许多应用场景都可以接受这种备份处理。</li>
<li>在数据写入 log 文件后，备份就成功了。接下来，该数据就可以长期驻留在内存中了。</li>
<li>系统会周期性地检查内存中的数据是否都被处理完了（比如，被删除或者写入磁盘），并且生成对应的检查点（Check Point）记录在磁盘中。然后，我们就可以随时删除被处理完的数据了。这样一来，log 文件就不会无限增长了。</li>
<li>系统崩溃重启，我们只需要从磁盘中读取检查点，就能知道最后一次成功处理的数据在 log 文件中的位置。接下来，我们就可以把这个位置之后未被处理的数据，从 log 文件中读出，然后重新加载到内存中。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220316104837.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/2ba2ac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/2ba2ac/" class="post-title-link" itemprop="url">B+树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-13 22:37:27" itemprop="dateCreated datePublished" datetime="2022-03-13T22:37:27+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="什么是-B-树"><a href="#什么是-B-树" class="headerlink" title="什么是 B+树"></a>什么是 B+树</h2><p>B+树是在二叉查找树的基础上进行了改造：树中的节点并不存储数据本身，而是只是作为索引。每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220311092926.jpg" alt="img"></p>
<p>改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220311092929.jpg" alt="img"></p>
<p>但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。</p>
<p>比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p>
<p>我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。</p>
<p>这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。</p>
<p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。</p>
<p>我们前面讲到，比起内存读写操作，磁盘 IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？</p>
<p>我们来看下，如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？如图所示，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他结点存储在磁盘中），如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。</p>
<h2 id="为什么需要-B-树"><a href="#为什么需要-B-树" class="headerlink" title="为什么需要 B+树"></a>为什么需要 B+树</h2><p>关系型数据库中常用 B+ 树作为索引，这是为什么呢？</p>
<p>思考以下经典应用场景</p>
<ul>
<li>根据某个值查找数据，比如 <code>select * from user where id=1234</code>。</li>
<li>根据区间值来查找某些数据，比如 <code>select * from user where id &gt; 1234 and id &lt; 2345</code>。</li>
</ul>
<p>为了提高查询效率，需要使用索引。而对于索引的性能要求，主要考察<strong>执行效率和存储空间</strong>。如果让你选择一种数据结构去存储索引，你会如何考虑？</p>
<p>以一些常见数据结构为例：</p>
<ul>
<li><strong>哈希表</strong>：哈希表的查询性能很好，时间复杂度是 <code>O(1)</code>。但是，哈希表不能支持按照区间快速查找数据。所以，哈希表不能满足我们的需求。</li>
<li><strong>平衡二叉查找树</strong>：尽管平衡二叉查找树查询的性能也很高，时间复杂度是 <code>O(logn)</code>。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</li>
<li><strong>跳表</strong>：跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 <code>O(logn)</code>。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。</li>
</ul>
<p>实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 B+ 树。不过，它是通过二叉查找树演化过来的，而非跳表。B+树的应用场景</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/eec931/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/eec931/" class="post-title-link" itemprop="url">字典树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-13 22:37:27" itemprop="dateCreated datePublished" datetime="2022-03-13T22:37:27+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="什么是字典树"><a href="#什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树</h2><p>Trie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串&#x2F;字符前缀」是否存在的数据结构。</p>
<ul>
<li>根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符；</li>
<li>从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；</li>
<li>任意节点的所有子节点所包含的字符都不相同；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220313181057.jpg" alt="img"></p>
<h3 id="字典树的构造"><a href="#字典树的构造" class="headerlink" title="字典树的构造"></a>字典树的构造</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220313181243.jpg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220313181425.jpg" alt="img"></p>
<p>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。</p>
<p><strong>字典树非常耗费内存</strong>。</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<h3 id="字典树的查找"><a href="#字典树的查找" class="headerlink" title="字典树的查找"></a>字典树的查找</h3><ol>
<li>每次从根结点开始搜索；</li>
<li>获取关键词的第一个字符，根据该字符选择对应的子节点，转到该子节点继续检索；</li>
<li>在相应的子节点上，获取关键词的第二个字符，进一步选择对应的子节点进行检索；</li>
<li>以此类推，进行迭代过程；</li>
<li>在某个节点处，关键词的所有字母已被取出，则读取附在该节点上的信息，查找完成。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220313181305.jpg" alt="img"></p>
<p>每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p>
<h2 id="字典树的应用场景"><a href="#字典树的应用场景" class="headerlink" title="字典树的应用场景"></a>字典树的应用场景</h2><p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p>
<p>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</p>
<p>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</p>
<p>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</p>
<p>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p>
<p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p>
<p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p>
<p>（1）自动补全</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200305095300.png" alt="img"></p>
<p>（2）拼写检查</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200305101637.png" alt="img"></p>
<p>（3）IP 路由 (最长前缀匹配)</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200305102959.gif" alt="img"></p>
<p>图 3. 使用 Trie 树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</p>
<p>（4）T9 (九宫格) 打字预测</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200305103047.jpg" alt="img"></p>
<p>（5）单词游戏</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200305103052.png" alt="img"></p>
<p>Trie 树可通过剪枝搜索空间来高效解决 Boggle 单词游戏</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/346350/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/346350/" class="post-title-link" itemprop="url">《检索技术核心 20 讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-04 20:03:00" itemprop="dateCreated datePublished" datetime="2022-03-04T20:03:00+08:00">2022-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《检索技术核心-20-讲》笔记"><a href="#《检索技术核心-20-讲》笔记" class="headerlink" title="《检索技术核心 20 讲》笔记"></a>《检索技术核心 20 讲》笔记</h1><blockquote>
<p>伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。</p>
</blockquote>
<h2 id="线性结构检索"><a href="#线性结构检索" class="headerlink" title="线性结构检索"></a>线性结构检索</h2><p>检索的核心思想：合理组织数据，尽可能快速减少查询范围，可以提升检索效率。</p>
<p><strong><em>数组和链表的比较</em></strong></p>
<ul>
<li><strong>存储方式</strong><ul>
<li>数组用 <strong>连续</strong> 的内存空间来存储数据。</li>
<li>链表用 <strong>不连续</strong> 的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。</li>
</ul>
</li>
<li><strong>访问方式</strong><ul>
<li>数组<strong>支持随机访问</strong>。根据下标随机访问的时间复杂度为 <code>O(1)</code></li>
<li>链表<strong>不支持随机访问</strong>，只能顺序访问。</li>
</ul>
</li>
<li><strong>空间大小</strong><ul>
<li>数组空间<strong>大小固定</strong>，扩容只能采用复制数组的方式。</li>
<li>链表空间<strong>大小不固定</strong>，扩容灵活。</li>
</ul>
</li>
<li><strong>效率比较</strong><ul>
<li>数组的 <strong>查找</strong> 效率高于链表。</li>
<li>链表的 <strong>添加</strong>、<strong>删除</strong> 效率高于数组。</li>
</ul>
</li>
</ul>
<h2 id="非线性结构检索"><a href="#非线性结构检索" class="headerlink" title="非线性结构检索"></a>非线性结构检索</h2><ul>
<li>对于无序数组，只能顺序查找，其时间复杂度为 <code>O(n)</code>。</li>
<li>对于有序数组，可以应用二分查找法，其时间复杂度为 <code>O(log n)</code>。</li>
</ul>
<p>显然，二分查找法很高效，但是它有限制条件：数据有序。为了保证数据有序，添加、删除数组数据时，必须要进行数据调整，来保证其有序。</p>
<p>首先，对于数据频繁变化的应用场景，有序数组并不是最适合的解决方案。我们一般要考虑采用非连续存储的数据结构来灵活调整。同时，为了提高检索效率，我们还要采取合理的组织方式，让这些非连续存储的数据结构能够使用二分查找算法。</p>
<p>数据组织的方式有两种，一种是二叉检索树。一个平衡的二叉检索树使用二分查找的检索效率是 <code>O(log n)</code>，但如果我们不做额外的平衡控制的话，二叉检索树的检索性能最差会退化到 <code>O(n)</code>，也就和单链表一样了。所以，AVL 树和红黑树这样平衡性更强的二叉检索树，在实际工作中应用更多。</p>
<p>除了树结构以外，另一种数据组织方式是跳表。跳表也具备二分查找的能力，理想跳表的检索效率是 <code>O(log n)</code>。为了保证跳表的检索空间平衡，跳表为每个节点随机生成层级，这样的实现方式比 AVL 树和红黑树更简单。</p>
<p>无论是二叉检索树还是跳表，它们都是通过将数据进行合理组织，然后尽可能地平衡划分检索空间，使得我们能采用二分查找的思路快速地缩减查找范围，达到 <code>O(log n)</code> 的检索效率。</p>
<h2 id="哈希检索"><a href="#哈希检索" class="headerlink" title="哈希检索"></a>哈希检索</h2><p>散列表的思路是：使用 Hash 函数将 Key 转换为数组下标。</p>
<p>哈希表的本质是一个数组，它通过 Hash 函数将查询的 Key 转为数组下标，利用数组的随机访问特性，使得我们能在 O(1) 的时间代价内完成检索。</p>
<p>尽管哈希检索没有使用二分查找，但无论是设计理想的哈希函数，还是保证哈希表有足够的空闲位置，包括解决冲突的“二次探查”和“双散列”方案，本质上都是希望数据插入哈希表的时候，分布能均衡，这样检索才能更高效。从这个角度来看，其实哈希检索提高检索效率的原理，和二叉检索树需要平衡左右子树深度的原理是一样的，也就是说，高效的检索需要均匀划分检索空间。</p>
<h2 id="状态检索"><a href="#状态检索" class="headerlink" title="状态检索"></a>状态检索</h2><p>在海量数据中，快速判断一个对象是否存在。相比于有序数组、二叉检索树和哈希表这三种方案，位图和布隆过滤器其实更适合解决这类状态检索的问题。这是因为，在不要求 100% 判断正确的情况下，使用位图和布隆过滤器可以达到 <code>O(1)</code> 时间代价的检索效率，同时空间使用率也非常高效。</p>
<p>为了判断一个很大的数据范围中，某数值是否存在，可以将这个范围的数据存为数组，其数组值为布尔型（true 或 false）。由于很多语言中，布尔类型需要 1 个字节，而二进制位（bit）的值 0 或 1 也可以表示 true 或 false，并且占用空间更小，所以更加合适。而这种基于位运算的哈希结构，即为位图。</p>
<p>布隆过滤器最大的特点，就是对一个对象使用多个哈希函数。如果我们使用了 k 个哈希函数，就会得到 k 个哈希值，也就是 k 个下标，我们会把数组中对应下标位置的值都置为 1。布隆过滤器和位图最大的区别就在于，我们不再使用一位来表示一个对象，而是使用 k 位来表示一个对象。这样两个对象的 k 位都相同的概率就会大大降低，从而能够解决哈希冲突的问题了。</p>
<p>布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p>
<p>布隆过滤器过滤器适用于对误判有一定容忍度的场景。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间代价内完成查询。</p>
<p>尽管原理并不复杂，但是倒排索引是许多检索引擎的核心。比如说，数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。</p>
<h2 id="B-树检索"><a href="#B-树检索" class="headerlink" title="B+ 树检索"></a>B+ 树检索</h2><p>内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。</p>
<p>而磁盘是机械器件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取相应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10 万到 100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。</p>
<p>磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 <strong><code>512</code></strong> 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 <strong><code>4K</code></strong> 个字节。操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫作簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>假设有一个有序数组存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘中读到内存里，然后在内存中进行二分查找。如果下一步要读的元素在其他块中，则需要再将相应块从磁盘中读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。</p>
<p>由于磁盘相对于内存而言访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！</p>
<p>将索引和数据分离就是一种常见的设计思路。在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。但是，哈希表由于缺乏范围检索的能力，在一些场合也不适用。因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。</p>
<p>随着索引数据越来越大，直到无法完全加载到内存中，这是需要将索引数据也存入磁盘中。B+ 树给出了将树形索引的所有节点都存在磁盘上的高效检索方案。操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树型索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+ 树的一个关键设计，就是让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。</p>
<p>B+ 树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+ 树就能做到节点的空间利用率最大化。此外，B+ 树还将同一层的所有节点串成了有序的双向链表，这样一来，B+ 树就同时具备了良好的范围查询能力和灵活调整的能力了。</p>
<p>因此，B+ 树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，指的是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。</p>
<p>即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更<br>高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。</p>
<p>另外，这一节还有一个很重要的设计思想需要你掌握，那就是将索引和数据分离。通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在许多大规模系统中，都是使用这个设计思想来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一次实践。</p>
<p>MySQL 中的 B+ 树实现其实有两种，一种是 MyISAM 引擎，另一种是 InnoDB 引擎。它们的核心区别就在于，数据和索引是否是分离的。</p>
<p>在 MyISAM 引擎中，B+ 树的叶子节点仅存储了数据的位置指针，这是一种索引和数据分离的设计方案，叫作非聚集索引。如果要保证 MyISAM 的数据一致性，那我们需要在表级别上进行加锁处理。</p>
<p>在 InnoDB 中，B+ 树的叶子节点直接存储了具体数据，这是一种索引和数据一体的方案。叫作聚集索引。由于数据直接就存在索引的叶子节点中，因此 InnoDB 不需要给全表加锁来保证一致性，它只需要支持行级的锁就可以了。</p>
<h2 id="LSM-树检索"><a href="#LSM-树检索" class="headerlink" title="LSM 树检索"></a>LSM 树检索</h2><p>B+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。</p>
<p>操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：<strong>LSM 树</strong>（Log Structured Merge Trees）。</p>
<p>LSM 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<p>LSM 树具有以下 3 个特点：</p>
<ol>
<li>将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（Merge Trees）；</li>
<li>用批量写入代替随机写入，并且用预写日志 WAL 技术（Write AheadLog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；</li>
<li>数据采取类似日志追加写的方式写入（Log Structured）磁盘，以顺序写的方式提高写<br>入效率。</li>
</ol>
<p>LSM 树的这些特点，使得它相对于 B+ 树，在写入性能上有大幅提升。所以，许多 NoSQL 系统都使用 LSM 树作为检索引擎，而且还对 LSM 树进行了优化以提升检索性能。</p>
<h2 id="索引构建"><a href="#索引构建" class="headerlink" title="索引构建"></a>索引构建</h2><ul>
<li><strong>数据压缩</strong>：一个是尽可能地将数据加载到内存中，因为内存的检索效率大大高于磁盘。那为了将数据更多地加载到内存中，索引压缩是一个重要的研究方向。</li>
<li><strong>分支处理</strong>：另一个是将大数据集合拆成多个小数据集合来处理。这其实就是分布式系统的核心思想。</li>
</ul>
<h2 id="索引更新"><a href="#索引更新" class="headerlink" title="索引更新"></a>索引更新</h2><h3 id="Double-Buffer（双缓冲）机制"><a href="#Double-Buffer（双缓冲）机制" class="headerlink" title="Double Buffer（双缓冲）机制"></a>Double Buffer（双缓冲）机制</h3><p>就是在内存中同时保存两份一样的索引，一个是索引 A，一个是索引 B。两个索引保持一个读、一个写，并且来回切换，最终完成高性能的索引更新。</p>
<p>优点：简单高效</p>
<p>缺点：达到一定数据量级后，会带来翻倍的内存开销，甚至有些索引存储在磁盘上的情况下，更是无法使用此机制。</p>
<h3 id="全量索引和增量索引"><a href="#全量索引和增量索引" class="headerlink" title="全量索引和增量索引"></a>全量索引和增量索引</h3><p>将新接收到的数据单独建立一个可以存在内存中的倒排索引，也就是增量索引。当查询发生的时候，我们会同时查询全量索引和增量索引，将合并的结果作为总的结果输出。</p>
<p>因为增量索引相对全量索引而言会小很多，内存资源消耗在可承受范围，所以我们可以使用 Double Buffer 机制<br>对增量索引进行索引更新。这样一来，增量索引就可以做到无锁访问。而全量索引本身就是只读的，也不需要加锁。因此，整个检索过程都可以做到无锁访问，也就提高了系统的检索效率。</p>
<h3 id="如何处理增量索引空间的持续增长"><a href="#如何处理增量索引空间的持续增长" class="headerlink" title="如何处理增量索引空间的持续增长"></a>如何处理增量索引空间的持续增长</h3><h4 id="完全重建法"><a href="#完全重建法" class="headerlink" title="完全重建法"></a>完全重建法</h4><p>如果增量索引的增长速度不算很快，或者全量索引重建的代价不大，那么我们完全可以在增量索引写满内存空间之前，完全重建一次全量索引，然后将系统查询切换到新的全量索引上。</p>
<h4 id="再合并法"><a href="#再合并法" class="headerlink" title="再合并法"></a>再合并法</h4><p>直接归并全量索引和增量索引，生成一个新的全量索引，这也就避免了从头处理所有文档的重复开销。</p>
<h4 id="滚动合并法"><a href="#滚动合并法" class="headerlink" title="滚动合并法"></a>滚动合并法</h4><p>先生成多个不同层级的索引，然后逐层合并。</p>
<p>比如说，一个检索系统在磁盘中保存了全量索引、周级索引和天级索引。所谓周级索引，就<br>是根据本周的新数据生成的一份索引，那天级索引就是根据每天的新数据生成的一份索引。<br>在滚动合并法中，当内存中的增量索引增长到一定体量时，我们会用再合并法将它合并到磁<br>盘上当天的天级索引文件中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220316134834.png" alt="img"></p>
<h2 id="索引拆分"><a href="#索引拆分" class="headerlink" title="索引拆分"></a>索引拆分</h2><p>水平拆分和垂直拆分</p>
<h2 id="TOP-K-检索"><a href="#TOP-K-检索" class="headerlink" title="TOP K 检索"></a>TOP K 检索</h2><h3 id="TF-IDF-算法"><a href="#TF-IDF-算法" class="headerlink" title="TF-IDF 算法"></a>TF-IDF 算法</h3><p>TF-IDF 算法的公式是：相关性 &#x3D; TF*IDF。其中，TF 是词频（Term Frequency），IDF 是逆文档频率（Inverse Document Frequency）。</p>
<ul>
<li><strong>词频</strong>定义的就是一个词项在文档中出现的次数。换一句话说就是，如果一个词项出现了越多次，那这个词在文档中就越重要。</li>
<li><strong>文档频率</strong>（Document Frequency），指的是这个词项出现在了多少个文档中。你也可以理解为，如果一个词出现在越多的文档中，那这个词就越普遍，越没有区分度。一个极端的例子，比如“的”字，它基本上在每个文档中都会出现，所以它的区分度就非常低。</li>
<li>逆文档频率是对文档频率取倒数，它的值越大，这个词的的区分度就越大。</li>
</ul>
<h3 id="BM25-算法"><a href="#BM25-算法" class="headerlink" title="BM25 算法"></a>BM25 算法</h3><p>BM25 算法的一个重要的设计思想是，它认为词频和相关性的关系并不是线性的。也就是说，随着词频的增加，相关性的增加会越来越不明显，并且还会有一个阈值上限。当词频达到阈值以后，那相关性就不会再增长了。</p>
<p>总结来说，BM25 算法就是一个对查询词和文档的相关性进行打分的概率模型算法。BM25 算法考虑了四个因子，分别为 IDF、文档长度、文档中的词频以及查询词中的词频。并且，公式中还加入了 3 个可以人工调整大小的参数，分别是 ：k1、k2 和 b。</p>
<h3 id="机器学习打分"><a href="#机器学习打分" class="headerlink" title="机器学习打分"></a>机器学习打分</h3><p>机器学习可以更大规模地引入更多的打分因子，并且可以自动学习出各个打分因子的权重。所以，利用机器学习进行相关性打分，已经成了目前大规模检索引擎的标配。</p>
<h3 id="根据打分结果快速-TOP-K-检索"><a href="#根据打分结果快速-TOP-K-检索" class="headerlink" title="根据打分结果快速 TOP K 检索"></a>根据打分结果快速 TOP K 检索</h3><p>完成打分阶段之后，排序阶段我们要重视排序的效率。对于精准 Top K 检索，我们可以使用堆排序来代替全排序，只返回我们认为最重要的 k 个结果。这样，时间代价就是 O(n) + O(k log n) ，在数据量级非常大的情况下，它比 O(n log n) 的检索性能会高得多。</p>
<h2 id="非精准-TOP-K-检索"><a href="#非精准-TOP-K-检索" class="headerlink" title="非精准 TOP K 检索"></a>非精准 TOP K 检索</h2><p>高质量的检索结果并不一定要非常精准，我们只需要保证质量足够高的结果，被包含在最终的 Top K 个结果中就够了。这就是非精准 Top K 检索的思路。</p>
<h2 id="空间检索"><a href="#空间检索" class="headerlink" title="空间检索"></a>空间检索</h2><p>通过将二维空间在水平和垂直方向上不停二分，可以生成一维的区域编码，然后我们可以使用一维空间的检索技术对区域编码做好索引。</p>
<p>在需要动态调整查询范围的场景下，对于二进制编码的二维空间的最近邻检索问题，我们可以通过四叉树来完成。四叉树可以很好地快速划分查询空间，并通过递归的方式高效地扩大查询范围。但是满四叉树经常会造成无谓的空间浪费，为了避免这个问题，在实际应用的时候，我们会选择使用非满四叉树来存储和索引编码。对于 GeoHash 编码的二维空间最近邻检索问题，我们也能通过类似的前缀树来提高检索效率。</p>
<h2 id="最近邻检索"><a href="#最近邻检索" class="headerlink" title="最近邻检索"></a>最近邻检索</h2><p>如何计算两篇文章的相似性</p>
<p>最常见的方式就是使用向量空间模型（Vector Space Model）。所谓向量空间模型，就是将所有文档中出现过的所有关键词都提取出来。如果一共有 n 个关键词，那每个关键词就是一个维度，这就组成了一个 n 维的向量空间。</p>
<h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>LevelDB 是由 Google 开源的存储系统。</p>
<p>LevelDB 是基于 LSM 树优化而来的存储系统。LSM 树会将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并。但是，这里面存在着大量的细节问题。</p>
<h3 id="数据在内存中如何高效检索？"><a href="#数据在内存中如何高效检索？" class="headerlink" title="数据在内存中如何高效检索？"></a>数据在内存中如何高效检索？</h3><p>首先，对内存中索引的高效检索，我们可以用很多检索技术，如红黑树、跳表等，这些数据结构会比 B+ 树更高效。LevelDB 对于 LSM 树的第一个改进，就是使用跳表代替 B+ 树来实现内存中的 C0 树。</p>
<h3 id="数据是如何高效地从内存转移到磁盘的？"><a href="#数据是如何高效地从内存转移到磁盘的？" class="headerlink" title="数据是如何高效地从内存转移到磁盘的？"></a>数据是如何高效地从内存转移到磁盘的？</h3><p>LevelDB 做了读写分离的设计。它将内存中的数据分为两块，一块叫作 MemTable，它是可读可写的。另一块叫作 Immutable MemTable，它是只读的。这两块数据的数据结构完全一样，都是跳表。</p>
<p>当 MemTable 的存储数据达到上限时，我们直接将它切换为只读的 Immutable MemTable，然后重新生成一个新的 MemTable，来支持新数据的写入和查询。这时，将内存索引存储到磁盘的问题，就变成了将 Immutable MemTable 写入磁盘的问题。而且，由于 Immutable MemTable 是只读的，因此，它不需要加锁就可以高效<br>地写入磁盘中。</p>
<h3 id="数据如何合并"><a href="#数据如何合并" class="headerlink" title="数据如何合并"></a>数据如何合并</h3><p>在原始 LSM 树的设计中，内存索引写入磁盘时是直接和磁盘中的 C1 树进行归并的。但如果工程中也这么<br>实现的话，会有两个很严重的问题：</p>
<ul>
<li>合并代价很高，因为 C1 树很大，而 C0 树很小，这会导致它们在合并时产生大量的磁盘 IO；</li>
<li>合并频率会很频繁，由于 C0 树很小，很容易被写满，因此系统会频繁进行 C0 树和 C1 树的合并，这样频繁合并会带来的大量磁盘 IO，这更是系统无法承受的。</li>
</ul>
<p>LevelDB 采用了延迟合并的设计来优化。具体来说就是，先将 Immutable MemTable 顺序快速写入磁盘，直接变成一个个 SSTable（Sorted String Table）文件，之后再对这些 SSTable 文件进行合并。这样就避免了 C0 树和 C1 树昂贵的 合并代价。</p>
<p>而在管理多个 SSTable 文件的环节，LevelDB 使用分层和滚动合并的设计来组织多个 SSTable 文件，避免了 C0 树和 C1 树的合并带来的大量数据被复制的问题。</p>
<h3 id="数据如何检索"><a href="#数据如何检索" class="headerlink" title="数据如何检索"></a>数据如何检索</h3><p>先在 MemTable 中查找，如果查找不到再去 Immutable MemTable 中查找。如果 Immutable MemTable 也查询不到，才会到磁盘中去查找。</p>
<p>在磁盘中检索数据的环节，因为 SSTable 文件是有序的，所以我们通过多层二分查找的方式，就能快速定位到需要查询的 SSTable 文件。接着，在 SSTable 文件内查找元素时，LevelDB 先是使用索引与数据分离的设计，减少磁盘 IO，又使用 BloomFilter 和二分查找来完成检索加速。加速检索的过程中，LevelDB 又使用缓存技术，将会被反复读取的数据缓存在内存中，从而避免了磁盘开销。</p>
<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><p>搜索流程：</p>
<ul>
<li>先对查询内容分词，搜索引擎还会纠错和相似推荐，得到检索词</li>
<li>根据检索词在倒排索引中进行短语检索。然后，根据相关性打分，将得分高的结果保留。</li>
</ul>
<h2 id="广告系统"><a href="#广告系统" class="headerlink" title="广告系统"></a>广告系统</h2><p>广告引擎处理一个广告请求的过程，本质上就是根据用户的广告请求信息，找出标签匹配的广告设置，并将广告进行排序返回的过程。</p>
<ul>
<li>在标签检索引擎中，我们通过合理地将标签使用在树形检索 + 倒排索引 + 结果过滤这三个环节，来提高检索效率。</li>
<li>在向量检索引擎中，我们可以使用聚类 + 倒排索引 + 乘积量化的技术来加速检索。</li>
<li>在打分排序环节，增加一个非精准打分环节，这样我们就可以大幅降低使用深度学习模型带来的开销。</li>
<li>在索引构建环节，我们还可以将一些过滤条件前置，仅将当前有效的广告设置加入索引，然后通过全量索引 + 增量索引的更新方式，来保证过滤逻辑的有效。</li>
</ul>
<h2 id="推荐引擎"><a href="#推荐引擎" class="headerlink" title="推荐引擎"></a>推荐引擎</h2><p>相比于搜索引擎和广告引擎，推荐引擎具有更灵活的检索能力，也就是可以使用更灵活的检索技术，来进行文章的召回服务。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/9a2546/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/9a2546/" class="post-title-link" itemprop="url">Elasticsearch 集群和分片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 20:52:25" itemprop="dateCreated datePublished" datetime="2022-03-01T20:52:25+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-集群和分片"><a href="#Elasticsearch-集群和分片" class="headerlink" title="Elasticsearch 集群和分片"></a>Elasticsearch 集群和分片</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="空集群"><a href="#空集群" class="headerlink" title="空集群"></a>空集群</h3><p>如果我们启动了一个单独的节点，里面不包含任何的数据和索引，那我们的集群看起来就是一个包含空内容节点的集群。</p>
<p><strong>Figure 1. 包含空内容节点的集群</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0201.png" alt="包含空内容节点的集群"></p>
<p>图 1：只有一个空节点的集群</p>
<p>一个运行中的 Elasticsearch 实例称为一个<strong>节点</strong>，而<strong>集群</strong>是由一个或者多个拥有相同 <code>cluster.name</code> 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p>
<p>当一个节点被选举成为<strong>主节点</strong>时， 它将负责管理集群范围内的<strong>所有变更</strong>，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p>
<p>作为用户，我们可以将请求发送到集群中的任何节点，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p>
<h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p>Elasticsearch 的集群监控信息中包含了许多的统计数据，其中最为重要的一项就是 <em>集群健康</em> ， 它在 <code>status</code> 字段中展示为 <code>green</code> 、 <code>yellow</code> 或者 <code>red</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/health</span><br></pre></td></tr></table></figure>

<p>在一个不包含任何索引的空集群中，它将会有一个类似于如下所示的返回内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_data_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_primary_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;relocating_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;initializing_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>status</code> 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p>
<ul>
<li>**<code>green</code>**：所有的主分片和副本分片都正常运行。</li>
<li>**<code>yellow</code>**：所有的主分片都正常运行，但不是所有的副本分片都正常运行。</li>
<li>**<code>red</code>**：有主分片没能正常运行。</li>
</ul>
<h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><p>我们往 Elasticsearch 添加数据时需要用到 <em>索引</em> —— 保存相关数据的地方。索引实际上是指向一个或者多个物理分片的逻辑命名空间 。</p>
<p>一个 <em>分片</em> 是一个底层的 <em>工作单元</em> ，它仅保存了全部数据中的一部分。现在我们只需知道一个分片是一个 Lucene 的实例，以及它本身就是一个完整的搜索引擎。 我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互。</p>
<p>Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</p>
<p>一个分片可以是 <em>主</em> 分片或者 <em>副本</em> 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。</p>
<blockquote>
<p>技术上来说，一个主分片最大能够存储 <code>Integer.MAX_VALUE - 128</code> 个文档，但是实际最大值还需要参考你的使用场景：包括你使用的硬件， 文档的大小和复杂程度，索引和查询文档的方式以及你期望的响应时长。</p>
</blockquote>
<p>一个副本分片只是一个主分片的拷贝。副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
<p>在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。</p>
<p>让我们在包含一个空节点的集群内创建名为 <code>blogs</code> 的索引。 索引在默认情况下会被分配 5 个主分片， 但是为了演示目的，我们将分配 3 个主分片和一份副本（每个主分片拥有一个副本分片）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;settings&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;number_of_shards&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="string">&quot;number_of_replicas&quot;</span> : <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的集群现在是 _拥有一个索引的单节点集群_。所有 3 个主分片都被分配在 <code>Node 1</code> 。</p>
<p><strong>Figure 2. 拥有一个索引的单节点集群</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0202.png" alt="拥有一个索引的单节点集群"></p>
<p>如果我们现在查看集群健康，我们将看到如下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_data_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_primary_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;relocating_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;initializing_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;delayed_unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_pending_tasks&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_in_flight_fetch&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;task_max_waiting_in_queue_millis&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards_percent_as_number&quot;</span><span class="punctuation">:</span> <span class="number">50</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集群 status 值为 yellow</li>
<li>没有被分配到任何节点的副本数</li>
</ul>
<p>集群的健康状况为 <code>yellow</code> 则表示全部 <em>主</em> 分片都正常运行（集群可以正常服务所有请求），但是 <em>副本</em> 分片没有全部处在正常状态。 实际上，所有 3 个副本分片都是 <code>unassigned</code> —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。</p>
<p>当前我们的集群是正常运行的，但是在硬件故障时有丢失数据的风险。</p>
<h3 id="添加故障转移"><a href="#添加故障转移" class="headerlink" title="添加故障转移"></a>添加故障转移</h3><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。</p>
<blockquote>
<p>为了测试第二个节点启动后的情况，你可以在同一个目录内，完全依照启动第一个节点的方式来启动一个新节点（参考安装并运行 Elasticsearch）。多个节点可以共享同一个目录。</p>
<p>当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。 但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。</p>
</blockquote>
<p>如果启动了第二个节点，我们的集群将会拥有两个节点的集群——所有主分片和副本分片都已被分配。</p>
<p><strong>Figure 3. 拥有两个节点的集群——所有主分片和副本分片都已被分配</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0203.png" alt="拥有两个节点的集群"></p>
<p>当第二个节点加入到集群后，3 个 <em>副本分片</em> 将会分配到这个节点上——每个主分片对应一个副本分片。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p>
<p>所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。</p>
<p><code>cluster-health</code> 现在展示的状态为 <code>green</code> ，这表示所有 6 个分片（包括 3 个主分片和 3 个副本分片）都在正常运行。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_nodes&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_data_nodes&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_primary_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;relocating_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;initializing_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;delayed_unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_pending_tasks&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_in_flight_fetch&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;task_max_waiting_in_queue_millis&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards_percent_as_number&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集群 <code>status</code> 值为 <code>green</code></li>
</ul>
<p>我们的集群现在不仅仅是正常运行的，并且还处于 <em>始终可用</em> 的状态。</p>
<h3 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h3><p>怎样为我们的正在增长中的应用程序按需扩容呢？ 当启动了第三个节点，我们的集群将拥有三个节点的集群——为了分散负载而对分片进行重新分配。</p>
<p><strong>Figure 4. 拥有三个节点的集群——为了分散负载而对分片进行重新分配</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0204.png" alt="拥有三个节点的集群"></p>
<p><code>Node 1</code> 和 <code>Node 2</code> 上各有一个分片被迁移到了新的 <code>Node 3</code> 节点，现在每个节点上都拥有 2 个分片，而不是之前的 3 个。 这表示每个节点的硬件资源（CPU, RAM, I&#x2F;O）将被更少的分片所共享，每个分片的性能将会得到提升。</p>
<p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有 6 个分片（3 个主分片和 3 个副本分片）的索引可以最大扩容到 6 个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p>
<h3 id="更多的扩容"><a href="#更多的扩容" class="headerlink" title="更多的扩容"></a>更多的扩容</h3><p>但是如果我们想要扩容超过 6 个节点怎么办呢？</p>
<p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够 <em>存储</em> 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 <em>或</em> 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p>
<p>在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把副本数从默认的 <code>1</code> 增加到 <code>2</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs/_settings</span><br><span class="line">&#123;</span><br><span class="line">   &quot;number_of_replicas&quot; : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>blogs</code> 索引现在拥有 9 个分片：3 个主分片和 6 个副本分片。 这意味着我们可以将集群扩容到 9 个节点，每个节点上一个分片。相比原来 3 个节点时，集群搜索性能可以提升 <em>3</em> 倍。</p>
<p><strong>Figure 5. 将参数 <code>number_of_replicas</code> 调大到 2</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0205.png" alt="拥有2份副本分片3个节点的集群"></p>
<blockquote>
<p>当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。</p>
<p>但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去 2 个节点的情况下不丢失任何数据。</p>
</blockquote>
<h3 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h3><p>我们之前说过 Elasticsearch 可以应对节点故障，接下来让我们尝试下这个功能。 如果我们关闭第一个节点，这时集群的状态为关闭了一个节点后的集群。</p>
<p><strong>Figure 6. 关闭了一个节点后的集群</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0206.png" alt="关闭了一个节点后的集群"></p>
<p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： <code>Node 2</code> 。</p>
<p>在我们关闭 <code>Node 1</code> 的同时也失去了主分片 <code>1</code> 和 <code>2</code> ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 <code>red</code> ：不是所有主分片都在正常工作。</p>
<p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 <code>Node 2</code> 和 <code>Node 3</code> 上对应的副本分片提升为主分片， 此时集群的状态将会为 <code>yellow</code> 。 这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p>
<p>为什么我们集群状态是 <code>yellow</code> 而不是 <code>green</code> 呢？ 虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应 2 份副本分片，而此时只存在一份副本分片。 所以集群不能为 <code>green</code> 的状态，不过我们不必过于担心：如果我们同样关闭了 <code>Node 2</code> ，我们的程序 <em>依然</em> 可以保持在不丢任何数据的情况下运行，因为 <code>Node 3</code> 为每一个分片都保留着一份副本。</p>
<p>如果我们重新启动 <code>Node 1</code> ，集群可以将缺失的副本分片再次进行分配，那么集群的状态也将如 Figure 5. 将参数 <code>number_of_replicas</code> 调大到 2 所示。 如果 <code>Node 1</code> 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p>
<p>到目前为止，你应该对分片如何使得 Elasticsearch 进行水平扩容以及数据保障等知识有了一定了解。 接下来我们将讲述关于分片生命周期的更多细节。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><blockquote>
<ul>
<li>为什么搜索是 <em>近</em> 实时的？</li>
<li>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 <em>实时</em> 的?</li>
<li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</li>
<li>为什么删除文档不会立刻释放空间？</li>
<li><code>refresh</code>, <code>flush</code>, 和 <code>optimize</code> API 都做了什么, 你什么情况下应该使用他们？</li>
</ul>
</blockquote>
<h3 id="使文本可被搜索"><a href="#使文本可被搜索" class="headerlink" title="使文本可被搜索"></a>使文本可被搜索</h3><p>必须解决的第一个挑战是如何使文本可被搜索。 传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值(这里指单词)的能力。</p>
<p>最好的支持 <em>一个字段多个值</em> 需求的数据结构是我们在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html">倒排索引</a> 章节中介绍过的 <em>倒排索引</em> 。 倒排索引包含一个有序列表，列表包含所有文档出现过的不重复个体，或称为 <em>词项</em> ，对于每一个词项，包含了它所有曾出现过文档的列表。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Term  |<span class="string"> Doc 1 </span>|<span class="string"> Doc 2 </span>|<span class="string"> Doc 3 </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">------------------------------------</span></span><br><span class="line"><span class="string">brown </span>|<span class="string">   X   </span>|<span class="string">       </span>|<span class="string">  X    </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">fox   </span>|<span class="string">   X   </span>|<span class="string">   X   </span>|<span class="string">  X    </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">quick </span>|<span class="string">   X   </span>|<span class="string">   X   </span>|<span class="string">       </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">the   </span>|<span class="string">   X   </span>|<span class="string">       </span>|<span class="string">  X    </span>|<span class="string"> ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当讨论倒排索引时，我们会谈到 <em>文档</em> 标引，因为历史原因，倒排索引被用来对整个非结构化文本文档进行标引。 Elasticsearch 中的 <em>文档</em> 是有字段和值的结构化 JSON 文档。事实上，在 JSON 文档中， 每个被索引的字段都有自己的倒排索引。</p>
</blockquote>
<p>这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数， 在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息允许 Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，这些内容在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-intro.html">什么是相关性?</a> 中有描述。</p>
<p>为了能够实现预期功能，倒排索引需要知道集合中的 <em>所有</em> 文档，这是需要认识到的关键问题。</p>
<p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>倒排索引被写入磁盘后是 <em>不可改变</em> 的:它永远不会修改。 不变性有重要的价值：</p>
<ul>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像 filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I&#x2F;O 和 需要被缓存到内存的索引的使用量。</li>
</ul>
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h3 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h3><p>下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？答案是: 用更多的索引。</p>
<p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到—从最早的开始—查询完后再对结果进行合并。</p>
<p>Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件，就像在 Figure 16, “一个 Lucene 索引包含一个提交点和三个段” 中描绘的那样。 如 Figure 17, “一个在内存缓存中包含新文档的 Lucene 索引” 所示，新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，如 Figure 18, “在一次提交后，一个新的段被添加到提交点而且缓存被清空。” 所示。</p>
<p><strong>Figure 16. 一个 Lucene 索引包含一个提交点和三个段</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1101.png" alt="A Lucene index with a commit point and three segments"></p>
<blockquote>
<p>被混淆的概念是，一个 <em>Lucene 索引</em> 我们在 Elasticsearch 称作 <em>分片</em> 。 一个 Elasticsearch <em>索引</em> 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-search.html"><em>执行分布式检索</em></a> 提到的那样，合并每个分片的结果到一个全局的结果集。</p>
</blockquote>
<p>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存， 见 Figure 17, “一个在内存缓存中包含新文档的 Lucene 索引” 。</li>
<li>不时地, 缓存被 <em>提交</em> ：<ul>
<li>一个新的段—一个追加的倒排索引—被写入磁盘。</li>
<li>一个新的包含新段名字的 <em>提交点</em> 被写入磁盘。</li>
<li>磁盘进行 <em>同步</em> — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。</li>
</ul>
</li>
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<p><strong>Figure 17. 一个在内存缓存中包含新文档的 Lucene 索引</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1102.png" alt="A Lucene index with new documents in the in-memory buffer, ready to commit"></p>
<p><strong>Figure 18. 在一次提交后，一个新的段被添加到提交点而且缓存被清空。</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1103.png" alt="After a commit, a new segment is added to the index and the buffer is cleared"></p>
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。 这种方式可以用相对较低的成本将新文档添加到索引。</p>
<h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 <code>.del</code> 文件，文件中会列出这些被删除文档的段信息。</p>
<p>当一个文档被 “删除” 时，它实际上只是在 <code>.del</code> 文件中被 <em>标记</em> 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</p>
<p>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<p>在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html">段合并</a> , 我们展示了一个被删除的文档是怎样被文件系统移除的。</p>
<h3 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h3><p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。</p>
<p>磁盘在这里成为了瓶颈。提交（Commiting）一个新的段到磁盘需要一个 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fsync"><code>fsync</code></a> 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 <code>fsync</code> 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着 <code>fsync</code> 要从整个过程中被移除。</p>
<p>在 Elasticsearch 和磁盘之间是文件系统缓存。 像之前描述的一样， 在内存索引缓冲区（ <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html#img-pre-refresh">Figure 19, “在内存缓冲区中包含了新文档的 Lucene 索引”</a> ）中的文档会被写入到一个新的段中（ <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html#img-post-refresh">Figure 20, “缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交”</a> ）。 但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。</p>
<p><strong>Figure 19. 在内存缓冲区中包含了新文档的 Lucene 索引</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1104.png" alt="A Lucene index with new documents in the in-memory buffer"></p>
<p>Lucene 允许新段被写入和打开—使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<p><strong>Figure 20. 缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1105.png" alt="The buffer contents have been written to a segment, which is searchable, but is not yet commited"></p>
<h3 id="refresh-API"><a href="#refresh-API" class="headerlink" title="refresh API"></a>refresh API</h3><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 <em>refresh</em> 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是 <em>近</em> 实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
<p>这些行为可能会对新用户造成困惑: 他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 <code>refresh</code> API 执行一次手动刷新:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /_refresh</span><br><span class="line">POST /blogs/_refresh</span><br></pre></td></tr></table></figure>

<p>刷新（Refresh）所有的索引</p>
<p>只刷新（Refresh） blogs 索引</p>
<blockquote>
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候， 手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。 相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。</p>
</blockquote>
<p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 <code>refresh_interval</code> ， 降低每个索引的刷新频率：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_logs</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;refresh_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30s&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>每 30 秒刷新 <code>my_logs</code> 索引。</p>
</blockquote>
<p><code>refresh_interval</code> 可以在既存索引上进行动态更新。 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="regexp">/my_logs/</span>_settings</span><br><span class="line">&#123; <span class="string">&quot;refresh_interval&quot;</span>: -<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="regexp">/my_logs/</span>_settings</span><br><span class="line">&#123; <span class="string">&quot;refresh_interval&quot;</span>: <span class="string">&quot;1s&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关闭自动刷新。</p>
</li>
<li><p>每秒自动刷新。</p>
</li>
</ul>
<blockquote>
<p><code>refresh_interval</code> 需要一个 <em>持续时间</em> 值， 例如 <code>1s</code> （1 秒） 或 <code>2m</code> （2 分钟）。 一个绝对值 <em>1</em> 表示的是 <em>1 毫秒</em> –无疑会使你的集群陷入瘫痪。</p>
</blockquote>
<h3 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h3><p>如果没有用 <code>fsync</code> 把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证 Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。</p>
<p>在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/dynamic-indices.html">动态更新索引</a>，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
<p>即使通过每秒刷新（refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？我们也不希望丢失掉这些数据。</p>
<p>Elasticsearch 增加了一个 <em>translog</em> ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。通过 translog ，整个流程看起来是下面这样：</p>
<p>一个文档被索引之后，就会被添加到内存缓冲区，<em>并且</em> 追加到了 translog ，正如 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-pre-refresh">Figure 21, “新的文档被添加到内存缓冲区并且被追加到了事务日志”</a> 描述的一样。</p>
<p><strong>Figure 21. 新的文档被添加到内存缓冲区并且被追加到了事务日志</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1106.png" alt="New documents are added to the in-memory buffer and appended to the transaction log"></p>
<p>刷新（refresh）使分片处于 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-post-refresh">Figure 22, “刷新（refresh）完成后, 缓存被清空但是事务日志不会”</a> 描述的状态，分片每秒被刷新（refresh）一次：</p>
<ul>
<li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行 <code>fsync</code> 操作。</li>
<li>这个段被打开，使其可被搜索。</li>
<li>内存缓冲区被清空。</li>
</ul>
<p><strong>Figure 22. 刷新（refresh）完成后, 缓存被清空但是事务日志不会</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1107.png" alt="After a refresh, the buffer is cleared but the transaction log is not"></p>
<p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志（见 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-pre-flush">Figure 23, “事务日志不断积累文档”</a> ）。</p>
<p><strong>Figure 23. 事务日志不断积累文档</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1108.png" alt="The transaction log keeps accumulating documents"></p>
<ol>
<li>每隔一段时间—例如 translog 变得越来越大—索引被刷新（flush）；一个新的 translog 被创建，并且一个全量提交被执行（见 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-post-flush">Figure 24, “在刷新（flush）之后，段被全量提交，并且事务日志被清空”</a> ）：<ul>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个提交点被写入硬盘。</li>
<li>文件系统缓存通过 <code>fsync</code> 被刷新（flush）。</li>
<li>老的 translog 被删除。</li>
</ul>
</li>
</ol>
<p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候， 它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。</p>
<p>translog 也被用来提供实时 CRUD 。当你试着通过 ID 查询、更新、删除一个文档，它会在尝试从相应的段中检索之前， 首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
<p><strong>Figure 24. 在刷新（flush）之后，段被全量提交，并且事务日志被清空</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1109.png" alt="After a flush, the segments are fully commited and the transaction log is cleared"></p>
<h3 id="flush-API"><a href="#flush-API" class="headerlink" title="flush API"></a>flush API</h3><p>这个执行一个提交并且截断 translog 的行为在 Elasticsearch 被称作一次 <em>flush</em> 。 分片每 30 分钟被自动刷新（flush），或者在 translog 太大的时候也会刷新。请查看 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/index-modules-translog.html#_translog_settings"><code>translog</code> 文档</a> 来设置，它可以用来 控制这些阈值：</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/indices-flush.html"><code>flush</code> API</a> 可以被用来执行一个手工的刷新（flush）:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="regexp">/blogs/</span>_flush</span><br><span class="line">POST /_flush?wait_for_ongoing</span><br></pre></td></tr></table></figure>

<ul>
<li>刷新（flush） blogs 索引。</li>
<li>刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</li>
</ul>
<p>你很少需要自己手动执行 <code>flush</code> 操作；通常情况下，自动刷新就足够了。</p>
<p>这就是说，在重启节点或关闭索引之前执行 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#flush-api">flush</a> 有益于你的索引。当 Elasticsearch 尝试恢复或重新打开一个索引， 它需要重放 translog 中所有的操作，所以如果日志越短，恢复越快。</p>
<blockquote>
<p>translog 的目的是保证操作不会丢失。这引出了这个问题： Translog 有多安全？</p>
<p>在文件被 <code>fsync</code> 到磁盘前，被写入的文件在重启之后就会丢失。默认 translog 是每 5 秒被 <code>fsync</code> 刷新到硬盘， 或者在每次写请求完成之后执行(e.g. index, delete, update, bulk)。这个过程在主分片和复制分片都会发生。最终， 基本上，这意味着在整个请求被 <code>fsync</code> 到主分片和复制分片的 translog 之前，你的客户端不会得到一个 200 OK 响应。</p>
<p>在每次请求后都执行一个 fsync 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是 bulk 导入，它在一次请求中平摊了大量文档的开销）。</p>
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync 还是比较有益的。比如，写入的数据被缓存到内存中，再每 5 秒执行一次 <code>fsync</code> 。</p>
<p>这个行为可以通过设置 <code>durability</code> 参数为 <code>async</code> 来启用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;index.translog.durability&quot;</span>: <span class="string">&quot;async&quot;</span>,</span><br><span class="line">    <span class="string">&quot;index.translog.sync_interval&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 translog 的话，你需要 <em>保证</em> 在发生 crash 时，丢失掉 <code>sync_interval</code> 时间段的数据也无所谓。请在决定前知晓这个特性。</p>
<p>如果你不确定这个行为的后果，最好是使用默认的参数（ <code>&quot;index.translog.durability&quot;: &quot;request&quot;</code> ）来避免数据丢失。</p>
</blockquote>
<h3 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h3><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和 cpu 运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
<p>Elasticsearch 通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
<p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p>
<p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。这个流程像在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html#img-merge">Figure 25, “两个提交了的段和一个未提交的段正在被合并到一个更大的段”</a> 中提到的一样工作：</p>
<p>1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</p>
<p>2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
<p><strong>Figure 25. 两个提交了的段和一个未提交的段正在被合并到一个更大的段</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1110.png" alt="Two commited segments and one uncommited segment in the process of being merged into a bigger segment"></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html#img-post-merge">Figure 26, “一旦合并结束，老的段被删除”</a> 说明合并完成时的活动：</p>
<ul>
<li>新的段被刷新（flush）到了磁盘。 ** 写入一个包含新段且排除旧的和较小的段的新提交点。</li>
<li>新的段被打开用来搜索。</li>
<li>老的段被删除。</li>
</ul>
<p><strong>Figure 26. 一旦合并结束，老的段被删除</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1111.png" alt="一旦合并结束，老的段被删除"></p>
<p>合并大的段需要消耗大量的 I&#x2F;O 和 CPU 资源，如果任其发展会影响搜索性能。Elasticsearch 在默认情况下会对合并流程进行资源限制，所以搜索仍然 有足够的资源很好地执行。</p>
<h3 id="optimize-API"><a href="#optimize-API" class="headerlink" title="optimize API"></a>optimize API</h3><p><code>optimize</code> API 大可看做是 <em>强制合并</em> API。它会将一个分片强制合并到 <code>max_num_segments</code> 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p>
<blockquote>
<p><code>optimize</code> API <em>不应该</em> 被用在一个活跃的索引————一个正积极更新的索引。后台合并流程已经可以很好地完成工作。 optimizing 会阻碍这个进程。不要干扰它！</p>
</blockquote>
<p>在特定情况下，使用 <code>optimize</code> API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。 老的索引实质上是只读的；它们也并不太可能会发生变化。</p>
<p>在这种情况下，使用 optimize 优化老的索引，将每一个分片合并为一个单独的段就很有用了；这样既可以节省资源，也可以使搜索更加快速：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</span><br></pre></td></tr></table></figure>

<p>合并索引中的每个分片为一个单独的段</p>
<blockquote>
<p>请注意，使用 <code>optimize</code> API 触发段合并的操作不会受到任何资源上的限制。这可能会消耗掉你节点上全部的 I&#x2F;O 资源, 使其没有余裕来处理搜索请求，从而有可能使集群失去响应。 如果你想要对索引执行 <code>optimize</code>，你需要先使用分片分配（查看 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/retiring-data.html#migrate-indices">迁移旧索引</a>）把索引移到一个安全的节点，再执行。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-cluster.html">Elasticsearch 官方文档之 集群内的原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/201e43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/201e43/" class="post-title-link" itemprop="url">ElasticSearch Java API 之 High Level REST Client</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 18:55:46" itemprop="dateCreated datePublished" datetime="2022-03-01T18:55:46+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ElasticSearch-Java-API-之-High-Level-REST-Client"><a href="#ElasticSearch-Java-API-之-High-Level-REST-Client" class="headerlink" title="ElasticSearch Java API 之 High Level REST Client"></a>ElasticSearch Java API 之 High Level REST Client</h1><blockquote>
<p>Elasticsearch 官方的 High Level REST Client 在 7.1.5.0 版本废弃。所以本文中的 API 不推荐使用。</p>
</blockquote>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在 pom.xml 中引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.17.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建连接和关闭"><a href="#创建连接和关闭" class="headerlink" title="创建连接和关闭"></a>创建连接和关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">        RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9201</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>

<h2 id="索引-API"><a href="#索引-API" class="headerlink" title="索引 API"></a>索引 API</h2><h3 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX</span> <span class="operator">=</span> <span class="string">&quot;mytest&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX_ALIAS</span> <span class="operator">=</span> <span class="string">&quot;mytest_alias&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> User&#125; 的 mapping 结构（json形式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_JSON</span> <span class="operator">=</span></span><br><span class="line">  <span class="string">&quot;&#123;\n&quot;</span> + <span class="string">&quot;  \&quot;properties\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;    \&quot;_class\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;index\&quot;: false,\n&quot;</span> + <span class="string">&quot;      \&quot;doc_values\&quot;: false\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;description\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;enabled\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;name\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;\n&quot;</span> + <span class="string">&quot;  &#125;\n&quot;</span> + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient client;</span><br></pre></td></tr></table></figure>

<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">createIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(INDEX);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 settings</span></span><br><span class="line">  createIndexRequest.settings(</span><br><span class="line">  Settings.builder().put(<span class="string">&quot;index.number_of_shards&quot;</span>, <span class="number">3</span>).put(<span class="string">&quot;index.number_of_replicas&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 mapping</span></span><br><span class="line">  createIndexRequest.mapping(MAPPING_JSON, XContentType.JSON);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的别名</span></span><br><span class="line">  createIndexRequest.alias(<span class="keyword">new</span> <span class="title class_">Alias</span>(INDEX_ALIAS));</span><br><span class="line"></span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">createIndexResponse</span> <span class="operator">=</span> client.indices().create(createIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(createIndexResponse.isAcknowledged());</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除索引</span></span><br><span class="line"><span class="type">DeleteIndexRequest</span> <span class="variable">deleteIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(INDEX);</span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.indices().delete(deleteIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(deleteResponse.isAcknowledged());</span><br></pre></td></tr></table></figure>

<h3 id="判断索引是否存在"><a href="#判断索引是否存在" class="headerlink" title="判断索引是否存在"></a>判断索引是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetIndexRequest</span> <span class="variable">getIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexRequest, RequestOptions.DEFAULT));</span><br><span class="line">  <span class="type">GetIndexRequest</span> <span class="variable">getIndexAliasRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX_ALIAS);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexAliasRequest, RequestOptions.DEFAULT));</span><br></pre></td></tr></table></figure>

<h2 id="文档-API"><a href="#文档-API" class="headerlink" title="文档 API"></a>文档 API</h2><h3 id="文档测试准备"><a href="#文档测试准备" class="headerlink" title="文档测试准备"></a>文档测试准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX</span> <span class="operator">=</span> <span class="string">&quot;mytest&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX_ALIAS</span> <span class="operator">=</span> <span class="string">&quot;mytest_alias&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> User&#125; 的 mapping 结构（json形式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_JSON</span> <span class="operator">=</span></span><br><span class="line">  <span class="string">&quot;&#123;\n&quot;</span> + <span class="string">&quot;  \&quot;properties\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;    \&quot;_class\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;index\&quot;: false,\n&quot;</span> + <span class="string">&quot;      \&quot;doc_values\&quot;: false\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;description\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;enabled\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;name\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;\n&quot;</span> + <span class="string">&quot;  &#125;\n&quot;</span> + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建索引</span></span><br><span class="line">  <span class="type">CreateIndexRequest</span> <span class="variable">createIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(INDEX);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 settings</span></span><br><span class="line">  createIndexRequest.settings(</span><br><span class="line">  Settings.builder().put(<span class="string">&quot;index.number_of_shards&quot;</span>, <span class="number">3</span>).put(<span class="string">&quot;index.number_of_replicas&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 mapping</span></span><br><span class="line">  createIndexRequest.mapping(MAPPING_JSON, XContentType.JSON);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的别名</span></span><br><span class="line">  createIndexRequest.alias(<span class="keyword">new</span> <span class="title class_">Alias</span>(INDEX_ALIAS));</span><br><span class="line"></span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().create(createIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(response.isAcknowledged());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断索引是否存在</span></span><br><span class="line">  <span class="type">GetIndexRequest</span> <span class="variable">getIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX_ALIAS);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexRequest, RequestOptions.DEFAULT));</span><br><span class="line">  <span class="type">GetIndexRequest</span> <span class="variable">getIndexAliasRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX_ALIAS);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexAliasRequest, RequestOptions.DEFAULT));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 删除索引</span></span><br><span class="line">  <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(INDEX);</span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(response.isAcknowledged());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><p>RestHighLevelClient Api 使用 <code>IndexRequest</code> 来构建创建文档的请求参数。</p>
<p>【示例】创建 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">  request.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">  product.setName(<span class="string">&quot;机器人&quot;</span>);</span><br><span class="line">  product.setDescription(<span class="string">&quot;人工智能机器人&quot;</span>);</span><br><span class="line">  product.setEnabled(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSONUtil.toJsonStr(product);</span><br><span class="line">  request.source(jsonString, XContentType.JSON);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.index(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步执行</span></span><br><span class="line">client.indexAsync(request, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;IndexResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(IndexResponse indexResponse)</span> &#123;</span><br><span class="line">  System.out.println(indexResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>RestHighLevelClient Api 使用 <code>DeleteRequest</code> 来构建删除文档的请求参数。</p>
<p>【示例】删除 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DeleteRequest</span> <span class="variable">deleteRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(INDEX_ALIAS, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DeleteResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">  System.out.println(deleteResponse);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.deleteAsync(deleteRequest, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;DeleteResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(DeleteResponse deleteResponse)</span> &#123;</span><br><span class="line">  System.out.println(deleteResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>RestHighLevelClient Api 使用 <code>UpdateRequest</code> 来构建更新文档的请求参数。</p>
<p>【示例】更新 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(INDEX_ALIAS, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="type">Product</span> <span class="variable">product3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">  product3.setName(<span class="string">&quot;扫地机器人&quot;</span>);</span><br><span class="line">  product3.setDescription(<span class="string">&quot;人工智能扫地机器人&quot;</span>);</span><br><span class="line">  product3.setEnabled(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">jsonString2</span> <span class="operator">=</span> JSONUtil.toJsonStr(product3);</span><br><span class="line">  updateRequest.doc(jsonString2, XContentType.JSON);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">  System.out.println(updateResponse);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.updateAsync(updateRequest, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;UpdateResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(UpdateResponse updateResponse)</span> &#123;</span><br><span class="line">  System.out.println(updateResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h3><p>RestHighLevelClient Api 使用 <code>GetRequest</code> 来构建查看文档的请求参数。</p>
<p>【示例】查看 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetRequest</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(INDEX_ALIAS, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetResponse</span> <span class="variable">getResponse</span> <span class="operator">=</span> client.get(getRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.getAsync(getRequest, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;GetResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(GetResponse getResponse)</span> &#123;</span><br><span class="line">  System.out.println(getResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="获取匹配条件的记录总数"><a href="#获取匹配条件的记录总数" class="headerlink" title="获取匹配条件的记录总数"></a>获取匹配条件的记录总数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;获取匹配条件的记录总数&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchPhraseQuery(<span class="string">&quot;customer_gender&quot;</span>, <span class="string">&quot;MALE&quot;</span>));</span><br><span class="line">    sourceBuilder.trackTotalHits(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">CountRequest</span> <span class="variable">countRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountRequest</span>(INDEX);</span><br><span class="line">    countRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">CountResponse</span> <span class="variable">countResponse</span> <span class="operator">=</span> client.count(countRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> countResponse.getCount();</span><br><span class="line">    System.out.println(<span class="string">&quot;命中记录数：&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123;0, 1, 2, 3&#125;)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;分页查询测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pageTest</span><span class="params">(<span class="type">int</span> page)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> page * size;</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchPhraseQuery(<span class="string">&quot;customer_gender&quot;</span>, <span class="string">&quot;MALE&quot;</span>));</span><br><span class="line">    sourceBuilder.from(offset);</span><br><span class="line">    sourceBuilder.size(size);</span><br><span class="line">    sourceBuilder.trackTotalHits(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(INDEX);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">KibanaSampleDataEcommerceBean</span> <span class="variable">bean</span> <span class="operator">=</span></span><br><span class="line">            BeanUtil.mapToBean(hit.getSourceAsMap(), KibanaSampleDataEcommerceBean.class, <span class="literal">true</span>,</span><br><span class="line">                               CopyOptions.create());</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;条件查询&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchPhraseQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(INDEX);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQueryBuilder.must(QueryBuilders.matchPhraseQuery(<span class="string">&quot;customer_last_name&quot;</span>, <span class="string">&quot;Jensen&quot;</span>));</span><br><span class="line">    sourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    sourceBuilder.trackTotalHits(<span class="literal">true</span>);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">KibanaSampleDataEcommerceBean</span> <span class="variable">bean</span> <span class="operator">=</span></span><br><span class="line">            BeanUtil.mapToBean(hit.getSourceAsMap(), KibanaSampleDataEcommerceBean.class, <span class="literal">true</span>,</span><br><span class="line">                               CopyOptions.create());</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html">Java High Level REST Client</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/0fb506/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/0fb506/" class="post-title-link" itemprop="url">Elasticsearch 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-22 21:01:01" itemprop="dateCreated datePublished" datetime="2022-02-22T21:01:01+08:00">2022-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h1><p>Elasticsearch 是一个基于 Lucene 的搜索和数据分析工具，它提供了一个分布式服务。Elasticsearch 是遵从 Apache 开源条款的一款开源产品，是当前主流的企业级搜索引擎。</p>
<p>它用于全文搜索、结构化搜索、分析以及将这三者混合使用：</p>
<ul>
<li>维基百科使用 Elasticsearch 提供全文搜索并高亮关键字，以及**输入实时搜索(search-as-you-type)<strong>和</strong>搜索纠错(did-you-mean)**等搜索建议功能。</li>
<li>英国卫报使用 Elasticsearch 结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。</li>
<li>StackOverflow 结合全文搜索与地理位置查询，以及<strong>more-like-this</strong>功能来找到相关的问题和答案。</li>
<li>Github 使用 Elasticsearch 检索 1300 亿行的代码。</li>
</ul>
<h2 id="Elasticsearch-特点"><a href="#Elasticsearch-特点" class="headerlink" title="Elasticsearch 特点"></a>Elasticsearch 特点</h2><ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索；</li>
<li>分布式的实时分析搜索引擎；</li>
<li>可弹性扩展到上百台服务器规模，处理 PB 级结构化或非结构化数据；</li>
<li>开箱即用（安装即可使用），它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。只需很少的学习既可在生产环境中使用。</li>
</ul>
<h2 id="Elasticsearch-发展历史"><a href="#Elasticsearch-发展历史" class="headerlink" title="Elasticsearch 发展历史"></a>Elasticsearch 发展历史</h2><ul>
<li><p>2010 年 2 月 8 日，Elasticsearch 第一个公开版本发布。</p>
</li>
<li><p>2010 年 5 月 14 日，发布第一个具有里程碑意义的初始版本 <strong>0.7.0</strong> ，具有如下特征：</p>
</li>
<li><p>Zen Discovery 自动发现模块；</p>
<ul>
<li>支持 Groovy Client；</li>
</ul>
</li>
<li><p>简单的插件管理机制；</p>
<ul>
<li>更好地支持 icu 分词器；</li>
</ul>
</li>
<li><p>更多的管理 api。</p>
</li>
<li><p>2013 年初，GitHub 抛弃了 Solr，采取 ElasticSearch 来做其 PB 级的搜索。</p>
</li>
<li><p>2014 年 2 月 14 日，发布 <strong>1.0.0</strong> 版本，增加如下重要特性：</p>
</li>
<li><p>支持 Snapshot&#x2F;Restore API 备份恢复 API；</p>
<ul>
<li>支持聚合分析 Aggregations；</li>
</ul>
</li>
<li><p>支持 cat api；</p>
<ul>
<li>支持断路器；</li>
</ul>
</li>
<li><p>引入 Doc values。</p>
</li>
<li><p>2015 年 10 月 28 日，发布 <strong>2.0.0</strong> 版本，有如下重要特性：</p>
</li>
<li><p>增加了 Pipleline Aggregations；</p>
<ul>
<li>query&#x2F;filter 查询合并，都合并到 query 中，根据不同的上下文执行不同的查询；</li>
</ul>
</li>
<li><p>压缩存储可配置；</p>
<ul>
<li>Rivers 模块被移除；</li>
</ul>
</li>
<li><p>Multicast 组播发现被移除，成为一个插件，生产环境必须配置单播地址。</p>
</li>
<li><p>2016 年 10 月 26 日，发布 <strong>5.0.0</strong> 版本，有如下重大特性变化：</p>
</li>
<li><p>Lucene 6.x 的支持，磁盘空间少一半；索引时间少一半；查询性能提升 25%；支持 IPV6；</p>
<ul>
<li>Internal Engine 级别移除了用于避免同一文档并发更新的竞争锁，带来 15%-20% 的性能提升；</li>
</ul>
</li>
<li><p>Shrink API，它可将分片数进行收缩成它的因数，如之前你是 15 个分片，你可以收缩成 5 个或者 3 个又或者 1 个，那么我们就可以想象成这样一种场景，在写入压力非常大的收集阶段，设置足够多的索引，充分利用 shard 的并行写能力，索引写完之后收缩成更少的 shard，提高查询性能；</p>
<ul>
<li>提供了第一个 Java 原生的 REST 客户端 SDK；</li>
</ul>
</li>
<li><p>IngestNode，之前如果需要对数据进行加工，都是在索引之前进行处理，比如 logstash 可以对日志进行结构化和转换，现在直接在 es 就可以处理了；</p>
<ul>
<li>提供了 Painless 脚本，代替 Groovy 脚本；</li>
<li>移除 site plugins，就是说 head、bigdesk 都不能直接装 es 里面了，不过可以部署独立站点（反正都是静态文件）或开发 kibana 插件；</li>
<li>新增 Sliced Scroll 类型，现在 Scroll 接口可以并发来进行数据遍历了。每个 Scroll 请求，可以分成多个 Slice 请求，可以理解为切片，各 Slice 独立并行，利用 Scroll 重建或者遍历要快很多倍；</li>
<li>新增了 Profile API；</li>
<li>新增了 Rollover API；</li>
<li>新增 Reindex；</li>
<li>引入新的字段类型 Text&#x2F;Keyword 来替换 String；</li>
<li>限制索引请求大小，避免大量并发请求压垮 ES；</li>
<li>限制单个请求的 shards 数量，默认 1000 个。</li>
</ul>
</li>
<li><p>2017 年 8 月 31 日，发布 <strong>6.0.0</strong> 版本，具有如下重要特性：</p>
</li>
<li><p>稀疏性 Doc Values 的支持；</p>
<ul>
<li>Index Sorting，即索引阶段的排序；</li>
</ul>
</li>
<li><p>顺序号的支持，每个 es 的操作都有一个顺序编号（类似增量设计）；</p>
<ul>
<li>无缝滚动升级；</li>
</ul>
</li>
<li><p>从 6.0 开始不支持一个 index 里面存在多个 type；</p>
<ul>
<li>Index-template inheritance，索引版本的继承，目前索引模板是所有匹配的都会合并，这样会造成索引模板有一些冲突问题， 6.0 将会只匹配一个，索引创建时也会进行验证；</li>
<li>Load aware shard routing， 基于负载的请求路由，目前的搜索请求是全节点轮询，那么性能最慢的节点往往会造成整体的延迟增加，新的实现方式将基于队列的耗费时间自动调节队列长度，负载高的节点的队列长度将减少，让其他节点分摊更多的压力，搜索和索引都将基于这种机制；</li>
<li>已经关闭的索引将也支持 replica 的自动处理，确保数据可靠。</li>
</ul>
</li>
<li><p>2019 年 4 月 10 日，发布 <strong>7.0.0</strong> 版本，具有如下重要特性：</p>
</li>
<li><p>集群连接变化：TransportClient 被废弃，es7 的 java 代码，只能使用 restclient；对于 java 编程，建议采用 High-level-rest-client 的方式操作 ES 集群；</p>
<ul>
<li>ES 程序包默认打包 jdk：7.x 版本的程序包大小变成 300MB+，对比 6.x，包大了 200MB+，这正是 JDK 的大小；</li>
</ul>
</li>
<li><p>采用基于 Lucene 9.0；</p>
<ul>
<li>正式废除单个索引下多 Type 的支持，es6 时，官方就提到了 es7 会删除 type，并且 es6 时，已经规定每一个 index 只能有一个 type。在 es7 中，使用默认的 _doc 作为 type，官方说在 8.x 版本会彻底移除 type。api 请求方式也发送变化，如获得某索引的某 ID 的文档：GET index&#x2F;_doc&#x2F;id 其中 index 和 id 为具体的值；</li>
</ul>
</li>
<li><p>引入了真正的内存断路器，它可以更精准地检测出无法处理的请求，并防止它们使单个节点不稳定；</p>
<ul>
<li>Zen2 是 Elasticsearch 的全新集群协调层，提高了可靠性、性能和用户体验，变得更快、更安全，并更易于使用。</li>
</ul>
</li>
</ul>
<h2 id="Elasticsearch-概念"><a href="#Elasticsearch-概念" class="headerlink" title="Elasticsearch 概念"></a>Elasticsearch 概念</h2><p>下列有一些概念是 Elasticsearch 的核心。从一开始就理解这些概念将极大地帮助简化学习 Elasticsearch 的过程。</p>
<h3 id="近实时（NRT）"><a href="#近实时（NRT）" class="headerlink" title="近实时（NRT）"></a>近实时（NRT）</h3><p>Elasticsearch 是一个近乎实时的搜索平台。这意味着<strong>从索引文档到可搜索文档的时间有一点延迟</strong>（通常是一秒）。</p>
<h3 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a>索引（Index）</h3><p>索引在不同语境，有着不同的含义</p>
<ul>
<li>索引（名词）：一个 <strong>索引</strong> 类似于传统关系数据库中的一个 <strong>数据库</strong> ，是一个存储关系型文档的容器。 索引 (<em>index</em>) 的复数词为 indices 或 indexes 。索引实际上是指向一个或者多个<strong>物理分片</strong>的<strong>逻辑命名空间</strong> 。</li>
<li>索引（动词）：索引一个文档 就是存储一个文档到一个 <em>索引</em> （名词）中以便被检索和查询。这非常类似于 SQL 语句中的 <code>INSERT</code> 关键词，除了文档已存在时，新文档会替换旧文档情况之外。</li>
<li>倒排索引：关系型数据库通过增加一个索引比如一个 B 树索引到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 <strong>倒排索引</strong> 的结构来达到相同的目的。</li>
</ul>
<p>索引的 Mapping 和 Setting</p>
<ul>
<li><strong><code>Mapping</code></strong> 定义文档字段的类型</li>
<li><strong><code>Setting</code></strong> 定义不同的数据分布</li>
</ul>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> ... any settings ... <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type_one&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> ... any mappings ... <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type_two&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> ... any mappings ... <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220108215559.PNG" alt="img"></p>
<h4 id="index-template"><a href="#index-template" class="headerlink" title="index template"></a>index template</h4><p>**<code>index template</code>**（索引模板）帮助用户设定 Mapping 和 Setting，并按照一定的规则，自动匹配到新创建的索引之上。</p>
<ul>
<li>模板仅在一个索引被创建时，才会产生作用。修改模板不会影响已创建的索引。</li>
<li>你可以设定多个索引模板，这些设置会被 merge 在一起。</li>
<li>你可以指定 order 的数值，控制 merge 的过程。</li>
</ul>
<p>当新建一个索引时</p>
<ul>
<li>应用 ES 默认的 Mapping 和 Setting</li>
<li>应用 order 数值低的 index template 中的设定</li>
<li>应用 order 数值高的 index template 中的设定，之前的设定会被覆盖</li>
<li>应用创建索引是，用户所指定的 Mapping 和 Setting，并覆盖之前模板中的设定。</li>
</ul>
<p>示例：创建默认索引模板</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">PUT _template/template_default</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;index_patterns&quot;</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line">  <span class="string">&quot;order&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /_template/template_test</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;index_patterns&quot;</span>: [<span class="string">&quot;test*&quot;</span>],</span><br><span class="line">  <span class="string">&quot;order&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;date_detection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;numeric_detection&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引模板</span></span><br><span class="line">GET /_template/template_default</span><br><span class="line">GET /_template/temp*</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入新的数据，index以test开头</span></span><br><span class="line">PUT testtemplate/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;someNumber&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;someDate&quot;</span>: <span class="string">&quot;2019/01/01&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">GET testtemplate/_mapping</span><br><span class="line">GET testtemplate/_settings</span><br><span class="line"></span><br><span class="line">PUT testmy</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line">		<span class="string">&quot;number_of_replicas&quot;</span>:5</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT testmy/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET testmy/_settings</span><br><span class="line">DELETE testmy</span><br><span class="line">DELETE /_template/template_default</span><br><span class="line">DELETE /_template/template_test</span><br></pre></td></tr></table></figure>

<h4 id="dynamic-template"><a href="#dynamic-template" class="headerlink" title="dynamic template"></a>dynamic template</h4><ul>
<li>根据 ES 识别的数据类型，结合字段名称，来动态设定字段类型<ul>
<li>所有的字符串类型都设定成 Keyword，或者关闭 keyword 字段。</li>
<li>is 开头的字段都设置成 boolean</li>
<li>long_ 开头的都设置成 long 类型</li>
</ul>
</li>
<li>dynamic template 是定义在某个索引的 Mapping 中</li>
<li>template 有一个名称</li>
<li>匹配规则是一个数组</li>
<li>为匹配到字段设置 Mapping</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Dynaminc Mapping 根据类型和字段名</span></span><br><span class="line">DELETE my_index</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Ruan&quot;</span>,</span><br><span class="line">  <span class="string">&quot;isVIP&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_mapping</span><br><span class="line"></span><br><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;strings_as_boolean&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="string">&quot;match&quot;</span>: <span class="string">&quot;is*&quot;</span>,</span><br><span class="line">          <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;boolean&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;strings_as_keywords&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_mapping</span><br><span class="line"></span><br><span class="line">DELETE my_index</span><br><span class="line"><span class="comment">#结合路径</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;path_match&quot;</span>: <span class="string">&quot;name.*&quot;</span>,</span><br><span class="line">          <span class="string">&quot;path_unmatch&quot;</span>: <span class="string">&quot;*.middle&quot;</span>,</span><br><span class="line">          <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_name&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_mapping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;first&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;middle&quot;</span>: <span class="string">&quot;Winston&quot;</span>,</span><br><span class="line">    <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Lennon&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search?q=full_name:John</span><br><span class="line">DELETE my_index</span><br></pre></td></tr></table></figure>

<h3 id="类型（Type）"><a href="#类型（Type）" class="headerlink" title="类型（Type）"></a><del>类型（Type）</del></h3><p><del>type 是一个逻辑意义上的分类或者叫分区，允许在同一索引中建立多个 type。本质是相当于一个过滤条件，高版本将会废弃 type 概念。</del></p>
<blockquote>
<p><del><strong>6.0.0 版本及之后，废弃 type</strong></del></p>
</blockquote>
<h3 id="文档（Document）"><a href="#文档（Document）" class="headerlink" title="文档（Document）"></a>文档（Document）</h3><p>Elasticsearch 是面向文档的，<strong>文档是所有可搜索数据的最小单位</strong>。</p>
<p>Elasticsearch 使用 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Json"><em>JSON</em></a> 作为文档的序列化格式。</p>
<p>在索引&#x2F;类型中，可以根据需要存储任意数量的文档。</p>
<p>每个文档都有一个 <strong>Unique ID</strong></p>
<ul>
<li>用户可以自己指定</li>
<li>或通过 Elasticsearch 自动生成</li>
</ul>
<h4 id="文档的元数据"><a href="#文档的元数据" class="headerlink" title="文档的元数据"></a>文档的元数据</h4><p>一个文档不仅仅包含它的数据 ，也包含<strong>元数据</strong> —— 有关文档的信息。</p>
<ul>
<li><code>_index</code>：文档在哪存放</li>
<li><code>_type</code>：文档表示的对象类别</li>
<li><code>_id</code>：文档唯一标识</li>
<li><code>_source</code>：文档的原始 Json 数据</li>
<li><code>_all</code>：整合所有字段内容到该字段，已被废除</li>
<li><code>_version</code>：文档的版本信息</li>
<li><code>_score</code>：相关性打分</li>
</ul>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;megacorp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;employee&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;found&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;first_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Smith&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;about&quot;</span><span class="punctuation">:</span> <span class="string">&quot;I love to go rock climbing&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;interests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;sports&quot;</span><span class="punctuation">,</span> <span class="string">&quot;music&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h3><h4 id="节点简介"><a href="#节点简介" class="headerlink" title="节点简介"></a>节点简介</h4><p>一个运行中的 Elasticsearch 实例称为一个<strong>节点</strong>。</p>
<p>Elasticsearch 实例本质上是一个 Java 进程。一台机器上可以运行多个 Elasticsearch 进程，但是生产环境建议一台机器上只运行一个 Elasticsearch 进程</p>
<p>每个节点都有名字，通过配置文件配置，或启动时通过 <code>-E node.name=node1</code> 指定。</p>
<p>每个节点在启动后，会分配一个 UID，保存在 <code>data</code> 目录下。</p>
<h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><ul>
<li><strong>主节点（master node）</strong>：每个节点都保存了集群的状态，只有 master 节点才能修改集群的状态信息（保证数据一致性）。<strong>集群状态</strong>，维护了以下信息：<ul>
<li>所有的节点信息</li>
<li>所有的索引和其相关的 mapping 和 setting 信息</li>
<li>分片的路由信息</li>
</ul>
</li>
<li><strong>候选节点（master eligible node）</strong>：master eligible 节点可以参加选主流程。第一个启动的节点，会将自己选举为 mater 节点。<ul>
<li>每个节点启动后，默认为 master eligible 节点，可以通过配置 <code>node.master: false</code> 禁止</li>
</ul>
</li>
<li><strong>数据节点（data node）</strong>：负责保存分片数据。</li>
<li><strong>协调节点（coordinating node）</strong>：负责接收客户端的请求，将请求分发到合适的接地那，最终把结果汇集到一起。每个 Elasticsearch 节点默认都是协调节点（coordinating node）。</li>
<li><strong>冷&#x2F;热节点（warm&#x2F;hot node）</strong>：针对不同硬件配置的数据节点（data node），用来实现 Hot &amp; Warm 架构，降低集群部署的成本。</li>
<li><strong>机器学习节点（machine learning node）</strong>：负责执行机器学习的 Job，用来做异常检测。</li>
</ul>
<h4 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h4><table>
<thead>
<tr>
<th>配置参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>node.master</td>
<td>true</td>
<td>是否为主节点</td>
</tr>
<tr>
<td>node.data</td>
<td>true</td>
<td>是否为数据节点</td>
</tr>
<tr>
<td>node.ingest</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>node.ml</td>
<td>true</td>
<td>是否为机器学习节点（需要开启 x-pack）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>建议</strong></p>
<p>开发环境中一个节点可以承担多种角色。但是，在生产环境中，节点应该设置为单一角色。</p>
</blockquote>
<h3 id="集群（Cluster）"><a href="#集群（Cluster）" class="headerlink" title="集群（Cluster）"></a>集群（Cluster）</h3><h4 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h4><p>拥有相同 <code>cluster.name</code> 配置的 Elasticsearch 节点组成一个<strong>集群</strong>。 <code>cluster.name</code> 默认名为 <code>elasticsearch</code>，可以通过配置文件修改，或启动时通过 <code>-E cluster.name=xxx</code> 指定。</p>
<p>当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p>
<p>当一个节点被选举成为主节点时，它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量增加，它也不会成为瓶颈。 任何节点都可以成为主节点。</p>
<p>作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p>
<h4 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h4><p>Elasticsearch 的集群监控信息中包含了许多的统计数据，其中最为重要的一项就是 <em>集群健康</em> ， 它在 <code>status</code> 字段中展示为 <code>green</code> 、 <code>yellow</code> 或者 <code>red</code> 。</p>
<p>在一个不包含任何索引的空集群中，它将会有一个类似于如下所示的返回内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span> : <span class="string">&quot;green&quot;</span>,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;number_of_nodes&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;number_of_data_nodes&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;active_primary_shards&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="string">&quot;active_shards&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="string">&quot;relocating_shards&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;initializing_shards&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;unassigned_shards&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;delayed_unassigned_shards&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;number_of_pending_tasks&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;number_of_in_flight_fetch&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;task_max_waiting_in_queue_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;active_shards_percent_as_number&quot;</span> : <span class="number">100.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>status</code> 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p>
<ul>
<li>**<code>green</code>**：所有的主分片和副本分片都正常运行。</li>
<li>**<code>yellow</code>**：所有的主分片都正常运行，但不是所有的副本分片都正常运行。</li>
<li>**<code>red</code>**：有主分片没能正常运行。</li>
</ul>
<h3 id="分片（Shards）"><a href="#分片（Shards）" class="headerlink" title="分片（Shards）"></a>分片（Shards）</h3><h4 id="分片简介"><a href="#分片简介" class="headerlink" title="分片简介"></a>分片简介</h4><p>索引实际上是指向一个或者多个<strong>物理分片</strong>的<strong>逻辑命名空间</strong> 。</p>
<p>一个分片是一个底层的工作单元 ，它仅保存了全部数据中的一部分。一个分片可以视为一个 Lucene 的实例，并且它本身就是一个完整的搜索引擎。 我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互。</p>
<p>Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</p>
<h4 id="主分片和副分片"><a href="#主分片和副分片" class="headerlink" title="主分片和副分片"></a>主分片和副分片</h4><p>分片分为主分片（Primary Shard）和副分片（Replica Shard）。</p>
<p>主分片：用于解决数据水平扩展的问题。通过主分片，可以将数据分布到集群内不同节点上。</p>
<ul>
<li>索引内任意一个文档都归属于一个主分片。</li>
<li>主分片数在索引创建时指定，后序不允许修改，除非 Reindex</li>
</ul>
<p>副分片（Replica Shard）：用于解决数据高可用的问题。副分片是主分片的拷贝。副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
<ul>
<li>副分片数可以动态调整</li>
<li>增加副本数，还可以在一定程度上提高服务的可用性（读取的吞吐）</li>
</ul>
<p>对于生产环境中分片的设定，需要提前做好容量规划</p>
<p>分片数过小</p>
<ul>
<li>无法水平扩展</li>
<li>单个分片的数量太大，导致数据重新分配耗时</li>
</ul>
<p>分片数过大</p>
<ul>
<li>影响搜索结果的相关性打分，影响统计结果的准确性</li>
<li>单节点上过多的分片，会导致资源浪费，同时也会影响性能</li>
</ul>
<h3 id="副本（Replicas）"><a href="#副本（Replicas）" class="headerlink" title="副本（Replicas）"></a>副本（Replicas）</h3><p>副本主要是针对主分片（Shards）的复制，Elasticsearch 中主分片可以拥有 0 个或多个的副本。</p>
<p>副本分片的主要目的就是为了故障转移。</p>
<p>分片副本很重要，主要有两个原因：</p>
<ul>
<li>它在分片或节点发生故障时提供高可用性。因此，副本分片永远不会在与其复制的主分片相同的节点；</li>
<li>副本分片也可以接受搜索的请求，可以并行搜索，从而提高系统的吞吐量。</li>
</ul>
<blockquote>
<p>每个 Elasticsearch 分片都是 Lucene 索引。单个 Lucene 索引中可以包含最大数量的文档。截止 LUCENE-5843，限制是 2,147,483,519（&#x3D; <code>Integer.MAX_VALUE</code> - 128）文档。您可以使用_cat&#x2F;shardsAPI 监控分片大小。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/">Elasticsearch 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.knowledgedict.com/tutorial/elasticsearch-intro.html">Elasticsearch 简介</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/293175/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/293175/" class="post-title-link" itemprop="url">Elasticsearch 索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-22 21:01:01" itemprop="dateCreated datePublished" datetime="2022-02-22T21:01:01+08:00">2022-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-索引"><a href="#Elasticsearch-索引" class="headerlink" title="Elasticsearch 索引"></a>Elasticsearch 索引</h1><h2 id="索引管理操作"><a href="#索引管理操作" class="headerlink" title="索引管理操作"></a>索引管理操作</h2><p>Elasticsearch 索引管理主要包括如何进行索引的创建、索引的删除、副本的更新、索引读写权限、索引别名的配置等等内容。</p>
<h3 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h3><p>ES 索引删除操作向 ES 集群的 http 接口发送指定索引的 delete http 请求即可，可以通过 curl 命令，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE http://&#123;es_host&#125;:&#123;es_http_port&#125;/&#123;index&#125;</span><br></pre></td></tr></table></figure>

<p>如果删除成功，它会返回如下信息，具体示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE http://10.10.10.66:9200/my_index?pretty</span><br></pre></td></tr></table></figure>

<p>为了返回的信息便于读取，增加了 pretty 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;acknowledged&quot;</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引别名"><a href="#索引别名" class="headerlink" title="索引别名"></a>索引别名</h3><p>ES 的索引别名就是给一个索引或者多个索引起的另一个名字，典型的应用场景是针对索引使用的平滑切换。</p>
<p>首先，创建索引 my_index，然后将别名 my_alias 指向它，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">PUT /my_index/_alias/my_alias</span><br></pre></td></tr></table></figure>

<p>也可以通过如下形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;add&quot;</span>: &#123; <span class="string">&quot;index&quot;</span>: <span class="string">&quot;my_index&quot;</span>, <span class="string">&quot;alias&quot;</span>: <span class="string">&quot;my_alias&quot;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在一次请求中增加别名和移除别名混合使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;remove&quot;</span>: &#123; <span class="string">&quot;index&quot;</span>: <span class="string">&quot;my_index&quot;</span>, <span class="string">&quot;alias&quot;</span>: <span class="string">&quot;my_alias&quot;</span> &#125;&#125;</span><br><span class="line">    &#123; <span class="string">&quot;add&quot;</span>: &#123; <span class="string">&quot;index&quot;</span>: <span class="string">&quot;my_index_v2&quot;</span>, <span class="string">&quot;alias&quot;</span>: <span class="string">&quot;my_alias&quot;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果别名与索引是一对一的，使用别名索引文档或者查询文档是可以的，但是如果别名和索引是一对多的，使用别名会发生错误，因为 ES 不知道把文档写入哪个索引中去或者从哪个索引中读取文档。</p>
</blockquote>
<p>ES 索引别名有个典型的应用场景是平滑切换，更多细节可以查看 <a target="_blank" rel="noopener" href="https://www.knowledgedict.com/tutorial/elasticsearch-index-smooth-shift.html">Elasticsearch（ES）索引零停机（无需重启）无缝平滑切换的方法</a>。</p>
<h2 id="Settings-详解"><a href="#Settings-详解" class="headerlink" title="Settings 详解"></a>Settings 详解</h2><p>Elasticsearch 索引的配置项主要分为<strong>静态配置属性</strong>和<strong>动态配置属性</strong>，静态配置属性是索引创建后不能修改，而动态配置属性则可以随时修改。</p>
<p>ES 索引设置的 api 为 **_<code>_settings</code>_**，完整的示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;number_of_shards&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;number_of_replicas&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;refresh_interval&quot;</span>: <span class="string">&quot;60s&quot;</span>,</span><br><span class="line">      <span class="string">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;tsconvert&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;stconvert&quot;</span>,</span><br><span class="line">            <span class="string">&quot;convert_type&quot;</span>: <span class="string">&quot;t2s&quot;</span>,</span><br><span class="line">            <span class="string">&quot;delimiter&quot;</span>: <span class="string">&quot;,&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;synonym&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;synonym&quot;</span>,</span><br><span class="line">            <span class="string">&quot;synonyms_path&quot;</span>: <span class="string">&quot;analysis/synonyms.txt&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;ik_max_word_synonym&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;filter&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;synonym&quot;</span>,</span><br><span class="line">              <span class="string">&quot;tsconvert&quot;</span>,</span><br><span class="line">              <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">              <span class="string">&quot;lowercase&quot;</span>,</span><br><span class="line">              <span class="string">&quot;stop&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;tokenizer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;ik_smart_synonym&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;filter&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;synonym&quot;</span>,</span><br><span class="line">              <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">              <span class="string">&quot;lowercase&quot;</span>,</span><br><span class="line">              <span class="string">&quot;stop&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;tokenizer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">			<span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;coerce&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">				<span class="string">&quot;ignore_malformed&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;indexing&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;slowlog&quot;</span>: &#123;</span><br><span class="line">					<span class="string">&quot;threshold&quot;</span>: &#123;</span><br><span class="line">						<span class="string">&quot;index&quot;</span>: &#123;</span><br><span class="line">							<span class="string">&quot;warn&quot;</span>: <span class="string">&quot;2s&quot;</span>,</span><br><span class="line">							<span class="string">&quot;info&quot;</span>: <span class="string">&quot;1s&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;provided_name&quot;</span>: <span class="string">&quot;hospital_202101070533&quot;</span>,</span><br><span class="line">			<span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;default_field&quot;</span>: <span class="string">&quot;timestamp&quot;</span>,</span><br><span class="line">				<span class="string">&quot;parse&quot;</span>: &#123;</span><br><span class="line">					<span class="string">&quot;allow_unmapped_fields&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;requests&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;cache&quot;</span>: &#123;</span><br><span class="line">					<span class="string">&quot;enable&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;search&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;slowlog&quot;</span>: &#123;</span><br><span class="line">					<span class="string">&quot;threshold&quot;</span>: &#123;</span><br><span class="line">						<span class="string">&quot;fetch&quot;</span>: &#123;</span><br><span class="line">							<span class="string">&quot;warn&quot;</span>: <span class="string">&quot;1s&quot;</span>,</span><br><span class="line">							<span class="string">&quot;info&quot;</span>: <span class="string">&quot;200ms&quot;</span></span><br><span class="line">						&#125;,</span><br><span class="line">						<span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">							<span class="string">&quot;warn&quot;</span>: <span class="string">&quot;1s&quot;</span>,</span><br><span class="line">							<span class="string">&quot;info&quot;</span>: <span class="string">&quot;500ms&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="固定属性"><a href="#固定属性" class="headerlink" title="固定属性"></a>固定属性</h3><ul>
<li>**_<code>index.creation_date</code>_**：顾名思义索引的创建时间戳。</li>
<li>**_<code>index.uuid</code>_**：索引的 uuid 信息。</li>
<li>**_<code>index.version.created</code>_**：索引的版本号。</li>
</ul>
<h3 id="索引静态配置"><a href="#索引静态配置" class="headerlink" title="索引静态配置"></a>索引静态配置</h3><ul>
<li>**_<code>index.number_of_shards</code><em>**：索引的主分片数，默认值是 **</em><code>5</code><em>**。这个配置在索引创建后不能修改；在 es 层面，可以通过 **</em><code>es.index.max_number_of_shards</code><em>** 属性设置索引最大的分片数，默认为 **</em><code>1024</code>_**。</li>
<li>**_<code>index.codec</code><em>**：数据存储的压缩算法，默认值为 **</em><code>LZ4</code><em>**，可选择值还有 **</em><code>best_compression</code>_**，它比 LZ4 可以获得更好的压缩比（即占据较小的磁盘空间，但存储性能比 LZ4 低）。</li>
<li>**_<code>index.routing_partition_size</code>_**：路由分区数，如果设置了该参数，其路由算法为：<code>( hash(_routing) + hash(_id) % index.routing_parttion_size ) % number_of_shards</code>。如果该值不设置，则路由算法为 <code>hash(_routing) % number_of_shardings</code>，<code>_routing</code> 默认值为 <code>_id</code>。</li>
</ul>
<p>静态配置里，有重要的部分是配置分析器（config analyzers）。</p>
<ul>
<li><p><strong><code>index.analysis</code></strong></p>
<p>：分析器最外层的配置项，内部主要分为 char_filter、tokenizer、filter 和 analyzer。</p>
<ul>
<li>**_<code>char_filter</code>_**：定义新的字符过滤器件。</li>
<li>**_<code>tokenizer</code>_**：定义新的分词器。</li>
<li>**_<code>filter</code>_**：定义新的 token filter，如同义词 filter。</li>
<li>**_<code>analyzer</code>_**：配置新的分析器，一般是 char_filter、tokenizer 和一些 token filter 的组合。</li>
</ul>
</li>
</ul>
<h3 id="索引动态配置"><a href="#索引动态配置" class="headerlink" title="索引动态配置"></a>索引动态配置</h3><ul>
<li>**_<code>index.number_of_replicas</code><em>**：索引主分片的副本数，默认值是 **</em><code>1</code>_**，该值必须大于等于 0，这个配置可以随时修改。</li>
<li>**_<code>index.refresh_interval</code><em>**：执行新索引数据的刷新操作频率，该操作使对索引的最新更改对搜索可见，默认为 **</em><code>1s</code><em>**。也可以设置为 **</em><code>-1</code>_** 以禁用刷新。更详细信息参考 <a target="_blank" rel="noopener" href="https://www.knowledgedict.com/tutorial/elasticsearch-refresh_interval-settings.html">Elasticsearch 动态修改 refresh_interval 刷新间隔设置</a>。</li>
</ul>
<h2 id="Mapping-详解"><a href="#Mapping-详解" class="headerlink" title="Mapping 详解"></a>Mapping 详解</h2><p>在 Elasticsearch 中，**<code>Mapping</code>**（映射），用来定义一个文档以及其所包含的字段如何被存储和索引，可以在映射中事先定义字段的数据类型、字段的权重、分词器等属性，就如同在关系型数据库中创建数据表时会设置字段的类型。</p>
<p>Mapping 会把 json 文档映射成 Lucene 所需要的扁平格式</p>
<p>一个 Mapping 属于一个索引的 Type</p>
<ul>
<li>每个文档都属于一个 Type</li>
<li>一个 Type 有一个 Mapping 定义</li>
<li>7.0 开始，不需要在 Mapping 定义中指定 type 信息</li>
</ul>
<h3 id="映射分类"><a href="#映射分类" class="headerlink" title="映射分类"></a>映射分类</h3><p>在 Elasticsearch 中，映射可分为静态映射和动态映射。在关系型数据库中写入数据之前首先要建表，在建表语句中声明字段的属性，在 Elasticsearch 中，则不必如此，Elasticsearch 最重要的功能之一就是让你尽可能快地开始探索数据，文档写入 Elasticsearch 中，它会根据字段的类型自动识别，这种机制称为<strong>动态映射</strong>，而<strong>静态映射</strong>则是写入数据之前对字段的属性进行手工设置。</p>
<h4 id="静态映射"><a href="#静态映射" class="headerlink" title="静态映射"></a>静态映射</h4><p><strong>静态映射</strong>是在创建索引时手工指定索引映射。静态映射和 SQL 中在建表语句中指定字段属性类似。相比动态映射，通过静态映射可以添加更详细、更精准的配置信息。</p>
<p>如何定义一个 Mapping</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /books</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type_one&quot;</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        <span class="string">&quot;type_two&quot;</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><p><strong>动态映射</strong>是一种偷懒的方式，可直接创建索引并写入文档，文档中字段的类型是 Elasticsearch <strong>自动识别</strong>的，不需要在创建索引的时候设置字段的类型。在实际项目中，如果遇到的业务在导入数据之前不确定有哪些字段，也不清楚字段的类型是什么，使用动态映射非常合适。当 Elasticsearch 在文档中碰到一个以前没见过的字段时，它会利用动态映射来决定该字段的类型，并自动把该字段添加到映射中，根据字段的取值自动推测字段类型的规则见下表：</p>
<table>
<thead>
<tr>
<th align="left">JSON 格式的数据</th>
<th align="left">自动推测的字段类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null</td>
<td align="left">没有字段被添加</td>
</tr>
<tr>
<td align="left">true or false</td>
<td align="left">boolean 类型</td>
</tr>
<tr>
<td align="left">浮点类型数字</td>
<td align="left">float 类型</td>
</tr>
<tr>
<td align="left">数字</td>
<td align="left">long 类型</td>
</tr>
<tr>
<td align="left">JSON 对象</td>
<td align="left">object 类型</td>
</tr>
<tr>
<td align="left">数组</td>
<td align="left">由数组中第一个非空值决定</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">有可能是 date 类型（若开启日期检测）、double 或 long 类型、text 类型、keyword 类型</td>
</tr>
</tbody></table>
<p>下面举一个例子认识动态 mapping，在 Elasticsearch 中创建一个新的索引并查看它的 mapping，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT books</span><br><span class="line">GET books/_mapping</span><br></pre></td></tr></table></figure>

<p>此时 books 索引的 mapping 是空的，返回结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>再往 books 索引中写入一条文档，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT books/it/1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;id&quot;</span>: 1,</span><br><span class="line">	<span class="string">&quot;publish_date&quot;</span>: <span class="string">&quot;2019-11-10&quot;</span>,</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;master Elasticsearch&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档写入完成之后，再次查看 mapping，返回结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;publish_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用动态 mapping 要结合实际业务需求来综合考虑，如果将 Elasticsearch 当作主要的数据存储使用，并且希望出现未知字段时抛出异常来提醒你注意这一问题，那么开启动态 mapping 并不适用。在 mapping 中可以通过 <code>dynamic</code> 设置来控制是否自动新增字段，接受以下参数：</p>
<ul>
<li>**<code>true</code>**：默认值为 true，自动添加字段。</li>
<li>**<code>false</code>**：忽略新的字段。</li>
<li>**<code>strict</code>**：严格模式，发现新的字段抛出异常。</li>
</ul>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字符串类型</td>
<td align="left">string、text、keyword</td>
</tr>
<tr>
<td align="left">数字类型</td>
<td align="left">long、integer、short、byte、double、float、half_float、scaled_float</td>
</tr>
<tr>
<td align="left">日期类型</td>
<td align="left">date</td>
</tr>
<tr>
<td align="left">布尔类型</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">二进制类型</td>
<td align="left">binary</td>
</tr>
<tr>
<td align="left">范围类型</td>
<td align="left">range</td>
</tr>
</tbody></table>
<h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数组类型</td>
<td align="left">array</td>
</tr>
<tr>
<td align="left">对象类型</td>
<td align="left">object</td>
</tr>
<tr>
<td align="left">嵌套类型</td>
<td align="left">nested</td>
</tr>
</tbody></table>
<h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">地理类型</td>
<td align="left">geo_point</td>
</tr>
<tr>
<td align="left">地理图形类型</td>
<td align="left">geo_shape</td>
</tr>
<tr>
<td align="left">IP 类型</td>
<td align="left">ip</td>
</tr>
<tr>
<td align="left">范围类型</td>
<td align="left">completion</td>
</tr>
<tr>
<td align="left">令牌计数类型</td>
<td align="left">token_count</td>
</tr>
<tr>
<td align="left">附件类型</td>
<td align="left">attachment</td>
</tr>
<tr>
<td align="left">抽取类型</td>
<td align="left">percolator</td>
</tr>
</tbody></table>
<h3 id="Mapping-属性"><a href="#Mapping-属性" class="headerlink" title="Mapping 属性"></a>Mapping 属性</h3><p>Elasticsearch 的 mapping 中的字段属性非常多，具体如下表格：</p>
<p>| 属性名 | 描述 |<br>| :- | :- | |<br>| <strong><em><code>type</code></em></strong> | 字段类型，常用的有 text、integer 等等。 |<br>| <strong><em><code>index</code></em></strong> | 当前字段是否被作为索引。可选值为 **_<code>true</code><em>**，默认为 true。 |<br>| **</em><code>store</code><em>** | 是否存储指定字段，可选值为 **</em><code>true</code><em>** | **</em><code>false</code><em>**，设置 true 意味着需要开辟单独的存储空间为这个字段做存储，而且这个存储是独立于 **</em><code>_source</code><em>** 的存储的。 |<br>| **</em><code>norms</code><em>** | 是否使用归一化因子，可选值为 **</em><code>true</code><em>** | **</em><code>false</code><em>**，不需要对某字段进行打分排序时，可禁用它，节省空间；_type</em> 为 <em>text</em> 时，默认为 <em>true_；而 <em>type</em> 为 <em>keyword</em> 时，默认为 <em>false_。 |<br>| **</em><code>index_options</code></em>** | 索引选项控制添加到倒排索引（Inverted Index）的信息，这些信息用于搜索（Search）和高亮显示：**_<code>docs</code><em><strong>：只索引文档编号(Doc Number)；</strong></em><code>freqs</code><em><strong>：索引文档编号和词频率（term frequency）；</strong></em><code>positions</code><em><strong>：索引文档编号，词频率和词位置（序号）；</strong></em><code>offsets</code><em><strong>：索引文档编号，词频率，词偏移量（开始和结束位置）和词位置（序号）。默认情况下，被分析的字符串（analyzed string）字段使用 <em>positions_，其他字段默认使用 <em>docs_。此外，需要注意的是 <em>index_option</em> 是 elasticsearch 特有的设置属性；临近搜索和短语查询时，_index_option</em> 必须设置为 <em>offsets_，同时高亮也可使用 postings highlighter。 |<br>| **</em><code>term_vector</code></em>** | 索引选项控制词向量相关信息：</strong></em><code>no</code><em><strong>：默认值，表示不存储词向量相关信息；</strong></em><code>yes</code><em><strong>：只存储词向量信息；</strong></em><code>with_positions</code><em><strong>：存储词项和词项位置；</strong></em><code>with_offsets</code><em><strong>：存储词项和字符偏移位置；</strong></em><code>with_positions_offsets</code><em>**：存储词项、词项位置、字符偏移位置。_term_vector</em> 是 lucene 层面的索引设置。 |<br>| <strong><em><code>similarity</code></em></strong> | 指定文档相似度算法（也可以叫评分模型）：**_<code>BM25</code><em>**：ES 5 之后的默认设置。 |<br>| **</em><code>copy_to</code><em>** | 复制到自定义 _all 字段，值是数组形式，即表明可以指定多个自定义的字段。 |<br>| **</em><code>analyzer</code><em>** | 指定索引和搜索时的分析器，如果同时指定 <em>search_analyzer</em> 则搜索时会优先使用 <em>search_analyzer_。 |<br>| **</em><code>search_analyzer</code></em>** | 指定搜索时的分析器，搜索时的优先级最高。 |<br>| <strong><em><code>null_value</code></em></strong> | 用于需要对 Null 值实现搜索的场景，只有 Keyword 类型支持此配置。 |</p>
<h2 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h2><h3 id="多个-index、多个-type-查询"><a href="#多个-index、多个-type-查询" class="headerlink" title="多个 index、多个 type 查询"></a>多个 index、多个 type 查询</h3><p>Elasticsearch 的搜索 api 支持<strong>一个索引（index）的多个类型（type）查询</strong>以及<strong>多个索引（index）</strong>的查询。</p>
<p>例如，我们可以搜索 twitter 索引下面所有匹配条件的所有类型中文档，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /twitter/_search?q=user:shay</span><br></pre></td></tr></table></figure>

<p>我们也可以搜索一个索引下面指定多个 type 下匹配条件的文档，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /twitter/tweet,user/_search?q=user:banon</span><br></pre></td></tr></table></figure>

<p>我们也可以搜索多个索引下匹配条件的文档，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /twitter,elasticsearch/_search?q=tag:wow</span><br></pre></td></tr></table></figure>

<p>此外我们也可以搜索所有索引下匹配条件的文档，用_all 表示所有索引，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_all/_search?q=tag:wow</span><br></pre></td></tr></table></figure>

<p>甚至我们可以搜索所有索引及所有 type 下匹配条件的文档，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=tag:wow</span><br></pre></td></tr></table></figure>

<h3 id="URI-搜索"><a href="#URI-搜索" class="headerlink" title="URI 搜索"></a>URI 搜索</h3><p>Elasticsearch 支持用 uri 搜索，可用 get 请求里面拼接相关的参数，并用 curl 相关的命令就可以进行测试。</p>
<p>如下有一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET twitter/_search?q=user:kimchy</span><br></pre></td></tr></table></figure>

<p>如下是上一个请求的相应实体：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">62</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="number">1.3862944</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;twitter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1.3862944</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kimchy&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2009-11-15T14:12:12&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trying out Elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;likes&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>URI 中允许的参数：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">q</td>
<td align="left">查询字符串，映射到 query_string 查询</td>
</tr>
<tr>
<td align="left">df</td>
<td align="left">在查询中未定义字段前缀时使用的默认字段</td>
</tr>
<tr>
<td align="left">analyzer</td>
<td align="left">查询字符串时指定的分词器</td>
</tr>
<tr>
<td align="left">analyze_wildcard</td>
<td align="left">是否允许通配符和前缀查询，默认设置为 false</td>
</tr>
<tr>
<td align="left">batched_reduce_size</td>
<td align="left">应在协调节点上一次减少的分片结果数。如果请求中潜在的分片数量很大，则应将此值用作保护机制，以减少每个搜索请求的内存开销</td>
</tr>
<tr>
<td align="left">default_operator</td>
<td align="left">默认使用的匹配运算符，可以是<em>AND</em>或者<em>OR</em>，默认是<em>OR</em></td>
</tr>
<tr>
<td align="left">lenient</td>
<td align="left">如果设置为 true，将会忽略由于格式化引起的问题（如向数据字段提供文本），默认为 false</td>
</tr>
<tr>
<td align="left">explain</td>
<td align="left">对于每个 hit，包含了具体如何计算得分的解释</td>
</tr>
<tr>
<td align="left">_source</td>
<td align="left">请求文档内容的参数，默认 true；设置 false 的话，不返回_source 字段，可以使用<strong>_source_include</strong>和<strong>_source_exclude</strong>参数分别指定返回字段和不返回的字段</td>
</tr>
<tr>
<td align="left">stored_fields</td>
<td align="left">指定每个匹配返回的文档中的存储字段，多个用逗号分隔。不指定任何值将导致没有字段返回</td>
</tr>
<tr>
<td align="left">sort</td>
<td align="left">排序方式，可以是<em>fieldName</em>、<em>fieldName:asc</em>或者<em>fieldName:desc</em>的形式。fieldName 可以是文档中的实际字段，也可以是诸如_score 字段，其表示基于分数的排序。此外可以指定多个 sort 参数（顺序很重要）</td>
</tr>
<tr>
<td align="left">track_scores</td>
<td align="left">当排序时，若设置 true，返回每个命中文档的分数</td>
</tr>
<tr>
<td align="left">track_total_hits</td>
<td align="left">是否返回匹配条件命中的总文档数，默认为 true</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">设置搜索的超时时间，默认无超时时间</td>
</tr>
<tr>
<td align="left">terminate_after</td>
<td align="left">在达到查询终止条件之前，指定每个分片收集的最大文档数。如果设置，则在响应中多了一个 terminated_early 的布尔字段，以指示查询执行是否实际上已终止。默认为 no terminate_after</td>
</tr>
<tr>
<td align="left">from</td>
<td align="left">从第几条（索引以 0 开始）结果开始返回，默认为 0</td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">返回命中的文档数，默认为 10</td>
</tr>
<tr>
<td align="left">search_type</td>
<td align="left">搜索的方式，可以是<em>dfs_query_then_fetch</em>或<em>query_then_fetch</em>。默认为<em>query_then_fetch</em></td>
</tr>
<tr>
<td align="left">allow_partial_search_results</td>
<td align="left">是否可以返回部分结果。如设置为 false，表示如果请求产生部分结果，则设置为返回整体故障；默认为 true，表示允许请求在超时或部分失败的情况下获得部分结果</td>
</tr>
</tbody></table>
<h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><p>在 Elasticsearch 中，查询是一个比较复杂的执行模式，因为我们不知道那些 document 会被匹配到，任何一个 shard 上都有可能，所以一个 search 请求必须查询一个索引或多个索引里面的所有 shard 才能完整的查询到我们想要的结果。</p>
<p>找到所有匹配的结果是查询的第一步，来自多个 shard 上的数据集在分页返回到客户端之前会被合并到一个排序后的 list 列表，由于需要经过一步取 top N 的操作，所以 search 需要进过两个阶段才能完成，分别是 query 和 fetch。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/">Elasticsearch 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.knowledgedict.com/tutorial/elasticsearch-index-mapping.html">Elasticsearch 索引映射类型及 mapping 属性详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/blog/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">46:19</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>




  <script src="/blog/js/third-party/pace.js"></script>

  




<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"11d050d74382da19a3385d9f8027eb99"}</script>
<script src="/blog/js/third-party/comments/gitalk.js"></script>

</body>
</html>
