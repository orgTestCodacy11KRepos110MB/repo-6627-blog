<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">279</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">118</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">385</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">385</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">118</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">279</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c013cc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c013cc/" class="post-title-link" itemprop="url">SpringBoot Actuator 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-14 20:51:22" itemprop="dateCreated datePublished" datetime="2022-06-14T20:51:22+08:00">2022-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">Spring其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringBoot-Actuator-快速入门"><a href="#SpringBoot-Actuator-快速入门" class="headerlink" title="SpringBoot Actuator 快速入门"></a>SpringBoot Actuator 快速入门</h1><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.7.0/spring-boot-project/spring-boot-actuator"><code>spring-boot-actuator</code></a> 模块提供了 Spring Boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 <code>spring-boot-starter-actuator</code> 依赖。</p>
<p>如果是 Maven 项目，添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果是 Gradle 项目，添加以下声明：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="端点（Endpoint）"><a href="#端点（Endpoint）" class="headerlink" title="端点（Endpoint）"></a>端点（Endpoint）</h2><p>Actuator Endpoint 使 Spring Boot 用户可以监控应用，并和应用进行交互。Spring Boot 内置了许多 端点，并允许用户自定义端点。例如，<code>health</code> 端点提供基本的应用健康信息。</p>
<p>用户可以启用或禁用每个单独的端点并通过 HTTP 或 JMX 暴露它们（使它们可远程访问）。当端点被启用和公开时，它被认为是可用的。内置端点仅在可用时才会自动配置。大多数应用程序选择通过 HTTP 公开。例如，默认情况下，<code>health</code> 端点映射到 <code>/actuator/health</code>。</p>
<h3 id="启用端点"><a href="#启用端点" class="headerlink" title="启用端点"></a>启用端点</h3><p>默认情况下，除了 <code>shutdown</code> 之外的所有端点都已启用。要配置端点的启用，请使用 <code>management.endpoint.&lt;id&gt;.enabled</code> 属性。以下示例启用 <code>shutdown</code> 端点：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoint.shutdown.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>如果您希望端点是明确指定才启用，请将 <code>management.endpoints.enabled-by-default</code> 属性设置为 false 并根据需要明确指定启用的端点，以下为示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.enabled-by-default</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">management.endpoint.info.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="暴露端点"><a href="#暴露端点" class="headerlink" title="暴露端点"></a>暴露端点</h3><p>由于端点可能包含敏感信息，您应该仔细考虑何时暴露它们。下表显示了内置端点的默认曝光：</p>
<table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">JMX</th>
<th align="left">Web</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>auditevents</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>beans</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>caches</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>conditions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>configprops</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>env</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>flyway</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>health</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left"><code>heapdump</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>httptrace</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>info</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>integrationgraph</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>jolokia</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>logfile</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>loggers</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>liquibase</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>metrics</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>mappings</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>prometheus</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>quartz</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>scheduledtasks</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>sessions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>shutdown</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>startup</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>threaddump</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
</tbody></table>
<p>要更改暴露的端点，请使用以下特定于技术的包含和排除属性：</p>
<table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>management.endpoints.jmx.exposure.exclude</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.jmx.exposure.include</code></td>
<td align="left"><code>*</code></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.web.exposure.exclude</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.web.exposure.include</code></td>
<td align="left"><code>health</code></td>
</tr>
</tbody></table>
<p><code>include</code> 属性列出了暴露的端点的 ID。 <code>exclude</code> 属性列出了不应暴露的端点的 ID。 <code>exclude</code> 属性优先于 <code>include</code> 属性。您可以使用端点 ID 列表配置包含和排除属性。</p>
<p>例如，仅暴露 <code>health</code> 和 info 端点，其他端点都不通过 JMX 暴露，可以按如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.jmx.exposure.include</span>=<span class="string">health,info</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>*</code> 可用于选择所有端点。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>出于安全考虑，只有 <code>/health</code> 端点会通过 HTTP 方式暴露。用户可以通过 <code>management.endpoints.web.exposure.include</code> 决定哪些端点可以通过 HTTP 方式暴露。</p>
<p>如果 Spring Security 在类路径上并且不存在其他 <code>WebSecurityConfigurerAdapter</code> 或 <code>SecurityFilterChain</code> bean，则除 <code>/health</code> 之外的所有 actuator 都由 Spring Boot 自动启用安全控制。如果用户自定义了 <code>WebSecurityConfigurerAdapter</code> 或 <code>SecurityFilterChain</code> bean，Spring Boot 不再启用安全控制，由用户自行控制访问规则。</p>
<p>如果您希望为 HTTP 端点定义安全控制（例如，只允许具有特定角色的用户访问它们），Spring Boot 提供了一些方便的 <code>RequestMatcher</code> 对象，您可以将它们与 Spring Security 结合使用。</p>
<p>下面是一个典型的 Spring Security 配置示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().hasRole(<span class="string">&quot;ENDPOINT_ADMIN&quot;</span>));</span><br><span class="line">        http.httpBasic();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的示例使用 EndpointRequest.toAnyEndpoint() 将请求匹配到任何端点，然后确保所有端点都具有 ENDPOINT_ADMIN 角色。 EndpointRequest 上还提供了其他几种匹配器方法。</p>
<p>如果希望无需身份验证即可访问所有执行器端点。可以通过更改 management.endpoints.web.exposure.include 属性来做到这一点，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure>

<p>此外，如果存在 Spring Security，您将需要添加自定义安全配置，以允许未经身份验证的访问端点，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().permitAll());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Spring Boot 依赖于 Spring Security 的默认设置，因此 CSRF 保护默认开启。这意味着在使用默认安全配置时，需要 POST（关闭和记录器端点）、PUT 或 DELETE 的执行器端点会收到 403（禁止）错误。</p>
<blockquote>
<p>建议仅在创建非浏览器客户端使用的服务时完全禁用 CSRF 保护。</p>
</blockquote>
<h3 id="配置端点"><a href="#配置端点" class="headerlink" title="配置端点"></a>配置端点</h3><p>端点会自动缓存对不带任何参数的读操作的响应数据。要配置端点缓存响应的时间量，请使用其 <code>cache.time-to-live</code> 属性。以下示例将 bean 端点缓存的生存时间设置为 10 秒：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoint.beans.cache.time-to-live</span>=<span class="string">10s</span></span><br></pre></td></tr></table></figure>

<h3 id="Actuator-Web-端点的超媒体"><a href="#Actuator-Web-端点的超媒体" class="headerlink" title="Actuator Web 端点的超媒体"></a>Actuator Web 端点的超媒体</h3><p>Spring Boot Actuator 中内置了一个“发现页面”端点，其中包含了所有端点的链接。默认情况下，“发现页面”在 <code>/actuator</code> 上可用。</p>
<p>要禁用“发现页面”，请将以下属性添加到您的应用程序属性中：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.discovery.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>配置自定义管理上下文路径后，“发现页面”会自动从 <code>/actuator</code> 移动到应用管理上下文的根目录。例如，如果管理上下文路径是 <code>/management</code>，则发现页面可从 <code>/management</code> 获得。当管理上下文路径设置为 &#x2F; 时，发现页面被禁用以防止与其他映射发生冲突的可能性。</p>
<h3 id="跨域支持"><a href="#跨域支持" class="headerlink" title="跨域支持"></a>跨域支持</h3><p>CORS 是一种 W3C 规范，可让用户以灵活的方式指定授权哪种跨域请求。如果使用 Spring MVC 或 Spring WebFlux，则可以配置 Actuator 的 Web 端点以支持此类场景。</p>
<p>CORS 支持默认是禁用的，只有在设置 <code>management.endpoints.web.cors.allowed-origins</code> 属性后才会启用。以下配置允许来自 example.com 域的 GET 和 POST 调用：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.cors.allowed-origins</span>=<span class="string">https://example.com</span></span><br><span class="line"><span class="attr">management.endpoints.web.cors.allowed-methods</span>=<span class="string">GET,POST</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义端点"><a href="#自定义端点" class="headerlink" title="自定义端点"></a>自定义端点</h3><p>如果添加带有 <code>@Endpoint</code> 注释的 <code>@Bean</code>，则任何带有 <code>@ReadOperation</code>、<code>@WriteOperation</code> 或 <code>@DeleteOperation</code> 注释的方法都会自动通过 JMX 公开，并且在 Web 应用程序中，也可以通过 HTTP 公开。可以使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 公开端点。如果 Jersey 和 Spring MVC 都可用，则使用 Spring MVC。</p>
<p>以下示例公开了一个返回自定义对象的读取操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="keyword">public</span> CustomData <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomData</span>(<span class="string">&quot;test&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以使用 <code>@JmxEndpoint</code> 或 <code>@WebEndpoint</code> 编写特定技术的端点。这些端点仅限于各自的技术。例如，<code>@WebEndpoint</code> 仅通过 HTTP 而不是通过 JMX 公开。</p>
<p>您可以使用 <code>@EndpointWebExtension</code> 和 <code>@EndpointJmxExtension</code> 编写特定技术的扩展。这些注释让您可以提供特定技术的操作来扩充现有端点。</p>
<p>最后，如果您需要访问 Web 框架的功能，您可以实现 servlet 或 Spring <code>@Controller</code> 和 <code>@RestController</code> 端点，但代价是它们无法通过 JMX 或使用不同的 Web 框架获得。</p>
<h2 id="通过-HTTP-进行监控和管理"><a href="#通过-HTTP-进行监控和管理" class="headerlink" title="通过 HTTP 进行监控和管理"></a>通过 HTTP 进行监控和管理</h2><h3 id="自定义管理端点路径"><a href="#自定义管理端点路径" class="headerlink" title="自定义管理端点路径"></a>自定义管理端点路径</h3><p>如果是 Web 应用，Spring Boot Actuator 会自动将所有启用的端点通过 HTTP 方式暴露。默认约定是使用前缀为 <code>/actuator</code> 的端点的 id 作为 URL 路径。例如，健康被暴露为 <code>/actuator/health</code>。</p>
<p>有时，自定义管理端点的前缀很有用。例如，您的应用程序可能已经将 <code>/actuator</code> 用于其他目的。您可以使用 <code>management.endpoints.web.base-path</code> 属性更改管理端点的前缀，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.base-path</span>=<span class="string">/manage</span></span><br></pre></td></tr></table></figure>

<p>该示例将端点从 <code>/actuator/&#123;id&#125;</code> 更改为 <code>/manage/&#123;id&#125;</code>（例如，<code>/manage/info</code>）。</p>
<h3 id="自定义管理服务器端口"><a href="#自定义管理服务器端口" class="headerlink" title="自定义管理服务器端口"></a>自定义管理服务器端口</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-SSL"><a href="#配置-SSL" class="headerlink" title="配置 SSL"></a>配置 SSL</h3><p>当配置为使用自定义端口时，还可以使用各种 <code>management.server.ssl.*</code> 属性为管理服务器配置自己的 SSL。例如，这样做可以让管理服务器在主应用程序使用 HTTPS 时通过 HTTP 可用，如以下属性设置所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:store.jks</span></span><br><span class="line"><span class="attr">server.ssl.key-password</span>=<span class="string">secret</span></span><br><span class="line"><span class="attr">management.server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">management.server.ssl.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>或者，主服务器和管理服务器都可以使用 SSL，但使用不同的密钥存储，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:main.jks</span></span><br><span class="line"><span class="attr">server.ssl.key-password</span>=<span class="string">secret</span></span><br><span class="line"><span class="attr">management.server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">management.server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">management.server.ssl.key-store</span>=<span class="string">classpath:management.jks</span></span><br><span class="line"><span class="attr">management.server.ssl.key-password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义管理服务器地址"><a href="#自定义管理服务器地址" class="headerlink" title="自定义管理服务器地址"></a>自定义管理服务器地址</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="attr">management.server.address</span>=<span class="string">127.0.0.1</span></span><br></pre></td></tr></table></figure>

<h3 id="禁用-HTTP-端点"><a href="#禁用-HTTP-端点" class="headerlink" title="禁用 HTTP 端点"></a>禁用 HTTP 端点</h3><p>如果您不想通过 HTTP 方式暴露端点，可以将管理端口设置为 -1，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.server.port</span>=<span class="string">-1</span></span><br></pre></td></tr></table></figure>

<p>也可以通过使用 management.endpoints.web.exposure.exclude 属性来实现这一点，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.exposure.exclude</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure>

<h2 id="通过-JMX-进行监控和管理"><a href="#通过-JMX-进行监控和管理" class="headerlink" title="通过 JMX 进行监控和管理"></a>通过 JMX 进行监控和管理</h2><p>Java 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用。您可以通过将 <code>spring.jmx.enabled</code> 配置属性设置为 true 来打开它。 Spring Boot 将最合适的 <code>MBeanServer</code> 暴露为 ID 为 <code>mbeanServer</code> 的 bean。使用 Spring JMX 注释（<code>@ManagedResource</code>、<code>@ManagedAttribute</code> 或 <code>@ManagedOperation</code>）注释的任何 bean 都会暴露给它。</p>
<p>如果您的平台提供标准 <code>MBeanServer</code>，则 Spring Boot 会使用该标准并在必要时默认使用 VM <code>MBeanServer</code>。如果一切都失败了，则创建一个新的 <code>MBeanServer</code>。</p>
<p>有关更多详细信息，请参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.7.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a> 类。</p>
<p>默认情况下，Spring Boot 还将管理端点公开为 <code>org.springframework.boot</code> 域下的 JMX MBean。要完全控制 JMX 域中的端点注册，请考虑注册您自己的 <code>EndpointObjectNameFactory</code> 实现。</p>
<h3 id="定制化-MBean-Names"><a href="#定制化-MBean-Names" class="headerlink" title="定制化 MBean Names"></a>定制化 MBean Names</h3><p>MBean 的名称通常由端点的 id 生成。例如，健康端点公开为 <code>org.springframework.boot:type=Endpoint,name=Health</code>。</p>
<p>如果您的应用程序包含多个 Spring <code>ApplicationContext</code>，您可能会发现名称冲突。要解决此问题，您可以将 <code>spring.jmx.unique-names</code> 属性设置为 true，以便 MBean 名称始终是唯一的。</p>
<p>如果需要定制，跨域按如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.jmx.unique-names</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">management.endpoints.jmx.domain</span>=<span class="string">com.example.myapp</span></span><br></pre></td></tr></table></figure>

<h3 id="禁用-JMX-端点"><a href="#禁用-JMX-端点" class="headerlink" title="禁用 JMX 端点"></a>禁用 JMX 端点</h3><p>想禁用 JMX 端点，可以按如下配置：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management<span class="selector-class">.endpoints</span><span class="selector-class">.jmx</span><span class="selector-class">.exposure</span>.exclude=*</span><br></pre></td></tr></table></figure>

<h3 id="将-Jolokia-用于基于-HTTP-的-JMX"><a href="#将-Jolokia-用于基于-HTTP-的-JMX" class="headerlink" title="将 Jolokia 用于基于 HTTP 的 JMX"></a>将 Jolokia 用于基于 HTTP 的 JMX</h3><p>Jolokia 是一个 JMX-HTTP 的桥接工具，它提供了另一种访问 JMX bean 的方法。要使用 Jolokia，需要先添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure>

<p>然后，您可以通过将 <code>jolokia</code> 或 <code>*</code> 添加到 <code>Management.Endpoints.web.exposure.include</code> 属性来暴露 Jolokia 端点。然后，您可以在管理 HTTP 服务器上使用 <code>/actuator/jolokia</code> 访问它。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Spring Boot Actuator 支持查看和配置应用日志级别。</p>
<p>日志级别的可选值如下：</p>
<ul>
<li><code>TRACE</code></li>
<li><code>DEBUG</code></li>
<li><code>INFO</code></li>
<li><code>WARN</code></li>
<li><code>ERROR</code></li>
<li><code>FATAL</code></li>
<li><code>OFF</code></li>
<li><code>null</code></li>
</ul>
<p><code>null</code> 表示没有显式配置。</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>Spring Boot Actuator 支持简单的审计功能。如果应用中启用了 Spring Security，Spring Boot Actuator 就会发布安全事件（如：“身份验证成功”、“失败”和“访问被拒绝”异常）。</p>
<p>可以通过在应用的配置中提供 <code>AuditEventRepository</code> 类型的 bean 来启用审计。为方便起见，Spring Boot 提供了一个 <code>InMemoryAuditEventRepository</code>。 <code>InMemoryAuditEventRepository</code> 的功能有限，建议仅将其用于开发环境。</p>
<p>如果要自定义安全事件，可以提供 <code>AbstractAuthenticationAuditListener</code> 和 <code>AbstractAuthorizationAuditListener</code> 实现。</p>
<p>此外，还可以将审计服务用于业务活动。为此，要么将 <code>AuditEventRepository</code> bean 注入组件并直接使用它，要么使用 Spring <code>ApplicationEventPublisher</code> 发布 <code>AuditApplicationEvent</code>（通过实现 <code>ApplicationEventPublisherAware</code>）。</p>
<h2 id="HTTP-追踪"><a href="#HTTP-追踪" class="headerlink" title="HTTP 追踪"></a>HTTP 追踪</h2><p>用户可以通过在应用中提供 <code>HttpTraceRepository</code> 类型的 bean 来启用 HTTP 跟踪。Spring Boot 提供了内置的 <code>InMemoryHttpTraceRepository</code>，它可以存储最近 100 次（默认）请求-响应的追踪数据。与其他 HTTP 追踪解决方案相比，<code>InMemoryHttpTraceRepository</code> 比较受限，建议仅用于开发环境。对于生产环境，建议使用 Zipkin 或 Spring Cloud Sleuth。</p>
<p>或者，可以自定义 <code>HttpTraceRepository</code>。</p>
<h2 id="处理监控"><a href="#处理监控" class="headerlink" title="处理监控"></a>处理监控</h2><p>在 spring-boot 模块中，您可以找到两个类来创建对进程监控有用的文件：</p>
<ul>
<li><code>ApplicationPidFileWriter</code> 创建一个包含应用程序 PID 的文件（默认情况下，在应用程序目录中，文件名为 <code>application.pid</code>）。</li>
<li><code>WebServerPortFileWriter</code> 创建一个文件（或多个文件），其中包含正在运行的 Web 服务器的端口（默认情况下，在应用程序目录中，文件名为 <code>application.port</code>）。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator">Spring Boot 官方文档之 Production-ready Features</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/03714e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/03714e/" class="post-title-link" itemprop="url">分布式分区</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-14 08:49:21" itemprop="dateCreated datePublished" datetime="2022-06-14T08:49:21+08:00">2022-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式协同综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式分区"><a href="#分布式分区" class="headerlink" title="分布式分区"></a>分布式分区</h1><blockquote>
<p>在不同系统中，分区有着不同的称呼，例如它对应于 MongoDB, Elasticsearch 和 SolrCloud 中的 shard, HBase 的 region, Bigtable 中的<br>tablet, Cassandra 和 Riak 中的 vnode ，以及 Couch base 中的 vBucket。总体而言，分区是最普遍的术语。</p>
<p>分区通常是这样定义的，即每一条数据（或者每条记录，每行或每个文档）只属于某个特定分区。实际上，每个分区都可以视为一个完整的小型数据库，虽然数据库可能存在一些跨分区的操作。</p>
</blockquote>
<p><strong>采用数据分区的主要目的是提高可扩展性</strong>。不同的分区可以放在一个无共享集群的不同节点上，这样一个大数据集可以分散在更多的磁盘上，查询负载也随之分布到更多的处理器上。</p>
<p>对单个分区进行查询时，每个节点对自己所在分区可以独立执行查询操作，因此添加更多的节点可以提高查询吞吐量。超大而复杂的查询尽管比较困难，但也可能做到跨节点的并行处理。</p>
<h2 id="数据分区与数据复制"><a href="#数据分区与数据复制" class="headerlink" title="数据分区与数据复制"></a>数据分区与数据复制</h2><p>分区通常与复制结合使用，即每个分区在多个节点都存有副本。这意味着某条记录属于特定的分区，而同样的内容会保存在不同的节点上以提高系统的容错性。</p>
<p>一个节点上可能存储了多个分区。每个分区都有自己的主副本，例如被分配给某节点，而从副本则分配在其他一些节点。一个节点可能既是某些分区的主副本，同时又是其他分区的从副本。</p>
<h2 id="键－值数据的分区"><a href="#键－值数据的分区" class="headerlink" title="键－值数据的分区"></a>键－值数据的分区</h2><p>分区的主要目标是将数据和查询负载均匀分布在所有节点上。如果节点平均分担负载，那么理论上 10 个节点应该能够处理 10 倍的数据量和 10 倍于单个节点的读写吞吐量（忽略复制） 。</p>
<p>而如果分区不均匀，则会出现某些分区节点比其他分区承担更多的数据量或查询负载，称之为倾斜。倾斜会导致分区效率严重下降，在极端情况下，所有的负载可能会集中在一个分区节点上，这就意味着 10 个节点 9 个空闲，系统的瓶颈在最繁忙的那个节点上。这种负载严重不成比例的分区即成为系统热点。</p>
<h3 id="基于关键字区间分区"><a href="#基于关键字区间分区" class="headerlink" title="基于关键字区间分区"></a>基于关键字区间分区</h3><p>一种分区方式是为每个分区分配一段连续的关键字或者关键宇区间范围（以最小值和最大值来指示）。</p>
<p>关键字的区间段不一定非要均匀分布，这主要是因为数据本身可能就不均匀。</p>
<p>每个分区内可以按照关键字排序保存（参阅第 3 章的“ SSTables 和 LSM Trees ”）。这样可以轻松支持区间查询，即将关键字作为一个拼接起来的索引项从而一次查询得到多个相关记录。</p>
<p>然而，基于关键字的区间分区的缺点是某些访问模式会导致热点。如果关键字是时间戳，则分区对应于一个时间范围，所有的写入操作都集中在同一个分区（即当天的分区），这会导致该分区在写入时负载过高，而其他分区始终处于空闲状态。为了避免上述问题，需要使用时间戳以外的其他内容作为关键字的第一项。</p>
<h3 id="基于关键字晗希值分区"><a href="#基于关键字晗希值分区" class="headerlink" title="基于关键字晗希值分区"></a>基于关键字晗希值分区</h3><p>一且找到合适的关键宇 H 合希函数，就可以为每个分区分配一个哈希范围（而不是直接作用于关键宇范围），关键字根据其哈希值的范围划分到不同的分区中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303105925.png" alt="img"></p>
<p>这种方总可以很好地将关键字均匀地分配到多个分区中。分区边界可以是均匀间隔，也可以是伪随机选择（ 在这种情况下，该技术有时被称为一致性哈希） 。</p>
<p>然而，通过关键宇 II 合希进行分区，我们丧失了良好的区间查询特性。即使关键字相邻，但经过哈希之后会分散在不同的分区中，区间查询就失去了原有的有序相邻的特性。</p>
<h3 id="负载倾斜与热点"><a href="#负载倾斜与热点" class="headerlink" title="负载倾斜与热点"></a>负载倾斜与热点</h3><p>基于哈希的分区方能可以减轻热点，但无住做到完全避免。一个极端情况是，所有的读／写操作都是针对同一个关键字，则最终所有请求都将被路由到同一个分区。</p>
<p>一个简单的技术就是在关键字的开头或结尾处添加一个随机数。只需一个两位数的十进制随机数就可以将关键字的写操作分布到 100 个不同的关键字上，从而分配到不同的分区上。但是，随之而来的问题是，之后的任何读取都需要些额外的工作，必须从所有 100 个关键字中读取数据然后进行合井。因此通常只对少量的热点关键字附加随机数才有意义。</p>
<h2 id="分区与二级索引"><a href="#分区与二级索引" class="headerlink" title="分区与二级索引"></a>分区与二级索引</h2><p>二级索引通常不能唯一标识一条记录，而是用来加速特定值的查询。</p>
<p>二级索引带来的主要挑战是它们不能规整的地映射到分区中。有两种主要的方法来支持对二级索引进行分区：基于文档的分区和基于词条的分区。</p>
<h3 id="基于文档分区的二级索引"><a href="#基于文档分区的二级索引" class="headerlink" title="基于文档分区的二级索引"></a>基于文档分区的二级索引</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303111528.png" alt="img"></p>
<p>在这种索引方法中，每个分区完全独立，各自维护自己的二级索引，且只负责自己分区内的文档而不关心其他分区中数据。每当需要写数据库时，包括添加，删除或更新文档等，只需要处理包含目标文档 ID 的那一个分区。因此文档分区索引也被称为本地索引，而不是全局索引。</p>
<p>这种查询分区数据库的方陆有时也称为分散／聚集，显然这种二级索引的查询代价高昂。即使采用了并行查询，也容易导致读延迟显著放大。尽管如此，它还是广泛用于实践： MongoDB 、Riak、Cassandra、Elasticsearch 、SolrCloud 和 VoltDB 都支持基于文档分区二级索引。</p>
<h3 id="基于词条的二级索引分区"><a href="#基于词条的二级索引分区" class="headerlink" title="基于词条的二级索引分区"></a>基于词条的二级索引分区</h3><p>可以对所有的数据构建全局索引，而不是每个分区维护自己的本地索引。</p>
<p>为避免成为瓶颈，不能将全局索引存储在一个节点上，否则就破坏了设计分区均衡的目标。所以，全局索引也必须进行分区，且可以与数据关键字采用不同的分区策略。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303112708.png" alt="img"></p>
<p>可以直接通过关键词来全局划分索引，或者对其取哈希值。直接分区的好处是可以支持高效的区间查询；而采用哈希的方式则可以更均句的划分分区。</p>
<p>这种全局的词条分区相比于文档分区索引的主要优点是，它的读取更为高效，即它不需要采用 scatter&#x2F;gather 对所有的分区都执行一遍查询。</p>
<p>然而全局索引的不利之处在于， 写入速度较慢且非常复杂，主要因为单个文档的更新时，里面可能会涉及多个二级索引，而二级索引的分区又可能完全不同甚至在不同的节点上，由此势必引人显著的写放大。</p>
<p>理想情况下，索引应该时刻保持最新，即写入的数据要立即反映在最新的索引上。但是，对于词条分区来讲，这需要一个跨多个相关分区的分布式事务支持，写入速度会受到极大的影响，所以现有的数据库都不支持同步更新二级索引。</p>
<h2 id="分区再均衡"><a href="#分区再均衡" class="headerlink" title="分区再均衡"></a>分区再均衡</h2><p>随着时间的推移，数据库可能总会出现某些变化：</p>
<ul>
<li>查询压力增加，因此需要更多的 C PU 来处理负载。</li>
<li>数据规模增加，因此需要更多的磁盘和内存来存储数据。</li>
<li>节点可能出现故障，因此需要其他机器来接管失效的节点。</li>
</ul>
<p>所有这些变化都要求数据和请求可以从一个节点转移到另一个节点。这样一个迁移负载的过程称为再平衡（或者动态平衡）。无论对于哪种分区方案， 分区再平衡通常至少要满足：</p>
<ul>
<li>平衡之后，负载、数据存储、读写请求等应该在集群范围更均匀地分布。</li>
<li>再平衡执行过程中，数据库应该可以继续正常提供读写服务。</li>
<li>避免不必要的负载迁移，以加快动态再平衡，井尽量减少网络和磁盘 I&#x2F;O 影响。</li>
</ul>
<h3 id="动态再平衡的策略"><a href="#动态再平衡的策略" class="headerlink" title="动态再平衡的策略"></a>动态再平衡的策略</h3><h4 id="为什么不用取模？"><a href="#为什么不用取模？" class="headerlink" title="为什么不用取模？"></a>为什么不用取模？</h4><p>最好将哈希值划分为不同的区间范围，然后将每个区间分配给一个分区。</p>
<p>为什么不直接使用 mod，对节点数取模方怯的问题是，如果节点数 N 发生了变化，会导致很多关键字需要从现有的节点迁移到另一个节点。</p>
<h4 id="固定数量的分区"><a href="#固定数量的分区" class="headerlink" title="固定数量的分区"></a>固定数量的分区</h4><p>创建远超实际节点数的分区数，然后为每个节点分配多个分区。</p>
<p>接下来， 如果集群中添加了一个新节点，该新节点可以从每个现有的节点上匀走几个分区，直到分区再次达到全局平衡。</p>
<h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>对于采用关键宇区间分区的数据库，如果边界设置有问题，最终可能会出现所有数据都挤在一个分区而其他分区基本为空，那么设定固定边界、固定数量的分区将非常不便：而手动去重新配置分区边界又非常繁琐。</p>
<p>因此， 一些数据库如 HBas e 和 RethinkDB 等采用了动态创建分区。当分区的数据增长超过一个可配的参数阔值（ HBase 上默认值是 lOGB ），它就拆分为两个分区，每个承担一半的数据量［26］。相反，如果大量数据被删除，并且分区缩小到某个阑值以下，则将其与相邻分区进行合井。</p>
<p>每个分区总是分配给一个节点，而每个节点可以承载多个分区，这点与固定数量的分区一样。当一个大的分区发生分裂之后，可以将其中的一半转移到其他某节点以平衡负载。</p>
<p>但是，需要注意的是，对于一个空的数据库， 因为没有任何先验知识可以帮助确定分区的边界，所以会从一个分区开始。可能数据集很小，但直到达到第一个分裂点之前，所有的写入操作都必须由单个节点来处理， 而其他节点则处于空闲状态。</p>
<h4 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h4><p>采用动态分区策略，拆分和合并操作使每个分区的大小维持在设定的最小值和最大值之间，因此分区的数量与数据集的大小成正比关系。另一方面，对于固定数量的分区方式，其每个分区的大小也与数据集的大小成正比。两种情况，分区的数量都与节点数无关。</p>
<p>Cassandra 和 Ketama 则采用了第三种方式，使分区数与集群节点数成正比关系。换句话说，每个节点具有固定数量的分区。此时， 当节点数不变时，每个分区的大小与数据集大小保持正比的增长关系； 当节点数增加时，分区则会调整变得更小。较大的数据量通常需要大量的节点来存储，因此这种方陆也使每个分区大小保持稳定。当一个</p>
<p>新节点加入集群时，它随机选择固定数量的现有分区进行分裂，然后拿走这些分区的一半数据量，将另一半数据留在原节点。随机选择分区边界的前提要求采用基于哈希分区（可以从哈希函数产生的数字范围里设置边界）</p>
<h3 id="自动与手动再平衡操作"><a href="#自动与手动再平衡操作" class="headerlink" title="自动与手动再平衡操作"></a>自动与手动再平衡操作</h3><p>全自动式再平衡会更加方便，它在正常维护之外所增加的操作很少。但是，也有可能出现结果难以预测的情况。再平衡总体讲是个比较昂贵的操作，它需要重新路由请求井将大量数据从一个节点迁移到另一个节点。万一执行过程中间出现异常，会使网络或节点的负载过重，井影响其他请求的性能。</p>
<p>将自动平衡与自动故障检测相结合也可能存在一些风险。例如，假设某个节点负载过重，对请求的响应暂时受到影响，而其他节点可能会得到结论：该节点已经失效；接下来激活自动平衡来转移其负载。客观上这会加重该节点、其他节点以及网络的负荷，可能会使总体情况变得更槽，甚至导致级联式的失效扩散。</p>
<h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><p>处理策略</p>
<ol>
<li>允许客户端链接任意的节点（例如，采用循环式的负载均衡器）。如果某节点恰好拥有所请求的分区，贝 lj 直接处理该请求：否则，将请求转发到下一个合适的节点，接收答复，并将答复返回给客户端。</li>
<li>将所有客户端的请求都发送到一个路由层，由后者负责将请求转发到对应的分区节点上。路由层本身不处理任何请求，它仅充一个分区感知的负载均衡器。</li>
<li>客户端感知分区和节点分配关系。此时，客户端可以直接连接到目标节点，而不需要任何中介。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220304120137.png" alt="img"></p>
<p>许多分布式数据系统依靠独立的协调服务（如 ZooKeeper ）跟踪集群范围内的元数据。每个节点都向 ZooKeeper 中注册自己， ZooKeeper 维护了分区到节点的最终映射关系。其他参与者（如路由层或分区感知的客户端）可以向 ZooKeeper 订阅此信息。一旦分区发生了改变，或者添加、删除节点， ZooKeeper 就会主动通知路由层，这样使路由信息保持最新状态。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220304163629.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/">《数据密集型应用系统设计》</a> - 这可能是目前最好的分布式存储书籍，强力推荐【进阶】</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/47f7bd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/47f7bd/" class="post-title-link" itemprop="url">分布式复制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-11 10:40:10" itemprop="dateCreated datePublished" datetime="2022-06-11T10:40:10+08:00">2022-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式协同综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式复制"><a href="#分布式复制" class="headerlink" title="分布式复制"></a>分布式复制</h1><p>分布式复制是指：在多个节点上保存相同数据的副本，每个副本具体的存储位置可能不尽相同。复制方住可以提供冗余：如果某些节点发生不可用，则可以通过其他节点继续提供数据访问服务。复制也可以帮助提高系统性能。</p>
<h2 id="分布式复制简介"><a href="#分布式复制简介" class="headerlink" title="分布式复制简介"></a>分布式复制简介</h2><p>数据复制的作用</p>
<ul>
<li>使数据在地理位置上更接近用户，从而<strong>降低访问延迟</strong>。</li>
<li>当部分组件出现位障，系统依然可以继续工作，从而<strong>提高可用性</strong>。</li>
<li>扩展至多台机器以同时提供数据访问服务，从而<strong>提高读吞吐量</strong>。</li>
</ul>
<p>分布式系统的复制方式有以下几种：</p>
<ul>
<li><strong>主从复制</strong></li>
<li><strong>多主节点复制</strong></li>
<li><strong>无主节点复制</strong></li>
</ul>
<p>分布式系统的复制需要考虑以下问题：</p>
<ul>
<li><strong>同步还是异步</strong></li>
<li><strong>如何处理失败的副本</strong></li>
<li><strong>如何保证数据一致</strong></li>
</ul>
<h2 id="主节点与从节点"><a href="#主节点与从节点" class="headerlink" title="主节点与从节点"></a>主节点与从节点</h2><p>每个保存数据库完整数据集的节点称之为副本。有了多副本，必然会面临一个问题：如何确保所有副本之间的数据是一致的？</p>
<p>主从复制的工作原理如下：</p>
<ol>
<li>指定某一个副本为主副本（或称为主节点） 。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。</li>
<li>其他副本则全部称为从副本（或称为从节点）。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。</li>
<li>客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。再次强调，只有主副本才可以接受写请求：从客户端的角度来看，从副本都是只读的。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220302202101.png" alt="img"></p>
<p>典型应用：</p>
<ul>
<li>数据库：MySql、MongoDB 等</li>
<li>消息队列：Kafka、RabbitMQ 等</li>
</ul>
<h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><p>对于关系数据库系统，同步或异步通常是一个可配置的选项：而其他系统则可能是硬性指定或者只能二选一。同步复制与异步复制基本流程是，客户将更新请求发送给主节点，主节点接收到请求，接下来将数据更新转发给从节点。最后，由主节点来通知客户更新完成。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220302202158.png" alt="img"></p>
<p>通常情况下， 复制速度会非常快，例如多数数据库系统可以在一秒之内完成所有从节点的更新。但是，系统其实并没有保证一定会在多段时间内完成复制。有些情况下，从节点可能落后主节点几分钟甚至更长时间，例如，由于从节点刚从故障中恢复，或者系统已经接近最大设计上限，或者节点之间的网络出现问题。</p>
<ul>
<li><strong>同步复制的优点</strong>： 一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。</li>
<li><strong>同步复制的缺点</strong>：如果同步的从节点无法完成确认（例如由于从节点发生崩愤，或者网络故障，或任何其他原因）， 写入就不能视为成功。主节点会阻塞其后所有的写操作，直到同步副本确认完成。</li>
</ul>
<p>因此，把所有从节点都配置为同步复制有些不切实际。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。实际应用中，很多数据库推荐的模式是：只要有一个从节点或半数以上的从节点同步成功，就视为同步，直接返回结果；剩下的节点都通过异步方式同步。万一同步的从节点变得不可用或性能下降， 则将另一个异步的从节点提升为同步模式。这样可以保证至少有两个节点（即主节点和一个同步从节点）拥有最新的数据副本。这种配置有时也称为半同步 。</p>
<p>主从复制还经常会被配置为全异步模式。此时如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。这意味着即使向客户端确认了写操作， 却无法保证数据的持久化。但全异步配置的优点则是，不管从节点上数据多么滞后， 主节点总是可以继续响应写请求，系统的吞吐性能更好。</p>
<ul>
<li><strong>异步复制的优点</strong>：不管从节点上数据多么滞后，主节点总是可以继续响应写请求，系统的吞吐性能更好。</li>
<li><strong>异步复制的缺点</strong>：如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。</li>
</ul>
<h3 id="配置新的从节点"><a href="#配置新的从节点" class="headerlink" title="配置新的从节点"></a>配置新的从节点</h3><p>当如果出现以下情况时，如需要增加副本数以提高容错能力，或者替换失败的副本，就需要考虑增加新的从节点。但如何确保新的从节点和主节点保持数据一致呢？</p>
<p>简单地将数据文件从一个节点复制到另一个节点通常是不够的。主要是因为客户端仍在不断向数据库写入新数据，数据始终处于不断变化之中，因此常规的文件拷贝方式将会导致不同节点上呈现出不同时间点的数据。</p>
<p>另一种思路是：考虑锁定数据库（使其不可写）来使磁盘上的文件保持一致，但这会违反高可用的设计目标。</p>
<p>在不停机、数据服务不中断的前提下，也有一种可行性复制方案，其主要操作步骤如下：</p>
<ol>
<li>在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。目前大多数数据库都支持此功能，快照也是系统备份所必需的。而在某些情况下，可能需要第三方工具， 如 MySQL 的 innobackupex。</li>
<li>将此快照拷贝到新的从节点。</li>
<li>从节点连接到主节点并请求快照点之后所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定位置相关联，这个位置信息在不同的系统有不同的称呼，如 PostgreSQL 将其称为“ log sequence number” （日志序列号），而 MySQL 将其称为“ binlog coordinates ” 。</li>
<li>获得日志之后，从节点来应用这些快照点之后所有数据变更，这个过程称之为追赶。接下来，它可以继续处理主节点上新的数据变化。井重复步骤 1 ～步骤 4 。</li>
</ol>
<p>建立新的从副本具体操作步骤可能因数据库系统而异。</p>
<h3 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h3><p>系统中的任何节点都可能因故障或者计划内的维护（例如重启节点以安装内核安全补丁）而导致中断甚至停机。如果能够在不停机的情况下重启某个节点，这会对运维带来巨大的便利。我们的目标是，尽管个别节点会出现中断，但要保持系统总体的持续运行，并尽可能减小节点中断带来的影响。</p>
<p>如何通过主从复制技术来实现系统高可用呢？</p>
<h4 id="从节点失效：-追赶式恢复"><a href="#从节点失效：-追赶式恢复" class="headerlink" title="从节点失效： 追赶式恢复"></a>从节点失效： 追赶式恢复</h4><p>从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点发生崩溃，然后顺利重启，或者主从节点之间的网络发生暂时中断（闪断），则恢复比较容易，根据副本的复制日志，从节点可以知道在发生故障之前所处理的最后一笔事务，然后连接到主节点，并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后，将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。</p>
<h4 id="主节点失效：节点切换"><a href="#主节点失效：节点切换" class="headerlink" title="主节点失效：节点切换"></a>主节点失效：节点切换</h4><p>选择某个从节点将其提升为主节点；客户端也需要更新，这样之后的写请求会发送给新的主节点，然后其他从节点要接受来自新的主节点上的变更数据，这一过程称之为切换。</p>
<p>故障切换可以手动进行，例如通知管理员主节点发生失效，采取必要的步骤来创建新的主节点；或者以自动方式进行。自动切换的步骤通常如下：</p>
<ol>
<li><strong>确认主节点失效</strong>。有很多种出错可能性，很难准确检测出问题的原因，所以大多数系统都采用了基于超时的机制：节点间频繁地互相发生发送心跳悄息，如果发现某一个节点在一段比较长时间内（例如 30s ）没有响应，即认为该节点发生失效。</li>
<li><strong>选举新的主节点</strong>。可以通过选举的方式（超过多数的节点达成共识）来选举新的主节点，或者由之前选定的某控制节点来指定新的主节点。候选节点最好与原主节点的数据差异最小，这样可以最小化数据丢失的风险。让所有节点同意新的主节点是个典型的共识问题。</li>
<li><strong>重新配置系统使新主节点生效</strong>。客户端现在需要将写请求发送给新的主节点。如果原主节点之后重新上线，可能仍然自认为是主节点，而没有意识到其他节点已经达成共识迫使其下台。这时系统要确保原主节点降级为从节点，并认可新的主节点。</li>
</ol>
<p>上述切换过程依然充满了很多变数：</p>
<ul>
<li>如果使用了异步复制，且失效之前，新的主节点并未收到原主节点的所有数据；在选举之后，原主节点很快又重新上线并加入到集群，接下来的写操作会发生什么？新的主节点很可能会收到冲突的写请求，这是因为原主节点未意识的角色变化，还会尝试同步其他从节点，但其中的一个现在已经接管成为现任主节点。常见的解决方案是，原主节点上未完成复制的写请求就此丢弃，但这可能会违背数据更新持久化的承诺。</li>
<li>如果在数据库之外有其他系统依赖于数据库的内容并在一起协同使用，丢弃数据的方案就特别危险。例如，在 GitHub 的一个事故中，某个数据并非完全同步的 MySQL 从节点被提升为主副本，数据库使用了自增计数器将主键分配给新创建的行，但是因为新的主节点计数器落后于原主节点（ 即二者并非完全同步），它重新使用了已被原主节点分配出去的某些主键，而恰好这些主键已被外部 Redis 所引用，结果出现 MySQL 和 Redis 之间的不一致，最后导致了某些私有数据被错误地泄露给了其他用户。</li>
<li>在某些故障情况下，可能会发生两个节点同时－都自认为是主节点。这种情况被称为<strong>脑裂</strong>，它非常危险：两个主节点都可能接受写请求，并且没有很好解决冲突的办法，最后数据可能会丢失或者破坏。作为一种安全应急方案，有些系统会采取措施来强制关闭其中一个节点。然而，如果设计或者实现考虑不周，可能会出现两个节点都被关闭的情况。</li>
<li>如何设置合适的超时来检测主节点失效呢？ 主节点失效后，超时时间设置得越长也意味着总体恢复时间就越长。但如果超时设置太短，可能会导致很多不必要的切换。例如，突发的负载峰值会导致节点的响应时间变长甚至超肘，或者由于网络故障导致延迟增加。如果系统此时已经处于高负载压力或网络已经出现严重拥塞，不必要的切换操作只会使总体情况变得更糟。</li>
</ul>
<h3 id="复制日志的实现"><a href="#复制日志的实现" class="headerlink" title="复制日志的实现"></a>复制日志的实现</h3><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><p>最简单的情况，主节点记录所执行的每个写请求（操作语句）井将该操作语句作为日志发送给从节点。对于关系数据库，这意味着每个 INSERT 、UPDATE 或 DELETE 语句都会转发给从节点，并且每个从节点都会分析井执行这些 SQU 吾句，如同它们是来自客户端那样。</p>
<p>听起来很合理也不复杂，但这种复制方式有一些不适用的场景：</p>
<ul>
<li>任何调用非确定性函数的语句，如 <code>NOW()</code> 获取当前时间，或 <code>RAND()</code> 获取一个随机数等，可能会在不同的副本上产生不同的值。</li>
<li>如果语句中使用了自增列，或者依赖于数据库的现有数据（例如， <code>UPDATE ... WHERE &lt;某些条件&gt;</code>），则所有副本必须按照完全相同的顺序执行，否则可能会带来不同的结果。进而，如果有多个同时并发执行的事务时， 会有很大的限制。</li>
<li>有副作用的语句（例如，触发器、存储过程、用户定义的函数等），可能会在每个副本上产生不同的副作用。</li>
</ul>
<p>有可能采取一些特殊措施来解决这些问题，例如，主节点可以在记录操作语句时将非确定性函数替换为执行之后的确定的结果，这样所有节点直接使用相同的结果值。但是，这里面存在太多边界条件需要考虑，因此目前通常首选的是其他复制实现方案。</p>
<p>MySQL 5.1 版本之前采用基于操作语句的复制。现在由于逻辑紧凑，依然在用，但是默认情况下，如果语句中存在一些不确定性操作，则 MySQL 会切换到基于行的复制（稍后讨论）。VoltDB 使用基于语句的复制，它通过事务级别的确定性来保证复制的安全。</p>
<h4 id="基于预写日志（WAL）传输"><a href="#基于预写日志（WAL）传输" class="headerlink" title="基于预写日志（WAL）传输"></a>基于预写日志（WAL）传输</h4><p>通常每个写操作都是以追加写的方式写入到日志中：</p>
<ul>
<li>对于日志结构存储引擎，日志是主要的存储方式。日志段在后台压缩井支持垃圾回收。</li>
<li>对于采用覆写磁盘的 BTree 结构，每次修改会预先写入日志，如系统发生崩溃，通过索引更新的方式迅速恢复到此前一致状态。</li>
</ul>
<p>不管哪种情况，所有对数据库写入的字节序列都被记入日志。因此可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外， 主节点还可以通过网络将其发送给从节点。</p>
<p>PostgreSQL 、Oracle 以及其他系统等支持这种复制方式。其主要缺点是日志描述的数据结果非常底层： 一个 WAL 包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密耦合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无能支持主从节点上运行不同版本的软件。</p>
<p>看起来这似乎只是个有关实现方面的小细节，但可能对运营产生巨大的影响。如果复制协议允许从节点的软件版本比主节点更新，则可以实现数据库软件的不停机升级：首先升级从节点，然后执行主节点切换，使升级后的从节点成为新的主节点。相反，复制协议如果要求版本必须严格一致（例如 WALf 专输），那么就势必以停机为代价。</p>
<h4 id="基于行的逻辑日志复制"><a href="#基于行的逻辑日志复制" class="headerlink" title="基于行的逻辑日志复制"></a>基于行的逻辑日志复制</h4><p>另一种方能是复制和存储引擎采用不同的日志格式，这样复制与存储逻辑剥离。这种复制日志称为逻辑日志，以区分物理存储引擎的数据表示。</p>
<p>关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：</p>
<ul>
<li>对于行插入，日志包含所有相关列的新值。</li>
<li>对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。</li>
<li>对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少包含所有已更新列的新值）。</li>
</ul>
<p>如果一条事务涉及多行的修改，则会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已经提交。MySQL 的二进制日志 binlog （当配置为基于行的复制时）使用该方式。</p>
<p>由于逻辑日志与存储引擎逻辑解耦，因此可以更容易地保持向后兼容，从而使主从节点能够运行不同版本的软件甚至是不同的存储引擎。</p>
<p>对于外部应用程序来说，逻辑日志格式也更容易解析。</p>
<h4 id="基于触发器的复制"><a href="#基于触发器的复制" class="headerlink" title="基于触发器的复制"></a>基于触发器的复制</h4><p>在某些情况下，我们可能需要更高的灵活性。例如，只想复制数据的一部分，或者想从一种数据库复制到另一种数据库，或者需要订制、管理冲突解决逻辑（ 参阅本章后面的“处理写冲突”），则需要将复制控制交给应用程序层。</p>
<p>有一些工具，可以通过读取数据库日志让应用程序获取数据变更。另一种方法则是借助许多关系数据库都支持的功能：触发器和存储过程。</p>
<p>触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，例如将数据更改复制到另一个系统。Oracle 的 Databus 和 Postgres 的 Bucardo 就是这种技术的典型代表。基于触发器的复制通常比其他复制方式开销更高， 也比数据库内置复制更容易出错，或者暴露一些限制。然而，其高度灵活性仍有用武之地。</p>
<h2 id="复制滞后问题"><a href="#复制滞后问题" class="headerlink" title="复制滞后问题"></a>复制滞后问题</h2><p>主从复制要求所有写请求都经由主节点，而任何副本只能接受只读查询。对于读操作密集的负载（如 Web ），这是一个不错的选择：创建多个从副本，将读请求分发给这些从副本，从而减轻主节点负载井允许读取请求就近满足。</p>
<p>在这种扩展体系下，只需添加更多的从副本，就可以提高读请求的服务吞吐量。但是，这种方法实际上只能用于异步复制，如果试图同步复制所有的从副本，则单个节点故障或网络中断将使整个系统无法写入。而且节点越多，发生故障的概率越高，所以完全同步的配置现实中反而非常不可靠。</p>
<p>不幸的是，如果一个应用正好从一个异步的从节点读取数据，而该副本落后于主节点，则应用可能会读到过期的信息。这会导致数据库中出现明显的不一致：由于并非所有的写入都反映在从副本上，如果同时对主节点和从节点发起相同的查询，可能会得到不同的结果。经过一段时间之后，从节点最终会赶上并与主节点数据保持一致。这种效应也被称为<strong>最终一致性</strong>。</p>
<h4 id="读自己的写"><a href="#读自己的写" class="headerlink" title="读自己的写"></a>读自己的写</h4><p>许多应用让用户提交一些数据，接下来查看他们自己所提交的内容。例如客户数据库中的记录，亦或者是讨论主题的评论等。提交新数据须发送到主节点，但是当用户读取数据时，数据可能来自从节点。这对于读密集和偶尔写入的负载是个非常合适的方案。</p>
<p>然而对于异步复制存在这样一个问题，如图所示，用户在写入不久即查看数据，则新数据可能尚未到达从节点。对用户来讲， 看起来似乎是刚刚提交的数据丢失了，显然用户不会高兴。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220302204836.png" alt="img"></p>
<p>对于这种情况，我们需要读写一致性。该机制保证如果用户重新加载页面， 他们总能看到自己最近提交的更新。但对其他用户则没有任何保证，这些用户的更新可能会在稍后才能刷新看到。如何实现呢？有以下几种可行性方案：</p>
<ul>
<li><strong>如果用户访问可能会被修改的内容，从主节点读取； 否则，在从节点读取</strong>。这背后就要求有一些方法在实际执行查询之前，就已经知道内容是否可能会被修改。例如，社交网络上的用户首页信息通常只能由所有者编辑，而其他人无法编辑。因此，这就形成一个简单的规则： 总是从主节点读取用户自己的首页配置文件，而在从节点读取其他用户的配置文件。</li>
<li><strong>如果应用的大部分内容都可能被所有用户修改</strong>，那么上述方法将不太有效，它会导致大部分内容都必须经由主节点，这就丧失了读操作的扩展性。此时需要其他方案来判断是否从主节点读取。例如，跟踪最近更新的时间，如果更新后一分钟之内，则总是在主节点读取；井监控从节点的复制滞后程度，避免从那些滞后时间超过一分钟的从节点读取。</li>
<li>客户端还可以记住最近更新时的时间戳，井附带在读请求中，据此信息，系统可以确保对该用户提供读服务时都应该至少包含了该时间戳的更新。如果不够新，要么交由另一个副本来处理，要么等待直到副本接收到了最近的更新。时间戳可以是逻辑时间戳（例如用来指示写入顺序的日志序列号）或实际系统时钟（在这种情况下，时钟同步又称为一个关键点）。</li>
<li>如果副本分布在多数据中心（例如考虑与用户的地理接近，以及高可用性），情况会更复杂些。必须先把请求路由到主节点所在的数据中心（该数据中心可能离用户很远）。</li>
</ul>
<p>如果同一用户可能会从多个设备访问数据，情况会更加复杂。</p>
<ul>
<li>记住用户上次更新时间戳的方法实现起来会比较困难，因为在一台设备上运行的代码完全无法知道在其他设备上发生了什么。此时，元数据必须做到全局共享。</li>
<li>如果副本分布在多数据中心，无法保证来自不同设备的连接经过路由之后都到达同一个数据中心。例如，用户的台式计算机使用了家庭宽带连接，而移动设备则使用蜂窝数据网络，不同设备的网络连接线路可能完全不同。如果方案要求必须从主节点读取，则首先需要想办毡确保将来自不同设备的请求路由到同一个数据中心。</li>
</ul>
<h4 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220303093658.png" alt="img"></p>
<p>用户看到了最新内容之后又读到了过期的内容，好像时间被回拨， 此时需要单调读一致性。</p>
<p>单调读一致性可以确保不会发生这种异常。这是一个比强一致性弱，但比最终一致性强的保证。当读取数据时，单调读保证，如果某个用户依次进行多次读取，则他绝不会看到回攘现象，即在读取较新值之后又发生读旧值的情况。</p>
<p>实现单调读的一种方式是，确保每个用户总是从固定的同一副本执行读取（而不同的用户可以从不同的副本读取）。例如，基于用户 ID 的哈希的方怯而不是随机选择副本。但如果该副本发生失效，则用户的查询必须重新路由到另一个副本。</p>
<h4 id="前缀一致读"><a href="#前缀一致读" class="headerlink" title="前缀一致读"></a>前缀一致读</h4><p>前缀一致读：对于一系列按照某个顺序发生的写请求，那么读取这些内容时也会按照当时写入的顺序。</p>
<p>如果数据库总是以相同的顺序写入，则读取总是看到一致的序列，不会发生这种反常。然而，在许多分布式数据库中，不同的分区独立运行，因此不存在全局写入顺序。这就导致当用户从数据库中读数据时，可能会看到数据库的某部分旧值和另一部分新值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220613071613.png"></p>
<p>一个解决方案是确保任何具有因果顺序关系的写入都交给一个分区来完成，但该方案真实实现效率会大打折扣。现在有一些新的算法来显式地追踪事件因果关系。</p>
<h3 id="复制滞后的解决方案"><a href="#复制滞后的解决方案" class="headerlink" title="复制滞后的解决方案"></a>复制滞后的解决方案</h3><p>使用最终一致性系统时，最好事先就思考这样的问题：如果复制延迟增加到几分钟甚至几小时，那么应用层的行为会是什么样子？如果这种情况不可接受，那么在设计系统肘，就要考虑提供一个更强的一致性保证，比如写后读； 如果系统设计时假定是同步复制，但最终它事实上成为了异步复制，就可能会导致灾难性后果。</p>
<p>在应用层可以提供比底层数据库更强有力的保证。例如只在主节点上进行特定类型的读取，而代价则是，应用层代码中处理这些问题通常会非常复杂，且容易出错。</p>
<p>如果应用程序开发人员不必担心这么多底层的复制问题，而是假定数据库在“做正确的事情”，情况就变得很简单。而这也是事务存在的原因，事务是数据库提供更强保证的一种方式。</p>
<p>单节点上支持事务已经非常成熟。然而，在转向分布式数据库（即支持复制和分区）的过程中，有许多系统却选择放弃支持事务，并声称事务在性能与可用性方面代价过高，所以选择了最终一致性。</p>
<h2 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h2><p>主从复制方法较为常见，但存在一个明显的缺点：系统只有一个主节点，而所有写入都必须经由主节点。如果由于某种原因，例如与主节点之间的网络中断而导致主节点无法连接，主从复制方案就会影响所有的写入操作。</p>
<p>对主从复制模型进行自然的扩展，则可以配置多个主节点，每个主节点都可以接受写 s 操作，后面复制的流程类似： 处理写的每个主节点都必须将该数据更改转发到所有其他节点。这就是多主节点（ 也称为主－主，或主动／主动）复制。此时，每个主节点还同时扮演其他主节点的从节点。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在一个数据中心内部使用多主节点基本没有太大意义，其复杂性已经超过所能带来的好处。</p>
<p>但是，以下场景这种配置则是合理的：</p>
<ul>
<li>多数据中心</li>
<li>离线客户端操作</li>
<li>协作编辑</li>
</ul>
<h4 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h4><p>为了容忍整个数据中心级别故障或者更接近用户，可以把数据库的副本横跨多个数据中心。而如果使用常规的基于主从的复制模型，主节点势必只能放在其中的某一个数据中心，而所有写请求都必须经过该数据中心。</p>
<p>有了多主节点复制模型，则可以在每个数据中心都配置主节点。在每个数据中心内，采用常规的主从复制方案；而在数据中心之间，由各个数据中心的主节点来负责同其他数据中心的主节点进行数据的交换、更新。</p>
<p>部署单主节点的主从复制方案与多主复制方案之间的差异</p>
<ul>
<li><strong>性能</strong>：对于主从复制，每个写请求都必须经由广域网传送至主节点所在的数据中心。这会大大增加写入延迟，井基本偏离了采用多数据中心的初衷（即就近访问）。而在多主节点模型中，每个写操作都可以在本地数据中心快速响应，然后采用异步复制方式将变化同步到其他数据中心。因此，对上层应用有效屏蔽了数据中心之间的网络延迟，使得终端用户所体验到的性能更好。</li>
<li><strong>容忍数据中心失效</strong>：对于主从复制，如果主节点所在的数据中心发生故障，必须切换至另一个数据中心，将其中的一个从节点被提升为主节点。在多主节点模型中，每个数据中心则可以独立于其他数据中心继续运行，发生故障的数据中心在恢复之后更新到最新状态。</li>
<li><strong>容忍网络问题</strong>：数据中心之间的通信通常经由广域网，它往往不如数据中心内的本地网络可靠。对于主从复制模型，由于写请求是同步操作，对数据中心之间的网络性能和稳定性等更加依赖。多主节点模型则通常采用异步复制，可以更好地容忍此类问题，例如临时网络闪断不会妨碍写请求最终成功。</li>
</ul>
<h4 id="离线客户端操作"><a href="#离线客户端操作" class="headerlink" title="离线客户端操作"></a>离线客户端操作</h4><p>另一种多主复制比较适合的场景是，应用在与网络断开后还需要继续工作。</p>
<p>这种情况下，每个设备都有一个充当主节点的本地数据库（用来接受写请求），然后在所有设备之间采用异步方式同步这些多主节点上的副本，同步滞后可能是几小时或者数天，具体时间取决于设备何时可以再次联网。</p>
<p>从架构层面来看，上述设置基本上等同于数据中心之间的多主复制，只不过是个极端情况，即一个设备就是数据中心，而且它们之间的网络连接非常不可靠。多个设备同步日历的例子表明，多主节点可以得到想要的结果，但中间过程依然有很多的未知数。</p>
<p>有一些工具可以使多主配置更为容易，如 CouchDB 就是为这种操作模式而设计的。</p>
<h4 id="协作编辑"><a href="#协作编辑" class="headerlink" title="协作编辑"></a>协作编辑</h4><p>实时协作编辑应用程序允许多个用户同时编辑文档。</p>
<p>我们通常不会将协作编辑完全等价于数据库复制问题，但二者确实有很多相似之处。当一个用户编辑文档时· ，所做的更改会立即应用到本地副本（ Web 浏览器或客户端应用程序），然后异步复制到服务器以及编辑同一文档的其他用户。如果要确保不会发生编辑冲突，则应用程序必须先将文档锁定，然后才能对其进行编辑。如果另一个用户想要编辑同一个文档， 首先必须等到第一个用户提交修改并释放锁。这种协作模式相当于主从复制模型下在主节点上执行事务操作。</p>
<p>为了加快协作编辑的效率， 可编辑的粒度需要非常小。例如，单个按键甚至是全程无锁。然而另一方面， 也会面临所有多主复制都存在的挑战， 即如何解决冲突。</p>
<h3 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h3><p>多主复制的最大问题是可能发生写冲突。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220613072848.png"></p>
<h4 id="同步与异步冲突检测"><a href="#同步与异步冲突检测" class="headerlink" title="同步与异步冲突检测"></a>同步与异步冲突检测</h4><p>如果是主从复制数据库，第二个写请求要么会被阻塞直到第一个写完成， 要么被中止（用户必须重试） 。然而在多主节点的复制模型下，这两个写请求都是成功的，井且只能在稍后的时间点上才能异步检测到冲突，那时再要求用户层来解决冲突为时已晚。</p>
<p>理论上， 也可以做到同步冲突检测，即等待写请求完成对所有副本的同步，然后再通知用户写入成功。但是，这样做将会失去多主节点的主要优势：允许每个主节点独立接受写请求。如果确实想要同步方式冲突检测，或许应该考虑采用单主节点的主从复制模型。</p>
<h4 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h4><p>处理冲突最理想的策略是避免发生冲突，即如果应用层可以保证对特定记录的写请求总是通过同一个主节点，这样就不会发生写冲突。现实中，由于不少多主节点复制模型所实现的冲突解决方案存在瑕疵，因此，避免冲突反而成为大家普遍推荐的首选方案。</p>
<p>但是，有时可能需要改变事先指定的主节点，例如由于该数据中心发生故障，不得不将流量重新路由到其他数据中心，或者是因为用户已经漫游到另一个位置，因而更靠近新数据中心。此时，冲突避免方式不再有效，必须有措施来处理同时写入冲突的可能性。</p>
<h4 id="收敛于一致状态"><a href="#收敛于一致状态" class="headerlink" title="收敛于一致状态"></a>收敛于一致状态</h4><p>对于主从复制模型，数据更新符合顺序性原则，即如果同一个字段有多个更新，则最后一个写操作将决定该字段的最终值。</p>
<p>对于多主节点复制模型，由于不存在这样的写入顺序，所以最终值也会变得不确定。</p>
<p>实现收敛的冲突解决有以下可能的方式：</p>
<ul>
<li>给每个写入分配唯一的 ID ，例如， 一个时间戳， 一个足够长的随机数， 一个 UUID 或者一个基于键－值的哈希，挑选最高 ID 的写入作为胜利者，并将其他写入丢弃。如果基于时间戳，这种技术被称为最后写入者获胜。虽然这种方法很流行，但是很容易造成数据丢失。</li>
<li>为每个副本分配一个唯一的 ID ，井制定规则，例如序号高的副本写入始终优先于序号低的副本。这种方法也可能会导致数据丢失。</li>
<li>以某种方式将这些值合并在一起。例如，按字母顺序排序，然后拼接在一起。</li>
<li>利用预定义好的格式来记录和保留冲突相关的所有信息，然后依靠应用层的逻辑，事后解决冲突（可能会提示用户） 。</li>
</ul>
<h4 id="自定义冲突解决逻辑"><a href="#自定义冲突解决逻辑" class="headerlink" title="自定义冲突解决逻辑"></a>自定义冲突解决逻辑</h4><p>解决冲突最合适的方式可能还是依靠应用层，所以大多数多主节点复制模型都有工具来让用户编写应用代码来解决冲突。可以在写入时或在读取时执行这些代码逻辑：</p>
<ul>
<li><strong>在写入时执行</strong>：只要数据库系统在复制变更日志时检测到冲突，就会调用应用层的冲突处理程序。</li>
<li><strong>在读取时执行</strong>：当检测到冲突时，所有冲突写入值都会暂时保存下来。下一次读取数据时，会将数据的多个版本读返回给应用层。应用层可能会提示用户或自动解决冲突， 井将最后的结果返回到数据库。</li>
</ul>
<p>注意， 冲突解决通常用于单个行或文档， 而不是整个事务。因此，如果有一个原子事务包含多个不同写请求，每个写请求仍然是分开考虑来解决冲突。</p>
<h2 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h2><p>单主节点和多主节点复制，都是基于这样一种核心思路，即客户端先向某个节点（主节点）发送写请求，然后数据库系统负责将写请求复制到其他副本。由主节点决定写操作的顺序， 从节点按照相同的顺序来应用主节点所发送的写日志。</p>
<p>一些数据存储系统则采用了不同的设计思路：选择放弃主节点，允许任何副本直接接受来自客户端的写请求。对于某些无主节点系统实现，客户端直接将其写请求发送到多副本，而在其他一些实现中，由一个协调者节点代表客户端进行写人，但与主节点的数据库不同，协调者井不负责写入顺序的维护。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/">《数据密集型应用系统设计》</a> - 这可能是目前最好的分布式存储书籍，强力推荐【进阶】</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/b09613/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/b09613/" class="post-title-link" itemprop="url">DevOps 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-01 09:57:41" itemprop="dateCreated datePublished" datetime="2022-06-01T09:57:41+08:00">2022-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/DevOps/" itemprop="url" rel="index"><span itemprop="name">DevOps</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/DevOps/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DevOps-简介"><a href="#DevOps-简介" class="headerlink" title="DevOps 简介"></a>DevOps 简介</h1><h2 id="什么是-DevOps"><a href="#什么是-DevOps" class="headerlink" title="什么是 DevOps"></a>什么是 DevOps</h2><p>什么是 DevOps？<strong>DevOps 集文化理念、实践和工具于一身，它强调团队授权、跨团队沟通和协作以及技术自动化，其最终目标是优化质量和交付</strong>。</p>
<p>DevOps 理念，旨在打破开发工程师和运维工程师的壁垒，强调两个团队合而为一，在产品的整个生命周期（从开发、测试、部署再到运维、运营）内相互协作，工程师不再限于单一职能。</p>
<p>DevOps 始于 2007 年左右，当时的开发和运维对传统的软件开发模式提出了担忧：在这种模式下，编写代码的开发人员与负责部署的运维人员分开工作。 DevOps 一词是开发（development）和运维（operations）这两个词的组合，反映了将二者合而为一的过程。</p>
<h3 id="DevOps-如何工作"><a href="#DevOps-如何工作" class="headerlink" title="DevOps 如何工作"></a>DevOps 如何工作</h3><p>DevOps 团队包括在整个产品生命周期中协同工作的开发人员和运维人员，以提高软件部署的速度和质量。这是一种新的工作方式，一种文化转变，对团队及其工作的组织具有重要意义。</p>
<p>在 DevOps 模型下，开发和运维团队不再“孤立”。有时，这两个团队甚至会合并为一个团队，工程师在整个应用程序生命周期中工作，需要具备从开发、测试到部署和运维的复合型能力。</p>
<p>DevOps 团队使用工具来自动化和优化流程，这有助于提高可靠性。 DevOps 工具链可帮助团队处理重要的 DevOps 基础知识，包括持续集成、持续交付、自动化和协作。</p>
<p>DevOps 价值观也适用于开发以外的团队。如果 QA、安全团队也和开发、运维团队紧密地结合在一起，贯穿产品的整个生命周期。此时，安全成为了所有 DevOps 团队成员的工作重点，此时可以称为为 “DevSecOps”。</p>
<h3 id="DevOps-的生命周期"><a href="#DevOps-的生命周期" class="headerlink" title="DevOps 的生命周期"></a>DevOps 的生命周期</h3><p>由于 DevOps 的连续性，可以使用无限循环来展示 DevOps 生命周期的各个阶段是如何相互关联的。尽管看起来是按顺序流动的，但循环象征着在整个生命周期中始终保持持续迭代。</p>
<p>DevOps 生命周期由六个阶段组成，分别代表开发和运维所需的流程、功能和工具。在每个阶段，团队协作和沟通以保持一致性、速度和质量。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220601155057.png" alt="img"></p>
<p><em>图片来自 <a target="_blank" rel="noopener" href="https://www.tasksgrid.com/devops-guide/">https://www.tasksgrid.com/devops-guide/</a></em></p>
<h3 id="DevOps-的优势"><a href="#DevOps-的优势" class="headerlink" title="DevOps 的优势"></a>DevOps 的优势</h3><ul>
<li><strong>速度</strong>：应用 DevOps 可以更频繁地发布可交付成果，并且质量和稳定性也更高。高效的迭代，可以根据客户和市场反馈进行快速响应，以适应市场变化，有效推动业务发展。</li>
<li><strong>促进协作</strong>：DevOps 的基础是开发和运维之间的协作文化，两个团队紧密协作，共同承担诸多责任，并将各自的工作流程相互融合。这有助于减少效率低下的工作，同时节约大家的时间。</li>
<li><strong>快速发布</strong>：提高发布的频率和速度，以便能够更快速地进行创新并完善产品。您发布新功能和修复错误的速度越快，就越能快速地响应客户需求并建立竞争优势。持续集成和持续交付是自动执行软件发布流程（从构建到部署）的两项实践经验。</li>
<li><strong>可靠性</strong>：持续集成和持续部署等实践可检验程序变更后，功能是否正常，是否安全，从而提高软件产品的交付质量。监控和日志记录可以帮助团队实时了解服务当前的运行状态。</li>
<li><strong>规模</strong>：大规模运行和管理您的基础设施及开发流程。自动化和一致性可在降低风险的同时，帮助您有效管理复杂或不断变化的系统。例如，基础设施即代码能够帮助您以一种可重复且更有效的方式来管理部署、测试和生产环境。</li>
<li><strong>安全性</strong>：通过将自动实施的合规性策略、精细控制和配置管理技术集成到敏捷开发和 DevOps 工作流程中，使得产品内置了安全性。</li>
</ul>
<h2 id="DevOps-工具"><a href="#DevOps-工具" class="headerlink" title="DevOps 工具"></a>DevOps 工具</h2><p>DevOps 各生命周期阶段都有合适的工具可以作为解决方案。它们通过提高协作效率、减少上下文切换、引入自动化以及实现可监控来全方位增强 DevOps 实践。</p>
<p>DevOps 工具链通常遵循两种模式：完整解决方案或开放式工具链。</p>
<ul>
<li>完整解决方案实现了端到端的交付，流程很完备，但是一般难以兼容、集成第三方工具。</li>
<li>开放式工具链允许使用不同的工具进行定制。</li>
</ul>
<p>这两种方法各有利弊。</p>
<p>这里列举一些常见的 DevOps 工具：</p>
<ul>
<li><strong>项目管理</strong>：<a target="_blank" rel="noopener" href="https://www.atlassian.com/zh/software/jira"><strong>Jira</strong></a></li>
<li><strong>文档管理</strong>：<a target="_blank" rel="noopener" href="https://www.atlassian.com/zh/software/confluence"><strong>Confluence</strong></a></li>
<li><strong>代码管理</strong>：<a target="_blank" rel="noopener" href="https://about.gitlab.com/"><strong>Gitlab</strong></a>、<a target="_blank" rel="noopener" href="https://github.com/"><strong>Github</strong></a></li>
<li><strong>CI&#x2F;CD</strong>：<a target="_blank" rel="noopener" href="https://about.gitlab.com/"><strong>Gitlab</strong></a>、<a target="_blank" rel="noopener" href="https://www.jenkins.io/"><strong>Jenkins</strong></a></li>
<li><strong>容器</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.docker.com/"><strong>Docker</strong></a> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes"><strong>Kubernetes</strong></a> 是谷歌开源的容器集群管理系统 是用于自动部署，扩展和管理 Docker 应用程序的开源系统，简称 K8S。</li>
</ul>
</li>
<li><strong>日志</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/what-is/elasticsearch/"><strong>ELK</strong></a> 技术栈，通过数据采集工具 Logstack、Beats 套件、日志存储、解析服务 ElasticSearch、日志可视化工具 Kibnana，形成了一套完整的端到端日志解决方案，深受业界好评。</li>
</ul>
</li>
<li><strong>监控</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/what-is/elasticsearch/"><strong>ELK</strong></a> 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/prometheus/prometheus"><strong>Prometheus</strong></a> 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 PromQL 查询语言，功能强大而且简洁。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/grafana/grafana"><strong>Grafana</strong></a> 是流行的监控数据分析和可视化套件。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/graphite-project/graphite-web"><strong>Graphite</strong></a> 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 API 也可以接入其他图形化监控系统如 Grafana。</li>
</ul>
</li>
<li><strong>链路追踪</strong><ul>
<li><a target="_blank" rel="noopener" href="https://zipkin.io/"><strong>Zipkin</strong></a>：Zipkin 是 Twitter 开源的调用链分析工具，目前基于 <strong><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-sleuth">spring-cloud-sleuth</a></strong> 得到了广泛的使用，特点是轻量，使用、部署简单。</li>
<li><a target="_blank" rel="noopener" href="https://pinpoint-apm.gitbook.io/pinpoint/"><strong>Pinpoint</strong></a>：是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI 功能强大，接入端无代码侵入。</li>
<li><a target="_blank" rel="noopener" href="https://skywalking.apache.org/"><strong>SkyWalking</strong></a>：是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI 功能较强，接入端无代码侵入。目前已加入 Apache 孵化器。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/dianping/cat"><strong>CAT</strong></a>：CAT 是美团点评开源的基于编码和配置的调用链分析，应用监控分析，日志采集，监控报警等一系列的监控平台工具。</li>
</ul>
</li>
<li><strong>负载均衡</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/"><strong>Nginx</strong></a> 可以作为四层或七层负载均衡器。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/LVS"><strong>LVS</strong></a> 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。</li>
<li><a target="_blank" rel="noopener" href="http://www.haproxy.org/"><strong>HAProxy</strong></a> 可以作为 HTTP 和 TCP 负载均衡器。</li>
<li><a target="_blank" rel="noopener" href="https://f5.com/zh"><strong>F5</strong></a> 作为硬件负载均衡</li>
<li><a target="_blank" rel="noopener" href="https://www.a10networks.com.cn/"><strong>A10</strong></a> 作为硬件负载均衡</li>
</ul>
</li>
<li><strong>网关</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Kong/kong"><strong>Kong</strong></a> 是一个云原生、快速、可扩展和分布式的微服务抽象层（也称为 API 网关，API 中间件）。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul"><strong>Zuul</strong></a> 是 Netflix 开源的一个 API 网关，Zuul 在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。</li>
</ul>
</li>
<li>告警：短信、邮件、企业聊天软件、OA</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=_I94-tJlovg">【Youtube 视频】What is DevOps? - In Simple English</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Xrgk023l4lI">【Youtube 视频】DevOps In 5 Minutes</a></li>
<li><a target="_blank" rel="noopener" href="https://www.atlassian.com/devops">DevOps: Breaking the development-operations barrier</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d1bae4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d1bae4/" class="post-title-link" itemprop="url">Elasticsearch 映射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-16 19:54:24" itemprop="dateCreated datePublished" datetime="2022-05-16T19:54:24+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-映射"><a href="#Elasticsearch-映射" class="headerlink" title="Elasticsearch 映射"></a>Elasticsearch 映射</h1><p>在 Elasticsearch 中，**<code>Mapping</code>**（映射），用来定义一个文档以及其所包含的字段如何被存储和索引，可以在映射中事先定义字段的数据类型、字段的权重、分词器等属性，就如同在关系型数据库中创建数据表时会设置字段的类型。</p>
<p>Mapping 会把 JSON 文档映射成 Lucene 所需要的扁平格式</p>
<p>一个 Mapping 属于一个索引的 Type</p>
<ul>
<li>每个文档都属于一个 Type</li>
<li>一个 Type 有一个 Mapping 定义</li>
<li>7.0 开始，不需要在 Mapping 定义中指定 type 信息</li>
</ul>
<p>每个 <code>document</code> 都是 <code>field</code> 的集合，每个 <code>field</code> 都有自己的数据类型。映射数据时，可以创建一个 <code>mapping</code>，其中包含与 <code>document</code> 相关的 <code>field</code> 列表。映射定义还包括元数据 <code>field</code>，例如 <code>_source</code> ，它自定义如何处理 <code>document</code> 的关联元数据。</p>
<h2 id="映射方式"><a href="#映射方式" class="headerlink" title="映射方式"></a>映射方式</h2><p>在 Elasticsearch 中，映射可分为静态映射和动态映射。在关系型数据库中写入数据之前首先要建表，在建表语句中声明字段的属性，在 Elasticsearch 中，则不必如此，Elasticsearch 最重要的功能之一就是让你尽可能快地开始探索数据，文档写入 Elasticsearch 中，它会根据字段的类型自动识别，这种机制称为<strong>动态映射</strong>，而<strong>静态映射</strong>则是写入数据之前对字段的属性进行手工设置。</p>
<h3 id="静态映射"><a href="#静态映射" class="headerlink" title="静态映射"></a>静态映射</h3><p>ES 官方将静态映射称为<strong>显式映射（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/explicit-mapping.html">Explicit mapping</a>）</strong>。<strong>静态映射</strong>是在创建索引时显示的指定索引映射。静态映射和 SQL 中在建表语句中指定字段属性类似。相比动态映射，通过静态映射可以添加更详细、更精准的配置信息。例如：</p>
<ul>
<li>哪些字符串字段应被视为全文字段。</li>
<li>哪些字段包含数字、日期或地理位置。</li>
<li>日期值的格式。</li>
<li>用于控制动态添加字段的自定义规则。</li>
</ul>
<p>【示例】创建索引时，显示指定 mapping</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /my-index-<span class="number">000001</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:    &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;email&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>  &#125;,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>:   &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】在已存在的索引中，指定一个 field 的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /my-index-<span class="number">000001</span>/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;employee-id&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】查看 mapping</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="regexp">/my-index-000001/</span>_mapping</span><br></pre></td></tr></table></figure>

<p>【示例】查看指定 field 的 mapping</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="regexp">/my-index-000001/</span>_mapping<span class="regexp">/field/</span>employee-id</span><br></pre></td></tr></table></figure>

<h3 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h3><p>动态映射机制，允许用户不手动定义映射，Elasticsearch 会自动识别字段类型。在实际项目中，如果遇到的业务在导入数据之前不确定有哪些字段，也不清楚字段的类型是什么，使用动态映射非常合适。当 Elasticsearch 在文档中碰到一个以前没见过的字段时，它会利用动态映射来决定该字段的类型，并自动把该字段添加到映射中。</p>
<p>示例：创建一个名为 <code>data</code> 的索引、其 <code>mapping</code> 类型为 <code>_doc</code>，并且有一个类型为 <code>long</code> 的字段 <code>count</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT data/_doc/1</span><br><span class="line">&#123; <span class="string">&quot;count&quot;</span>: 5 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态字段映射"><a href="#动态字段映射" class="headerlink" title="动态字段映射"></a>动态字段映射</h4><p>动态字段映射（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-field-mapping.html">Dynamic field mappings</a>）是用于管理动态字段检测的规则。当 Elasticsearch 在文档中检测到新字段时，默认情况下会动态将该字段添加到类型映射中。</p>
<p>在 mapping 中可以通过将 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic.html"><code>dynamic</code></a> 参数设置为 <code>true</code> 或 <code>runtime</code> 来开启动态映射。</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic.html"><code>dynamic</code></a> 不同设置的作用：</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>true</code></td>
<td>新字段被添加到 mapping 中。mapping 的默认设置。</td>
</tr>
<tr>
<td><code>runtime</code></td>
<td>新字段被添加到 mapping 中并作为运行时字段——这些字段不会被索引，但是可以在查询时出现在 <code>_source</code> 中。</td>
</tr>
<tr>
<td><code>false</code></td>
<td>新字段不会被索引或搜索，但仍会出现在返回匹配的 <code>_source</code> 字段中。这些字段不会添加到映射中，并且必须显式添加新字段。</td>
</tr>
<tr>
<td><code>strict</code></td>
<td>如果检测到新字段，则会抛出异常并拒绝文档。必须将新字段显式添加到映射中。</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是：对已有字段，一旦已经有数据写入，就不再支持修改字段定义。如果希望改变字段类型，必须重建索引。这是由于 Lucene 实现的倒排索引，一旦生成后，就不允许修改。如果修改了字段的数据类型，会导致已被索引的字段无法被搜索。</p>
</blockquote>
<p>启用动态字段映射后，Elasticsearch 使用内置规则来确定如何映射每个字段的数据类型。规则如下：</p>
<table>
<thead>
<tr>
<th><strong>JSON 数据类型</strong></th>
<th><strong><code>&quot;dynamic&quot;:&quot;true&quot;</code></strong></th>
<th><strong><code>&quot;dynamic&quot;:&quot;runtime&quot;</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>null</code></td>
<td>没有字段被添加</td>
<td>没有字段被添加</td>
</tr>
<tr>
<td><code>true</code> or <code>false</code></td>
<td><code>boolean</code> 类型</td>
<td><code>boolean</code> 类型</td>
</tr>
<tr>
<td>浮点型数字</td>
<td><code>float</code> 类型</td>
<td><code>double</code> 类型</td>
</tr>
<tr>
<td>数字</td>
<td>数字型</td>
<td><code>long</code> 类型</td>
</tr>
<tr>
<td>JSON 对象</td>
<td><code>object</code> 类型</td>
<td>没有字段被添加</td>
</tr>
<tr>
<td>数组</td>
<td>由数组中第一个非空值决定</td>
<td>由数组中第一个非空值决定</td>
</tr>
<tr>
<td>开启<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-field-mapping.html#date-detection">日期检测</a>的字符串</td>
<td><code>date</code> 类型</td>
<td><code>date</code> 类型</td>
</tr>
<tr>
<td>开启<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-field-mapping.html#numeric-detection">数字检测</a>的字符串</td>
<td><code>float</code> 类型或 <code>long</code>类型</td>
<td><code>double</code> 类型或 <code>long</code> 类型</td>
</tr>
<tr>
<td>什么也没开启的字符串</td>
<td>带有 <code>.keyword</code> 子 field 的 <code>text</code> 类型</td>
<td><code>keyword</code> 类型</td>
</tr>
</tbody></table>
<p>下面举一个例子认识动态 mapping，在 Elasticsearch 中创建一个新的索引并查看它的 mapping，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT books</span><br><span class="line">GET books/_mapping</span><br></pre></td></tr></table></figure>

<p>此时 books 索引的 mapping 是空的，返回结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>再往 books 索引中写入一条文档，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT books/it/1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;id&quot;</span>: 1,</span><br><span class="line">	<span class="string">&quot;publish_date&quot;</span>: <span class="string">&quot;2019-11-10&quot;</span>,</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;master Elasticsearch&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档写入完成之后，再次查看 mapping，返回结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;long&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;publish_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>动态映射有时可能会错误的识别字段类型，这种情况下，可能会导致一些功能无法正常使用，如 Range 查询。所以，使用动态 mapping 要结合实际业务需求来综合考虑，如果将 Elasticsearch 当作主要的数据存储使用，并且希望出现未知字段时抛出异常来提醒你注意这一问题，那么开启动态 mapping 并不适用。</p>
<h4 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h4><p><strong>动态模板（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-templates.html">dynamic templates</a>）</strong>是用于给 <code>mapping</code> 动态添加字段的自定义规则。</p>
<p>动态模板可以设置匹配条件，只有匹配的情况下才使用动态模板：</p>
<ul>
<li><code>match_mapping_type</code> 对 Elasticsearch 检测到的数据类型进行操作</li>
<li><code>match</code> 和 <code>unmatch</code> 使用模式匹配字段名称</li>
<li><code>path_match</code> 和 <code>path_unmatch</code> 对字段的完整虚线路径进行操作</li>
<li>如果动态模板没有定义 <code>match_mapping_type</code>、<code>match</code> 或 <code>path_match</code>，则不会匹配任何字段。您仍然可以在批量请求的 <code>dynamic_templates</code> 部分按名称引用模板。</li>
</ul>
<p>【示例】当设置 <code>&#39;dynamic&#39;:&#39;true&#39;</code> 时，Elasticsearch 会将字符串字段映射为带有关键字子字段的文本字段。如果只是索引结构化内容并且对全文搜索不感兴趣，可以让 Elasticsearch 仅将字段映射为关键字字段。这种情况下，只有完全匹配才能搜索到这些字段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> my-index-<span class="number">000001</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;strings_as_keywords&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行时字段"><a href="#运行时字段" class="headerlink" title="运行时字段"></a>运行时字段</h2><p>运行时字段是在查询时评估的字段。运行时字段有以下作用：</p>
<ul>
<li>在不重新索引数据的情况下，向现有文档添加字段</li>
<li>在不了解数据结构的情况下，也可以处理数据</li>
<li>在查询时覆盖从索引字段返回的值</li>
<li>为特定用途定义字段而不修改底层架构</li>
</ul>
<p>检索 Elasticsearch 时，运行时字段和其他字段并没有什么不同。</p>
<p>需要注意的是：使用 <code>_search</code> API 上的 <code>fields</code> 参数来检索运行时字段的值。运行时字段不会显示在 <code>_source</code> 中，但 <code>fields</code> API 适用于所有字段，即使是那些未作为原始 <code>_source</code> 的一部分发送的字段。</p>
<p>运行时字段在处理日志数据时很有用，尤其是当日志是不确定的数据结构时：这种情况下，会降低搜索速度，但您的索引大小要小得多，您可以更快地处理日志，而无需为它们设置索引。</p>
<h3 id="运行时字段的优点"><a href="#运行时字段的优点" class="headerlink" title="运行时字段的优点"></a>运行时字段的优点</h3><p>因为<strong>运行时字段没有被索引</strong>，所以添加运行时字段不会增加索引大小。用户可以直接在 mapping 中定义运行时字段，从而节省存储成本并提高采集数据的速度。定义了运行时字段后，可以立即在搜索请求、聚合、过滤和排序中使用它。</p>
<p>如果将运行时字段设为索引字段，则无需修改任何引用运行时字段的查询。更好的是，您可以引用字段是运行时字段的一些索引，以及字段是索引字段的其他索引。您可以灵活地选择要索引哪些字段以及保留哪些字段作为运行时字段。</p>
<p>就其核心而言，运行时字段最重要的好处是能够在您提取字段后将字段添加到文档中。此功能简化了映射决策，因为您不必预先决定如何解析数据，并且可以使用运行时字段随时修改映射。使用运行时字段允许更小的索引和更快的摄取时间，这结合使用更少的资源并降低您的运营成本。</p>
<h2 id="字段数据类型"><a href="#字段数据类型" class="headerlink" title="字段数据类型"></a>字段数据类型</h2><p>在 Elasticsearch 中，每个字段都有一个字段数据类型或字段类型，用于指示字段包含的数据类型（例如字符串或布尔值）及其预期用途。字段类型按系列分组。同一族中的类型具有完全相同的搜索行为，但可能具有不同的空间使用或性能特征。</p>
<p>Elasticsearch 提供了非常丰富的数据类型，官方将其分为以下几类：</p>
<ul>
<li><p><strong>普通类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/binary.html"><code>binary</code></a>：编码为 Base64 字符串的二进制值。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/boolean.html"><code>boolean</code></a>：布尔类型，值为 true 或 false。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html">Keywords</a>：keyword 族类型，包括 <code>keyword</code>、<code>constant_keyword</code> 和 <code>wildcard</code>。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html">Numbers</a>：数字类型，如 <code>long</code> 和 <code>double</code></li>
<li><strong>Dates</strong>：日期类型，包括 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html"><code>date</code></a> 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/date_nanos.html"><code>date_nanos</code></a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/field-alias.html"><code>alias</code></a>：用于定义存在字段的别名。</li>
</ul>
</li>
<li><p><strong>对象类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/object.html"><code>object</code></a>：JSON 对象</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/flattened.html"><code>flattened</code></a>：整个 JSON 对象作为单个字段值。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html"><code>nested</code></a>：保留其子字段之间关系的 JSON 对象。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/parent-join.html"><code>join</code></a>：为同一索引中的文档定义父&#x2F;子关系。</li>
</ul>
</li>
<li><p><strong>结构化数据类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/range.html">Range</a>：范围类型，例如：<code>long_range</code>、<code>double_range</code>、<code>date_range</code> 和 <code>ip_range</code>。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ip.html"><code>ip</code></a>：IPv4 和 IPv6 地址。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/version.html"><code>version</code></a>：版本号。支持 <a target="_blank" rel="noopener" href="https://semver.org/">Semantic Versioning</a> 优先规则。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/plugins/8.2/mapper-murmur3.html"><code>murmur3</code></a>：计算并存储 hash 值。</li>
</ul>
</li>
<li><p><strong>聚合数据类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/aggregate-metric-double.html"><code>aggregate_metric_double</code></a>：预先聚合的指标值</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/histogram.html"><code>histogram</code></a>：直方图式的预聚合数值。</li>
</ul>
</li>
<li><p><strong>文本搜索类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/text.html"><code>text</code> fields</a>：text 族类型，包括 <code>text</code> 和 <code>match_only_text</code>。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/plugins/8.2/mapper-annotated-text.html"><code>annotated-text</code></a>：包含特殊标记的文本。用于识别命名实体。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html#completion-suggester"><code>completion</code></a>：用于自动补全。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-as-you-type.html"><code>search_as_you_type</code></a>：键入时完成的类似文本的类型。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/token-count.html"><code>token_count</code></a>：文本中标记的计数。</li>
</ul>
</li>
<li><p><strong>文档排名类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dense-vector.html"><code>dense_vector</code></a>：记录浮点数的密集向量。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rank-feature.html"><code>rank_feature</code></a>：记录一个数字特征，为了在查询时提高命中率。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rank-features.html"><code>rank_features</code></a>：记录多个数字特征，为了在查询时提高命中率。</li>
</ul>
</li>
<li><p><strong>空间数据类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-point.html"><code>geo_point</code></a>：地理经纬度</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html"><code>geo_shape</code></a>：复杂的形状，例如多边形</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/point.html"><code>point</code></a>：任意笛卡尔点</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/shape.html"><code>shape</code></a>：任意笛卡尔几何形状</li>
</ul>
</li>
<li><p><strong>其他类型</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/percolator.html"><code>percolator</code></a>：使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Query DSL</a> 编写的索引查询</li>
</ul>
</li>
</ul>
<h2 id="元数据字段"><a href="#元数据字段" class="headerlink" title="元数据字段"></a>元数据字段</h2><p>一个文档中，不仅仅包含数据 ，也包含<strong>元数据</strong>。元数据是用于描述文档的信息。</p>
<ul>
<li><strong>标识元数据字段</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index-field.html"><code>_index</code></a>：文档所属的索引。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html"><code>_id</code></a>：文档的 ID。</li>
</ul>
</li>
<li><strong>文档 source 元数据字段</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html"><code>_source</code></a>：文档正文的原始 JSON。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/plugins/8.2/mapper-size.html"><code>_size</code></a>：<code>_source</code> 字段的大小（以字节为单位），由 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/plugins/8.2/mapper-size.html"><code>mapper-size</code></a> 插件提供。</li>
</ul>
</li>
<li><strong>文档计数元数据字段</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-doc-count-field.html"><code>_doc_count</code></a>：当文档表示预聚合数据时，用于存储文档计数的自定义字段。</li>
</ul>
</li>
<li><strong>索引元数据字段</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-field-names-field.html"><code>_field_names</code></a>：文档中的所有非空字段。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-ignored-field.html"><code>_ignored</code></a>：文档中所有的由于 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ignore-malformed.html"><code>ignore_malformed</code></a> 而在索引时被忽略的字段。</li>
</ul>
</li>
<li><strong>路由元数据字段</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html"><code>_routing</code></a>：将文档路由到特定分片的自定义路由值。</li>
</ul>
</li>
<li><strong>其他元数据字段</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-meta-field.html"><code>_meta</code></a>：应用程序特定的元数据。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-tier-field.html"><code>_tier</code></a>：文档所属索引的当前数据层首选项。</li>
</ul>
</li>
</ul>
<h2 id="映射参数"><a href="#映射参数" class="headerlink" title="映射参数"></a>映射参数</h2><p>Elasticsearch 提供了以下映射参数：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer.html"><code>analyzer</code></a>：指定在索引或搜索文本字段时用于文本分析的分析器。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/coerce.html"><code>coerce</code></a>：如果开启，Elasticsearch 将尝试清理脏数据以适应字段的数据类型。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/copy-to.html"><code>copy_to</code></a>：允许将多个字段的值复制到一个组字段中，然后可以将其作为单个字段进行查询。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/doc-values.html"><code>doc_values</code></a>：默认情况下，所有字段都是被</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic.html"><code>dynamic</code></a>：是否开启动态映射。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/eager-global-ordinals.html"><code>eager_global_ordinals</code></a>：当在 global ordinals 的时候，refresh 以后下一次查询字典就需要重新构建，在追求查询的场景下很影响查询性能。可以使用 eager_global_ordinals，即在每次 refresh 以后即可更新字典，字典常驻内存，减少了查询的时候构建字典的耗时。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/enabled.html"><code>enabled</code></a>：只能应用于顶级 mapping 定义和 <code>object</code> 字段。设置为 <code>false</code> 后，Elasticsearch 解析时，会完全跳过该字段。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/fielddata.html"><code>fielddata</code></a>：默认情况下， <code>text</code> 字段是可搜索的，但不可用于聚合、排序或脚本。如果为字段设置 <code>fielddata=true</code>，就会通过反转倒排索引将 fielddata 加载到内存中。请注意，这可能会占用大量内存。如果想对 <code>text</code> 字段进行聚合、排序或脚本操作，fielddata 是唯一方法。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-fields.html"><code>fields</code></a>：有时候，同一个字段需要以不同目的进行索引，此时可以通过 <code>fields</code> 进行配置。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html"><code>format</code></a>：用于格式化日期类型。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ignore-above.html"><code>ignore_above</code></a>：字符串长度大于 <code>ignore_above</code> 所设，则不会被索引或存储。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ignore-malformed.html"><code>ignore_malformed</code></a>：有时候，同一个字段，可能会存储不同的数据类型。默认情况下，Elasticsearch 解析字段数据类型失败时，会引发异常，并拒绝整个文档。 如果设置 <code>ignore_malformed</code> 为 <code>true</code>，则允许忽略异常。这种情况下，格式错误的字段不会被索引，但文档中的其他字段可以正常处理。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-options.html"><code>index_options</code></a> 用于控制将哪些信息添加到倒排索引以进行搜索和突出显示。只有 <code>text</code> 和 <code>keyword</code> 等基于术语（term）的字段类型支持此配置。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-phrases.html"><code>index_phrases</code></a>：如果启用，两个词的组合（shingles）将被索引到一个单独的字段中。这允许以更大的索引为代价，更有效地运行精确的短语查询（无 slop）。请注意，当停用词未被删除时，此方法效果最佳，因为包含停用词的短语将不使用辅助字段，并将回退到标准短语查询。接受真或假（默认）。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-prefixes.html"><code>index_prefixes</code></a>：index_prefixes 参数启用 term 前缀索引以加快前缀搜索。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index.html"><code>index</code></a>：<code>index</code> 选项控制字段值是否被索引。默认为 true。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-field-meta.html"><code>meta</code></a>：附加到字段的元数据。此元数据对 Elasticsearch 是不透明的，它仅适用于多个应用共享相同索引的元数据信息，例如：单位。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/normalizer.html"><code>normalizer</code></a>：<code>keyword</code> 字段的 <code>normalizer</code> 属性类似于 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer.html"><code>analyzer</code></a> ，只是它保证分析链只产生单个标记。 <code>normalizer</code> 在索引 <code>keyword</code> 之前应用，以及在搜索时通过查询解析器（例如匹配查询）或通过术语级别查询（例如术语查询）搜索关键字字段时应用。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/norms.html"><code>norms</code></a>：<code>norms</code> 存储在查询时使用的各种规范化因子，以便计算文档的相关性评分。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/null-value.html"><code>null_value</code></a>：null 值无法被索引和搜索。当一个字段被设为 null，则被视为没有值。<code>null_value</code> 允许将空值替换为指定值，以便对其进行索引和搜索。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/position-increment-gap.html"><code>position_increment_gap</code></a>：分析的文本字段会考虑术语位置，以便能够支持邻近或短语查询。当索引具有多个值的文本字段时，值之间会添加一个“假”间隙，以防止大多数短语查询在值之间匹配。此间隙的大小使用 <code>position_increment_gap</code> 配置，默认为 100。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/properties.html"><code>properties</code></a>：类型映射、对象字段和嵌套字段包含的子字段，都称为属性。这些属性可以是任何数据类型，包括对象和嵌套。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyzer.html"><code>search_analyzer</code></a>：通常，在索引时和搜索时应使用相同的分析器，以确保查询中的术语与倒排索引中的术语格式相同。但是，有时在搜索时使用不同的分析器可能是有意义的，例如使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html"><code>edge_ngram</code></a> 标记器实现自动补全或使用同义词搜索时。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/similarity.html"><code>similarity</code></a>：Elasticsearch 允许为每个字段配置文本评分算法或相似度。相似度设置提供了一种选择文本相似度算法的简单方法，而不是默认的 BM25，例如布尔值。只有 <code>text</code> 和 <code>keyword</code> 等基于文本的字段类型支持此配置。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-store.html"><code>store</code></a>：默认情况下，对字段值进行索引以使其可搜索，但不会存储它们。这意味着可以查询该字段，但无法检索原始字段值。通常这不重要，字段值已经是默认存储的 <code>_source</code> 字段的一部分。如果您只想检索单个字段或几个字段的值，而不是整个 <code>_source</code>，则可以通过 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-fields.html#source-filtering">source filtering</a> 来实现。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/term-vector.html"><code>term_vector</code></a>：term_vector 包含有关分析过程产生的术语的信息，包括：<ul>
<li>术语列表</li>
<li>每个 term 的位置（或顺序）</li>
<li>起始和结束字符偏移量，用于将 term 和原始字符串进行映射</li>
<li>有效负载（如果可用） - 用户定义的，与 term 位置相关的二进制数据</li>
</ul>
</li>
</ul>
<h2 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h2><ul>
<li><code>index.mapping.total_fields.limit</code>：索引中的最大字段数。字段和对象映射以及字段别名计入此限制。默认值为 <code>1000</code>。</li>
<li><code>index.mapping.depth.limit</code>：字段的最大深度，以内部对象的数量来衡量。例如，如果所有字段都在根对象级别定义，则深度为 <code>1</code>。如果有一个对象映射，则深度为 <code>2</code>，以此类推。默认值为 <code>20</code>。</li>
<li><code>index.mapping.nested_fields.limit</code>：索引中不同 <code>nested</code> 映射的最大数量。 <code>nested</code> 类型只应在特殊情况下使用，即需要相互独立地查询对象数组。为了防止设计不佳的映射，此设置限制了每个索引的唯一 <code>nested</code> 类型的数量。默认值为 <code>50</code>。</li>
<li><code>index.mapping.nested_objects.limit</code>：单个文档中，所有 <code>nested</code> 类型中包含的最大嵌套 JSON 对象数。当文档包含太多 <code>nested</code> 对象时，此限制有助于防止出现内存溢出。默认值为 <code>10000</code>。</li>
<li><code>index.mapping.field_name_length.limit</code>：设置字段名称的最大长度。默认为 Long.MAX_VALUE（无限制）。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html">Elasticsearch 官方文档之 Mapping</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e3eb31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e3eb31/" class="post-title-link" itemprop="url">《消息队列高手课》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-11 20:59:25" itemprop="dateCreated datePublished" datetime="2022-05-11T20:59:25+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《消息队列高手课》笔记"><a href="#《消息队列高手课》笔记" class="headerlink" title="《消息队列高手课》笔记"></a>《消息队列高手课》笔记</h1><h2 id="为什么需要消息队列？"><a href="#为什么需要消息队列？" class="headerlink" title="为什么需要消息队列？"></a>为什么需要消息队列？</h2><p>消息队列的应用</p>
<ul>
<li>异步处理<ul>
<li>快速响应</li>
<li>减少等待，提升性能</li>
</ul>
</li>
<li>流量控制</li>
<li>服务解耦</li>
</ul>
<h2 id="该如何选择消息队列？"><a href="#该如何选择消息队列？" class="headerlink" title="该如何选择消息队列？"></a>该如何选择消息队列？</h2><ul>
<li><strong>是否开源</strong>：这决定了能否商用，所以最为重要。</li>
<li><strong>社区活跃度越高越好</strong>：高社区活跃度，一般保证了低 Bug 率，因为大部分 Bug，已经有人遇到并解决了。</li>
<li><strong>技术生态适配性</strong>：客户端对各种编程语言的支持。比如：如果使用 MQ 的都是 Java 应用，那么 ActiveMQ、RabbitMQ、RocketMQ、Kafka 都可以。如果需要支持其他语言，那么 RMQ 比较合适，因为它支持的编程语言比较丰富。如果 MQ 是应用于大数据或流式计算，那么 Kafka 几乎是标配。如果是应用于在线业务系统，那么 Kafka 就不合适了，可以考虑 RabbitMQ、 RocketMQ 很合适。</li>
<li><strong>高可用</strong>：应用于线上的准入标准。</li>
<li><strong>高性能</strong>：具备足够好的性能，能满足绝大多数场景的性能要求。</li>
<li><strong>业务场景的适应性</strong>：不同业务场景，会有不同的诉求，此时要根据不同 MQ 的特性针对性选择。</li>
</ul>
<h3 id="主流-MQ"><a href="#主流-MQ" class="headerlink" title="主流 MQ"></a>主流 MQ</h3><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级</td>
<td>万级</td>
<td>十万级</td>
<td>十万级，略高于 RocketMQ</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百、几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>毫秒级</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高：基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高：分布式架构</td>
<td>非常高：分布式架构。每个数据都有多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到不丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>应用场景</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>适合在线业务</td>
<td>大数据、实时计算以及日志采集领域，应用最为广泛</td>
</tr>
<tr>
<td>流行度</td>
<td>不活跃</td>
<td>社区非常活跃</td>
<td>阿里出品，有非常活跃的中文社区</td>
<td>社区非常活跃</td>
</tr>
<tr>
<td>支持编程语言</td>
<td></td>
<td>非常多</td>
<td>Java</td>
<td>Scala、Java</td>
</tr>
<tr>
<td>学习成本</td>
<td></td>
<td>采用 ErLang 开发，比较小众，不利于扩展和二次开发</td>
<td>采用 Java 开发，且贡献者多为中国人，容易读懂源码</td>
<td>使用 Scala 和 Java 开发，容易读懂源码</td>
</tr>
</tbody></table>
<p>RabbitMQ</p>
<p>突出亮点</p>
<ol>
<li>支持的编程语言最多</li>
<li>支持非常灵活的路由配置</li>
</ol>
<p>明显短板</p>
<ol>
<li>对消息堆积的支持并不好</li>
<li>性能差强人意</li>
</ol>
<h2 id="消息模型：主题和队列有什么区别？"><a href="#消息模型：主题和队列有什么区别？" class="headerlink" title="消息模型：主题和队列有什么区别？"></a>消息模型：主题和队列有什么区别？</h2><h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>最初的消息队列，就是一个严格意义上的队列。在计算机领域，“队列（Queue）”是一种数据结构，有完整而严格的定义。</p>
<p><strong>早期的消息队列，就是按照“队列”的数据结构来设计的。</strong>生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。</p>
<p>如果有多个生产者往同一个队列里面发送消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者发送消息的自然顺序。如果有多个消费者接收同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到。</p>
<p>如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息。此时，单个队列就满足不了需求，一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份。显然这是个比较蠢的做法，同样的一份消息数据被复制到多个队列中会浪费资源，更重要的是，生产者必须知道有多少个消费者。为每个消费者单独发送一份消息，这实际上违背了消息队列“解耦”这个设计初衷。</p>
<h3 id="发布-订阅模型（Publish-Subscribe-Pattern）"><a href="#发布-订阅模型（Publish-Subscribe-Pattern）" class="headerlink" title="发布 - 订阅模型（Publish-Subscribe Pattern）"></a>发布 - 订阅模型（Publish-Subscribe Pattern）</h3><p>在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。</p>
<p>队列模型和发布 - 订阅模型最大的区别就是：<strong>一份消息数据能不能被消费多次的问题</strong>。</p>
<h3 id="RabbitMQ-的消息模型"><a href="#RabbitMQ-的消息模型" class="headerlink" title="RabbitMQ 的消息模型"></a>RabbitMQ 的消息模型</h3><p>RabbitMQ，它是少数依然坚持使用队列模型的产品之一。那它是怎么解决多个消费者的问题呢？</p>
<p>在 RabbitMQ 中，Exchange 位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给 Exchange，由 Exchange 上配置的策略来决定将消息投递到哪些队列中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220511211021.jfif"></p>
<p>同一份消息如果需要被多个消费者来消费，需要配置 Exchange 将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布 - 订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能。</p>
<h3 id="RocketMQ-的消息模型"><a href="#RocketMQ-的消息模型" class="headerlink" title="RocketMQ 的消息模型"></a>RocketMQ 的消息模型</h3><p>RocketMQ 使用的消息模型是标准的发布 - 订阅模型</p>
<p>但是，在 RocketMQ 也有队列（Queue）这个概念，并且队列在 RocketMQ 中是一个非常重要的概念</p>
<p>几乎所有的消息队列产品都使用一种非常朴素的“请求 - 确认”机制，确保消息不会在传递过程中由于网络或服务器故障丢失。具体的做法也非常简单。在生产端，生产者先将消息发送给服务端，也就是 Broker，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。</p>
<p>如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。</p>
<p>这个确认机制很好地保证了消息传递过程中的可靠性，但是，引入这个机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。</p>
<p>也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。</p>
<p><strong>每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。</strong>需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。</p>
<p>RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。</p>
<p>消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。</p>
<p>在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。这个消费位置是非常重要的概念，我们在使用消息队列的时候，丢消息的原因大多是由于消费位置处理不当导致的。</p>
<h2 id="如何利用事务消息实现分布式事务？"><a href="#如何利用事务消息实现分布式事务？" class="headerlink" title="如何利用事务消息实现分布式事务？"></a>如何利用事务消息实现分布式事务？</h2><p>事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。</p>
<ul>
<li><strong>Kafka</strong> 的解决方案是：直接抛出异常，让用户自行处理。用户可以在业务代码中反复重试提交，直到提交成功，或者删除之前修改的数据记录进行事务补偿。</li>
<li><strong>RocketMQ</strong> 的解决方案是：通过事务反查机制来解决事务消息提交失败的问题。如果 Producer 在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。</li>
</ul>
<h3 id="RocketMQ-事务消息流程"><a href="#RocketMQ-事务消息流程" class="headerlink" title="RocketMQ 事务消息流程"></a>RocketMQ 事务消息流程</h3><p>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。下面主要基于 RocketMQ 4.3 之后的版本介绍 MQ 的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ，相对于提供了 2PC 的提交接口，方案如下：</p>
<p><strong>正常情况——事务主动方发消息</strong> 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220512194221.png" alt="img"></p>
<ol>
<li>发送方向 MQ 服务端(MQ Server)发送 half 消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
</ol>
<p><strong>异常情况——事务主动方消息恢复</strong> 在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220512194230.png" alt="img"></p>
<ol start="5">
<li>MQ Server 对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认</li>
<li>MQ Server 基于 commit &#x2F; rollback 对消息进行投递或者删除</li>
</ol>
<blockquote>
<p><strong>思考</strong>：为什么不等待写业务表成功后再向消息队列发送提交消息呢？</p>
<p>因为可能存在这样情况：写业务表成功了，但是还没来得及发消息，节点就宕机了。</p>
</blockquote>
<h3 id="MQ-事务方案总结"><a href="#MQ-事务方案总结" class="headerlink" title="MQ 事务方案总结"></a>MQ 事务方案总结</h3><p>相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量优于使用本地消息表方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>一次消息发送需要两次网络请求(half 消息 + commit&#x2F;rollback 消息)</li>
<li>业务处理服务需要实现消息状态回查接口</li>
</ul>
<h2 id="如何确保消息不会丢失"><a href="#如何确保消息不会丢失" class="headerlink" title="如何确保消息不会丢失?"></a>如何确保消息不会丢失?</h2><ul>
<li>在生产阶段，你需要捕获消息发送的错误，并重发消息。</li>
<li>在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。</li>
<li>在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。</li>
</ul>
<h2 id="如何处理消费过程中的重复消息？"><a href="#如何处理消费过程中的重复消息？" class="headerlink" title="如何处理消费过程中的重复消息？"></a>如何处理消费过程中的重复消息？</h2><p>在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：</p>
<ul>
<li><strong>At most once</strong>: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，<strong>没什么消息可靠性保证，允许丢消息</strong>。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</li>
<li><strong>At least once</strong>: 至少一次。消息在传递时，至少会被送达一次。也就是说，<strong>不允许丢消息，但是允许有少量重复消息</strong>出现。</li>
<li><strong>Exactly once</strong>：恰好一次。消息在传递时，只会被送达一次，<strong>不允许丢失也不允许重复</strong>，这个是最高的等级。</li>
</ul>
<p>现在常用的绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka 都是这样。也就是说，消息队列很难保证消息不重复。</p>
<p>一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性。一个幂等操作的特点是，<strong>其任意多次执行所产生的影响均与一次执行的影响相同。</strong></p>
<p>如果我们系统消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题了，因为同一条消息，消费一次和消费多次对系统的影响是完全一样的。也就可以认为，消费多次等于消费一次。</p>
<p>从对系统的影响结果来说：<strong>At least once + 幂等消费 &#x3D; Exactly once。</strong></p>
<p>常用的设计幂等操作的方法：</p>
<ol>
<li><strong>利用数据库的唯一约束实现幂等</strong></li>
<li><strong>为更新的数据设置前置条件</strong>：设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。</li>
<li><strong>记录并检查操作</strong>：在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。——此处涉及分布式 ID 知识点，可以使用类似 GUID、雪花算法 等方式来实现</li>
</ol>
<h2 id="消息积压了该如何处理？"><a href="#消息积压了该如何处理？" class="headerlink" title="消息积压了该如何处理？"></a>消息积压了该如何处理？</h2><p>在使用消息队列的系统中，对于性能的优化，主要体现在生产者和消费者这一收一发两部分的业务逻辑中。对于消息队列本身的性能，不需要太关注。</p>
<p>主要原因是，对于绝大多数使用消息队列的业务来说，消息队列本身的处理能力要远大于业务系统的处理能力。主流消息队列的单个节点，消息收发的性能可以达到每秒钟处理几万至几十万条消息的水平，还可以通过水平扩展 Broker 的实例数成倍地提升处理能力。</p>
<p>而一般的业务系统需要处理的业务逻辑远比消息队列要复杂，单个节点每秒钟可以处理几百到几千次请求，已经可以算是性能非常好的了。所以，对于消息队列的性能优化，我们更关注的是，<strong>在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。</strong></p>
<h3 id="发送端性能优化"><a href="#发送端性能优化" class="headerlink" title="发送端性能优化"></a>发送端性能优化</h3><p><strong>发送消息的性能上不去，你需要优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的</strong>。对于发送消息的业务逻辑，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能。</p>
<h3 id="消费端性能优化"><a href="#消费端性能优化" class="headerlink" title="消费端性能优化"></a>消费端性能优化</h3><p>如果消费的速度跟不上生产消息的速度，就会造成消息积压。即供大于求。</p>
<p><strong>一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行。</strong></p>
<p>消费端的性能优化除了优化消费业务逻辑以外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。特别需要注意的一点是，<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。</strong>如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。</p>
<h3 id="消息积压的处理"><a href="#消息积压的处理" class="headerlink" title="消息积压的处理"></a>消息积压的处理</h3><p>需要先分析消息积压的原因：是发送变快了，还是消费变慢了。大部分消息队列都内置了监控的功能，只要通过监控数据，很容易确定是哪种原因。</p>
<p>如果是因为促销或抢购等原因，导致消息陡增，短时间内不太可能优化消费端的代码来提升消费性能，唯一的方法是通过扩容消费端的实例数来提升总体的消费能力。</p>
<p>如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。</p>
<p>如果监控到消费变慢了，你需要检查你的消费实例，分析一下是什么原因导致消费变慢。优先检查一下日志是否有大量的消费错误，如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在什么地方不动了，比如触发了死锁或者卡在等待某些资源上了。</p>
<h2 id="学习开源代码该如何入手？"><a href="#学习开源代码该如何入手？" class="headerlink" title="学习开源代码该如何入手？"></a>学习开源代码该如何入手？</h2><p>（1）先看官方文档，了解关键点：</p>
<ul>
<li>这个项目是什么</li>
<li>这个项目有什么用</li>
<li>这个项目如何使用</li>
<li>这个项目适用于什么场景</li>
<li>这个项目有哪些优点、缺点</li>
<li>。。。</li>
</ul>
<p>（2）由点及面的阅读源码</p>
<p>不要泛泛而读，容易迷失。</p>
<p>最好带着目的性，带着问题去阅读源码，最好是带着问题的答案去读源码</p>
<h2 id="如何使用异步设计提升系统性能？"><a href="#如何使用异步设计提升系统性能？" class="headerlink" title="如何使用异步设计提升系统性能？"></a>如何使用异步设计提升系统性能？</h2><p>异步编程，可以减少或者避免线程等待，从而提高处理速度。但是，其增加了程序复杂度，应酌情使用。</p>
<h2 id="如何实现高性能的异步网络传输？"><a href="#如何实现高性能的异步网络传输？" class="headerlink" title="如何实现高性能的异步网络传输？"></a>如何实现高性能的异步网络传输？</h2><p>系统一般可以分为 IO 密集型应用和计算密集型应用。</p>
<p>大多数业务系统都属于 IO 密集型应用。最常用的 IO 资源有磁盘 IO 和带宽 IO。由于 IO 相较于内存计算，耗时较高，所以往往成为性能优化的关键。</p>
<p>提升 IO 效率的关键在于减少 IO 等待时间，在大量连接请求的时候，如果单线程，显然阻塞时间较长，所以，一般应采用并发 IO 模型。但是，线程数过多时，线程本身造成的 CPU 上下文切换，竞态造成的冲突都会造成额外的开销，导致 CPU 负载升高，从而降低系统整体性能。所以，理想的 IO 模型应该是一个能够复用少量线程的并发 IO 模型。这个模型的当前答案就是 NIO，其最具代表性的框架就是 Netty。其核心原理就是通过多路复用，来提升 IO 效率。</p>
<h2 id="序列化与反序列化：如何通过网络传输结构化的数据？"><a href="#序列化与反序列化：如何通过网络传输结构化的数据？" class="headerlink" title="序列化与反序列化：如何通过网络传输结构化的数据？"></a>序列化与反序列化：如何通过网络传输结构化的数据？</h2><p>略</p>
<h2 id="传输协议：应用程序之间对话的语言"><a href="#传输协议：应用程序之间对话的语言" class="headerlink" title="传输协议：应用程序之间对话的语言"></a>传输协议：应用程序之间对话的语言</h2><p>传输协议的目的，在于定义一种信息规则，使得收发双方能够互相交流。传输协议并没有什么必须遵循的规范，能满足需要即可。复杂的协议可以如网络协议报文一样，定义为 TLV 结构。</p>
<h2 id="内存管理：如何避免内存溢出和频繁的垃圾回收？"><a href="#内存管理：如何避免内存溢出和频繁的垃圾回收？" class="headerlink" title="内存管理：如何避免内存溢出和频繁的垃圾回收？"></a>内存管理：如何避免内存溢出和频繁的垃圾回收？</h2><p>略</p>
<h2 id="Kafka-如何实现高性能-IO？"><a href="#Kafka-如何实现高性能-IO？" class="headerlink" title="Kafka 如何实现高性能 IO？"></a>Kafka 如何实现高性能 IO？</h2><p><strong>使用批量消息提升服务端处理能力</strong></p>
<p><strong>使用顺序读写提升磁盘 IO 性能</strong></p>
<p><strong>利用 PageCache 加速消息读写</strong></p>
<ul>
<li>PageCache 就是操作系统在内存中给磁盘上的文件建立的缓存。调用系统的 API 读写文件的时候，不会直接去读写磁盘上的文件，应用程序实际操作的都是 PageCache，也就是文件在内存中缓存的副本。</li>
<li>应用程序在写入文件的时候，操作系统会先把数据写入到内存中的 PageCache，然后再一批一批地写到磁盘上。读取文件的时候，也是从 PageCache 中来读取数据，这时候会出现两种可能情况。一种是 PageCache 中有数据，那就直接读取，这样就节省了从磁盘上读取数据的时间；另一种情况是，PageCache 中没有数据，这时候操作系统会引发一个缺页中断，应用程序的读取线程会被阻塞，操作系统把数据从文件中复制到 PageCache 中，然后应用程序再从 PageCache 中继续把数据读出来，这时会真正读一次磁盘上的文件，这个读的过程就会比较慢。</li>
<li>用户的应用程序在使用完某块 PageCache 后，操作系统并不会立刻就清除这个 PageCache，而是尽可能地利用空闲的物理内存保存这些 PageCache，除非系统内存不够用，操作系统才会清理掉一部分 PageCache。清理的策略一般是 LRU 或它的变种算法，这个算法我们不展开讲，它保留 PageCache 的逻辑是：优先保留最近一段时间最常使用的那些 PageCache。</li>
<li>Kafka 在读写消息文件的时候，充分利用了 PageCache 的特性。一般来说，消息刚刚写入到服务端就会被消费，按照 LRU 的“优先清除最近最少使用的页”这种策略，读取的时候，对于这种刚刚写入的 PageCache，命中的几率会非常高。也就是说，大部分情况下，消费读消息都会命中 PageCache，带来的好处有两个：一个是读取的速度会非常快，另外一个是，给写入消息让出磁盘的 IO 资源，间接也提升了写入的性能。</li>
</ul>
<p><strong>零拷贝技术</strong></p>
<p>在服务端，处理消费的大致逻辑是这样的：</p>
<ul>
<li>首先，从文件中找到消息数据，读到内存中；</li>
<li>然后，把消息通过网络发给客户端。</li>
</ul>
<p>这个过程中，数据实际上做了 2 次或者 3 次复制：</p>
<ol>
<li>从文件复制数据到 PageCache 中，如果命中 PageCache，这一步可以省掉；</li>
<li>从 PageCache 复制到应用程序的内存空间中，也就是我们可以操作的对象所在的内存；</li>
<li>从应用程序的内存空间复制到 Socket 的缓冲区，这个过程就是我们调用网络应用框架的 API 发送数据的过程。</li>
</ol>
<p>Kafka 使用零拷贝技术可以把这个复制次数减少一次，上面的 2、3 步骤两次复制合并成一次复制。直接从 PageCache 中把数据复制到 Socket 缓冲区中，这样不仅减少一次数据复制，更重要的是，由于不用把数据复制到用户内存空间，DMA 控制器可以直接完成数据复制，不需要 CPU 参与，速度更快。</p>
<h2 id="缓存策略：如何使用缓存来减少磁盘-IO？"><a href="#缓存策略：如何使用缓存来减少磁盘-IO？" class="headerlink" title="缓存策略：如何使用缓存来减少磁盘 IO？"></a>缓存策略：如何使用缓存来减少磁盘 IO？</h2><p>略</p>
<h2 id="如何正确使用锁保护共享数据，协调异步线程？"><a href="#如何正确使用锁保护共享数据，协调异步线程？" class="headerlink" title="如何正确使用锁保护共享数据，协调异步线程？"></a>如何正确使用锁保护共享数据，协调异步线程？</h2><p>略</p>
<h2 id="如何用硬件同步原语（CAS）替代锁？"><a href="#如何用硬件同步原语（CAS）替代锁？" class="headerlink" title="如何用硬件同步原语（CAS）替代锁？"></a>如何用硬件同步原语（CAS）替代锁？</h2><p>略</p>
<h2 id="数据压缩：时间换空间的游戏"><a href="#数据压缩：时间换空间的游戏" class="headerlink" title="数据压缩：时间换空间的游戏"></a>数据压缩：时间换空间的游戏</h2><p><strong>数据压缩不仅能节省存储空间，还可以用于提升网络传输性能。</strong></p>
<p>压缩和解压的操作都是计算密集型的操作，非常耗费 CPU 资源。如果你的应用处理业务逻辑就需要耗费大量的 CPU 资源，就不太适合再进行压缩和解压。数据压缩，它本质上是用 CPU 资源换取存储资源，或者说是用压缩解压的时间来换取存储的空间，这个买卖是不是划算，需要根据实际情况先衡量一下。</p>
<p>目前常用的压缩算法包括：ZIP，GZIP，SNAPPY，LZ4 等等。在选择压缩算法的时候，需要综合考虑压缩时间和压缩率两个因素，被压缩数据的内容也是影响压缩时间和压缩率的重要因素，必要的时候可以先用业务数据做一个压缩测试，这样有助于选择最合适的压缩算法。一般来说，压缩率越高的算法，压缩耗时也越高。如果是对性能要求高的系统，可以选择压缩速度快的算法，比如 LZ4；如果需要更高的压缩比，可以考虑 GZIP 或者压缩率更高的 XZ 等算法。</p>
<p>另外一个影响压缩率的重要因素是压缩分段的大小，你需要根据业务情况选择一个合适的分段策略，在保证不错的压缩率的前提下，尽量减少解压浪费。</p>
<p>Kafka 在生产者上，对每批消息进行压缩，批消息在服务端不解压，消费者在收到消息之后再进行解压。简单地说，Kafka 的压缩和解压都是在客户端完成的。</p>
<h2 id="RocketMQ-Producer-源码分析：消息生产的实现过程"><a href="#RocketMQ-Producer-源码分析：消息生产的实现过程" class="headerlink" title="RocketMQ Producer 源码分析：消息生产的实现过程"></a>RocketMQ Producer 源码分析：消息生产的实现过程</h2><p>Producer 中包含的几个核心的服务都是有状态的，在 Producer 启动时，在 MQClientInstance 这个类中来统一来启动。在发送消息的流程中，RocketMQ 分了三种发送方式：单向、同步和异步，这三种发送方式对应的发送流程基本是相同的，同步和异步发送是由已经封装好的 MQClientAPIImpl 类来分别实现的。</p>
<p>对于我们在分析代码中提到的几个重要的业务逻辑实现类，你最好能记住这几个类和它的功能，包括 ：DefaultMQProducerImpl 封装了大部分 Producer 的业务逻辑，MQClientInstance 封装了客户端一些通用的业务逻辑，MQClientAPIImpl 封装了客户端与服务端的 RPC，NettyRemotingClient 实现了底层网络通信。</p>
<h2 id="Kafka-Consumer-源码分析：消息消费的实现过程"><a href="#Kafka-Consumer-源码分析：消息消费的实现过程" class="headerlink" title="Kafka Consumer 源码分析：消息消费的实现过程"></a>Kafka Consumer 源码分析：消息消费的实现过程</h2><p>Kafka 消费模型的几个要点：</p>
<ul>
<li>Kafka 的每个 Consumer（消费者）实例属于一个 ConsumerGroup（消费组）；</li>
<li>在消费时，ConsumerGroup 中的每个 Consumer 独占一个或多个 Partition（分区）；</li>
<li>对于每个 ConsumerGroup，在任意时刻，每个 Partition 至多有 1 个 Consumer 在消费；</li>
<li>每个 ConsumerGroup 都有一个 Coordinator(协调者）负责分配 Consumer 和 Partition 的对应关系，当 Partition 或是 Consumer 发生变更是，会触发 reblance（重新分配）过程，重新分配 Consumer 与 Partition 的对应关系；</li>
<li>Consumer 维护与 Coordinator 之间的心跳，这样 Coordinator 就能感知到 Consumer 的状态，在 Consumer 故障的时候及时触发 rebalance。</li>
</ul>
<p>发送请求时，构建 Request 对象，暂存入发送队列，但不立即发送，而是等待合适的时机批量发送。并且，用回调或者 RequestFeuture 方式，预先定义好如何处理响应的逻辑。在收到 Broker 返回的响应之后，也不会立即处理，而是暂存在队列中，择机处理。那这个择机策略就比较复杂了，有可能是需要读取响应的时候，也有可能是缓冲区满了或是时间到了，都有可能触发一次真正的网络请求，也就是在 poll() 方法中发送所有待发送 Request 并处理所有 Response。</p>
<h2 id="Kafka-和-RocketMQ-的消息复制实现的差异点在哪？"><a href="#Kafka-和-RocketMQ-的消息复制实现的差异点在哪？" class="headerlink" title="Kafka 和 RocketMQ 的消息复制实现的差异点在哪？"></a>Kafka 和 RocketMQ 的消息复制实现的差异点在哪？</h2><p>如果要确保数据一致性，必须采用“主 - 从”的复制方式。</p>
<p>在“主 - 从”模式下，数据先写入到主节点上，从节点只从主节点上复制数据，如果出现主从数据不一致的情况，必须以主节点上的数据为准。</p>
<h3 id="RocketMQ-如何实现复制"><a href="#RocketMQ-如何实现复制" class="headerlink" title="RocketMQ 如何实现复制"></a>RocketMQ 如何实现复制</h3><p>RocketMQ 提供新、老两种复制方式：传统的主从模式和新的基于 Dledger 的复制方式。传统的主从模式性能更好，但灵活性和可用性稍差，而基于 Dledger 的复制方式，在 Broker 故障的时候可以自动选举出新节点，可用性更好，性能稍差，并且资源利用率更低一些。</p>
<p>RocketMQ 引入 Dledger，通过 Dledger 来完成复制。Dledger 在写入消息的时候，要求至少消息复制到半数以上的节点之后，才给客户端返回写入成功，并且它是支持通过选举来动态切换主节点的。</p>
<h3 id="Kafka-是如何实现复制的"><a href="#Kafka-是如何实现复制的" class="headerlink" title="Kafka 是如何实现复制的"></a>Kafka 是如何实现复制的</h3><p>Kafka 中，复制的基本单位是分区。每个分区的几个副本之间，构成一个小的复制集群，Broker 只是这些分区副本的容器，所以 Kafka 的 Broker 是不分主从的。</p>
<p>分区的多个副本中也是采用一主多从的方式。Kafka 在写入消息的时候，采用的也是异步复制的方式。消息在写入到主节点之后，并不会马上返回写入成功，而是等待足够多的节点都复制成功后再返回。Kafka 为这个“足够多”创造了一个专有名词：ISR（In Sync Replicas)，翻译过来就是“保持数据同步的副本”。ISR 的数量是可配的，但需要注意的是，这个 ISR 中是包含主节点的。</p>
<p>Kafka 使用 ZooKeeper 来监控每个分区的多个节点，如果发现某个分区的主节点宕机了，Kafka 会利用 ZooKeeper 来选出一个新的主节点，这样解决了可用性的问题。选举的时候，会从所有 ISR 节点中来选新的主节点，这样可以保证数据一致性。</p>
<h3 id="RocketMQ-客户端如何在集群中找到正确的节点？"><a href="#RocketMQ-客户端如何在集群中找到正确的节点？" class="headerlink" title="RocketMQ 客户端如何在集群中找到正确的节点？"></a>RocketMQ 客户端如何在集群中找到正确的节点？</h3><p>NameServer 在集群中起到的一个核心作用就是，为客户端提供路由信息，帮助客户端找到对应的 Broker。每个 NameServer 节点上都保存了集群所有 Broker 的路由信息，可以独立提供服务。Broker 会与所有 NameServer 节点建立长连接，定期上报 Broker 的路由信息。客户端会选择连接某一个 NameServer 节点，定期获取订阅主题的路由信息，用于 Broker 寻址。</p>
<p>不仅仅是 RocketMQ，任何一个弹性分布式集群，都需要一个类似于 NameServer 服务，来帮助访问集群的客户端寻找集群中的节点，这个服务一般称为 NamingService。</p>
<p>在 RocketMQ 中，NameServer 是一个独立的进程，为 Broker、生产者和消费者提供服务。NameServer 最主要的功能就是，为客户端提供寻址服务，协助客户端找到主题对应的 Broker 地址。此外，NameServer 还负责监控每个 Broker 的存活状态。</p>
<p>NameServer 支持只部署一个节点，也支持部署多个节点组成一个集群，这样可以避免单点故障。在集群模式下，NameServer 各节点之间是不需要任何通信的，也不会通过任何方式互相感知，每个节点都可以独立提供全部服务。</p>
<h3 id="NameServer-的总体结构"><a href="#NameServer-的总体结构" class="headerlink" title="NameServer 的总体结构"></a>NameServer 的总体结构</h3><ul>
<li><strong>NamesrvStartup</strong>：程序入口。</li>
<li><strong>NamesrvController</strong>：NameServer 的总控制器，负责所有服务的生命周期管理。</li>
<li><strong>RouteInfoManager</strong>：NameServer 最核心的实现类，负责保存和管理集群路由信息。</li>
<li><strong>BrokerHousekeepingService</strong>：监控 Broker 连接状态的代理类。</li>
<li><strong>DefaultRequestProcessor</strong>：负责处理客户端和 Broker 发送过来的 RPC 请求的处理器。</li>
<li><strong>ClusterTestRequestProcessor</strong>：用于测试的请求处理器。</li>
</ul>
<p>NameServer 的所有核心功能都是在 RouteInfoManager 这个类中实现的。RouteInfoManager 这个类中保存了所有的路由信息，这些路由信息都是保存在内存中，并且没有持久化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrokerData</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BrokerData&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-的协调服务-ZooKeeper：实现分布式系统的“瑞士军刀”"><a href="#Kafka-的协调服务-ZooKeeper：实现分布式系统的“瑞士军刀”" class="headerlink" title="Kafka 的协调服务 ZooKeeper：实现分布式系统的“瑞士军刀”"></a>Kafka 的协调服务 ZooKeeper：实现分布式系统的“瑞士军刀”</h2><p>ZooKeeper 是一个分布式的协调服务，它的核心服务是一个高可用、高可靠的一致性存储，在此基础上，提供了包括读写元数据、节点监控、选举、节点间通信和分布式锁等很多功能，<strong>这些功能可以极大方便我们快速开发一个分布式的集群系统。</strong></p>
<p>ZooKeeper 的使用注意点：</p>
<ol>
<li>不要往 ZooKeeper 里面写入大量数据，它不是一个真正意义上的存储系统，只适合存放少量的数据。依据服务器配置的不同，ZooKeeper 在写入超过几百 MB 数据之后，性能和稳定性都会严重下降。</li>
<li>不要让业务集群的可用性依赖于 ZooKeeper 的可用性，什么意思呢？你的系统可以使用 Zookeeper，但你要留一手，要考虑如果 Zookeeper 集群宕机了，你的业务集群最好还能提供服务。因为 ZooKeeper 的选举过程是比较慢的，而它对网络的抖动又比较敏感，一旦触发选举，这段时间内的 ZooKeeper 是不能提供任何服务的。</li>
</ol>
<p>Kafka 主要使用 ZooKeeper 来保存它的元数据、监控 Broker 和分区的存活状态，并利用 ZooKeeper 来进行选举。</p>
<p>Kafka 在 ZooKeeper 中保存的元数据，主要就是 Broker 的列表和主题分区信息两棵树。这份元数据同时也被缓存到每一个 Broker 中。客户端并不直接和 ZooKeeper 来通信，而是在需要的时候，通过 RPC 请求去 Broker 上拉取它关心的主题的元数据，然后保存到客户端的元数据缓存中，以便支撑客户端生产和消费</p>
<h2 id="RocketMQ-与-Kafka-中如何实现事务？"><a href="#RocketMQ-与-Kafka-中如何实现事务？" class="headerlink" title="RocketMQ 与 Kafka 中如何实现事务？"></a>RocketMQ 与 Kafka 中如何实现事务？</h2><p>Kafka 和 RocketMQ 都是基于两阶段提交来实现的事务，都利用了特殊的主题中的队列和分区来记录事务日志。</p>
<p>不同之处在于对处于事务中的消息的处理方式，RocketMQ 是把这些消息暂存在一个特殊的队列中，待事务提交后再移动到业务队列中；而 Kafka 直接把消息放到对应的业务分区中，配合客户端过滤来暂时屏蔽进行中的事务消息。</p>
<p>RocketMQ 和 Kafka 的事务，它们的适用场景是不一样的，RocketMQ 的事务适用于解决本地事务和发消息的数据一致性问题，而 Kafka 的事务则是用于实现它的 Exactly Once 机制，应用于实时计算的场景中。</p>
<h2 id="MQTT-协议：如何支持海量的在线-IoT-设备"><a href="#MQTT-协议：如何支持海量的在线-IoT-设备" class="headerlink" title="MQTT 协议：如何支持海量的在线 IoT 设备?"></a>MQTT 协议：如何支持海量的在线 IoT 设备?</h2><p>MQTT 是专门为物联网设备设计的一套标准的通信协议。这套协议在消息模型和功能上与普通的消息队列协议是差不多的，最大的区别在于应用场景不同。在物联网应用场景中，IoT 设备性能差，网络连接不稳定。服务端面临的挑战主要是，需要支撑海量的客户端和主题。</p>
<p>已有的开源的 MQTT 产品，对于协议的支持都不错，在客户端数量小于十万级别的情况下，可以选择。对于海量客户端的场景，服务端必须使用集群来支撑，可以选择收费的云服务和企业版产品。也可以选择自行来构建 MQTT 集群。</p>
<p>自行构建集群，最关键的技术点就是，通过前置的 Proxy 集群来解决海量连接、会话管理和海量主题这三个问题。前置 Proxy 负责在 Broker 和客户端之间转发消息，通过这种方式，将海量客户端连接收敛为少量的 Proxy 与 Broker 之间的连接，解决了海量客户端连接数的问题。维护会话的实现原理，和 Tomcat 维护 HTTP 会话是一样的。对于海量主题，可以在后端部署多组 Broker 小集群，每个小集群分担一部分主题这样的方式来解决。</p>
<h2 id="Pulsar-的存储计算分离设计：全新的消息队列设计思路"><a href="#Pulsar-的存储计算分离设计：全新的消息队列设计思路" class="headerlink" title="Pulsar 的存储计算分离设计：全新的消息队列设计思路"></a>Pulsar 的存储计算分离设计：全新的消息队列设计思路</h2><p>Pulsar 和其他消息队列最大的区别是，它采用了存储计算分离的设计。存储消息的职责从 Broker 中分离出来，交给专门的 BookKeeper 存储集群。这样 Broker 就变成了无状态的节点，在集群调度和故障恢复方面更加简单灵活。</p>
<p>存储计算分离是一种设计思想，它将系统的存储职责和计算职责分离开，存储节点只负责数据存储，而计算节点只负责计算，计算节点是无状态的。无状态的计算节点，具有易于开发、调度灵活的优点，故障转移和恢复也更加简单快速。这种设计的缺点是，系统总体的复杂度更高，性能也更差。不过对于大部分分布式的业务系统来说，由于它不需要自己开发存储系统，采用存储计算分离的设计，既可以充分利用这种设计的优点，整个系统也不会因此变得过于复杂，综合评估优缺点，利大于弊，更加划算。</p>
<h2 id="流计算与消息（一）：通过-Flink-理解流计算的原理"><a href="#流计算与消息（一）：通过-Flink-理解流计算的原理" class="headerlink" title="流计算与消息（一）：通过 Flink 理解流计算的原理"></a>流计算与消息（一）：通过 Flink 理解流计算的原理</h2><p>Flink 分析计算任务之后生成 JobGraph，JobGraph 是一个有向无环图，数据流过这个图中的节点，在每个节点进行计算和变换，最终流出有向无环图就完成了计算。JobGraph 中的每个节点是一个 Task，Task 是可以并行执行的，每个线程就是一个 SubTask。SubTask 被 JobManager 分配给某个 TaskManager，在 TaskManager 进程中的一个线程中执行。</p>
<h2 id="流计算与消息（二）：在流计算中使用-Kafka-链接计算任务"><a href="#流计算与消息（二）：在流计算中使用-Kafka-链接计算任务" class="headerlink" title="流计算与消息（二）：在流计算中使用 Kafka 链接计算任务"></a>流计算与消息（二）：在流计算中使用 Kafka 链接计算任务</h2><p>端到端 Exactly Once 语义，可以保证在分布式系统中，每条数据不多不少只被处理一次。在流计算中，因为数据重复会导致计算结果错误，所以 Exactly Once 在流计算场景中尤其重要。Kafka 和 Flink 都提供了保证 Exactly Once 的特性，配合使用可以实现端到端的 Exactly Once 语义。</p>
<p>在 Flink 中，如果节点出现故障，可以自动重启计算任务，重新分配计算节点来保证系统的可用性。配合 CheckPoint 机制，可以保证重启后任务的状态恢复到最后一次 CheckPoint，然后从 CheckPoint 中记录的恢复位置继续读取数据进行计算。Flink 通过一个巧妙的 Barrier 使 CheckPoint 中恢复位置和各节点状态完全对应。</p>
<p>Kafka 的 Exactly Once 语义是通过它的事务和生产幂等两个特性来共同实现的。在配合 Flink 的时候，每个 Flink 的 CheckPoint 对应一个 Kafka 事务，只要保证 CheckPoint 和 Kafka 事务同步提交就可以实现端到端的 Exactly Once，Flink 通过“二阶段提交”这个分布式事务的经典算法来保证 CheckPoint 和 Kafka 事务状态的一致性。</p>
<h2 id="主流消息队列都是如何存储消息的？"><a href="#主流消息队列都是如何存储消息的？" class="headerlink" title="主流消息队列都是如何存储消息的？"></a>主流消息队列都是如何存储消息的？</h2><p>在所有的存储系统中，消息队列的存储可能是最简单的。每个主题包含若干个分区，每个分区其实就是一个 WAL（Write Ahead Log），写入的时候只能尾部追加，不允许修改。读取的时候，根据一个索引序号进行查询，然后连续顺序往下读。</p>
<h3 id="Kafka-存储消息结构"><a href="#Kafka-存储消息结构" class="headerlink" title="Kafka 存储消息结构"></a>Kafka 存储消息结构</h3><p>Kafka 的存储以 Partition 为单位，每个 Partition 包含一组消息文件（Segment file）和一组索引文件（Index），并且消息文件和索引文件一一对应，具有相同的文件名（但文件扩展名不一样），文件名就是这个文件中第一条消息的索引序号。</p>
<p>每个索引中保存索引序号（也就是这条消息是这个分区中的第几条消息）和对应的消息在消息文件中的绝对位置。在索引的设计上，Kafka 采用的是稀疏索引，为了节省存储空间，它不会为每一条消息都创建索引，而是每隔几条消息创建一条索引。</p>
<p>写入消息的时候非常简单，就是在消息文件尾部连续追加写入，一个文件写满了再写下一个文件。查找消息时，首先根据文件名找到所在的索引文件，然后用二分法遍历索引文件内的索引，在里面找到离目标消息最近的索引，再去消息文件中，找到这条最近的索引指向的消息位置，从这个位置开始顺序遍历消息文件，找到目标消息。</p>
<p>可以看到，寻址过程还是需要一定时间的。一旦找到消息位置后，就可以批量顺序读取，不必每条消息都要进行一次寻址。</p>
<h3 id="RocketMQ-存储消息结构"><a href="#RocketMQ-存储消息结构" class="headerlink" title="RocketMQ 存储消息结构"></a>RocketMQ 存储消息结构</h3><p>RocketMQ 的存储以 Broker 为单位。它的存储也是分为消息文件和索引文件，但是在 RocketMQ 中，每个 Broker 只有一组消息文件，它把在这个 Broker 上的所有主题的消息都存在这一组消息文件中。索引文件和 Kafka 一样，是按照主题和队列分别建立的，每个队列对应一组索引文件，这组索引文件在 RocketMQ 中称为 ConsumerQueue。RocketMQ 中的索引是定长稠密索引，它为每一条消息都建立索引，每个索引的长度（注意不是消息长度）是固定的 20 个字节。</p>
<p>写入消息的时候，Broker 上所有主题、所有队列的消息按照自然顺序追加写入到同一个消息文件中，一个文件写满了再写下一个文件。查找消息的时候，可以直接根据队列的消息序号，计算出索引的全局位置（索引序号 x 索引固定长度 20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。可以看到，这里两次寻址都是绝对位置寻址，比 Kafka 的查找是要快的。</p>
<h3 id="Kafka-和-RocketMQ-的存储结构比较"><a href="#Kafka-和-RocketMQ-的存储结构比较" class="headerlink" title="Kafka 和 RocketMQ 的存储结构比较"></a>Kafka 和 RocketMQ 的存储结构比较</h3><p>对比这两种存储结构，你可以看到它们有很多共通的地方，都是采用消息文件 + 索引文件的存储方式，索引文件的名字都是第一条消息的索引序号，索引中记录了消息的位置等等。</p>
<p>在消息文件的存储粒度上，Kafka 以分区为单位，粒度更细，优点是更加灵活，很容易进行数据迁移和扩容。RocketMQ 以 Broker 为单位，较粗的粒度牺牲了灵活性，带来的好处是，在写入的时候，同时写入的文件更少，有更好的批量（不同主题和分区的数据可以组成一批一起写入），更多的顺序写入，尤其是在 Broker 上有很多主题和分区的情况下，有更好的写入性能。</p>
<p>大多数场景下，这两种存储设计的差异其实并不明显，都可以满足需求。但是在某些极限场景下，依然会体现出它们设计的差异。比如，在一个 Broker 上有上千个活动主题的情况下，RocketMQ 的写入性能就会体现出优势。再比如，如果我们的消息都是几个、十几个字节的小消息，但是消息的数量很多，这时候 Kafka 的稀疏索引设计就能节省非常多的存储空间。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100032301">消息队列高手课</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/40aa36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/40aa36/" class="post-title-link" itemprop="url">如何阅读源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-07 14:05:51" itemprop="dateCreated datePublished" datetime="2022-05-07T14:05:51+08:00">2022-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">编程范式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>27</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="XXX"><a href="#XXX" class="headerlink" title="XXX"></a>XXX</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-XXX"><a href="#什么是-XXX" class="headerlink" title="什么是 XXX"></a>什么是 XXX</h3><h3 id="XXX-有什么用"><a href="#XXX-有什么用" class="headerlink" title="XXX 有什么用"></a>XXX 有什么用</h3><h2 id="XXX-原理"><a href="#XXX-原理" class="headerlink" title="XXX 原理"></a>XXX 原理</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1ae1ca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1ae1ca/" class="post-title-link" itemprop="url">SQL 语法高级特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-27 22:13:55" itemprop="dateCreated datePublished" datetime="2022-04-27T22:13:55+08:00">2022-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SQL-语法高级特性"><a href="#SQL-语法高级特性" class="headerlink" title="SQL 语法高级特性"></a>SQL 语法高级特性</h1><blockquote>
<p>本文针对关系型数据库的基本语法。限于篇幅，本文侧重说明用法，不会展开讲解特性、原理。</p>
<p>本文语法主要针对 Mysql，但大部分的语法对其他关系型数据库也适用。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200115160512.png" alt="img"></p>
<h2 id="连接和组合"><a href="#连接和组合" class="headerlink" title="连接和组合"></a>连接和组合</h2><h3 id="连接（JOIN）"><a href="#连接（JOIN）" class="headerlink" title="连接（JOIN）"></a>连接（JOIN）</h3><blockquote>
<p>连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</p>
</blockquote>
<p>如果一个 <code>JOIN</code> 至少有一个公共字段并且它们之间存在关系，则该 <code>JOIN</code> 可以在两个或多个表上工作。</p>
<p><code>JOIN</code> 保持基表（结构和数据）不变。<strong>连接可以替换子查询，并且比子查询的效率一般会更快</strong>。</p>
<p><code>JOIN</code> 有两种连接类型：内连接和外连接。</p>
<div align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/mysql/sql-join.png" alt="sql-join">
</div>

<h4 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h4><p>内连接又称等值连接，<strong>使用 <code>INNER JOIN</code> 关键字</strong>。在没有条件语句的情况下<strong>返回笛卡尔积</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure>

<h5 id="自连接（-）"><a href="#自连接（-）" class="headerlink" title="自连接（=）"></a>自连接（<code>=</code>）</h5><p>自连接可以看成内连接的一种，只是<strong>连接的表是自身</strong>而已。<strong>自然连接是把同名列通过 <code>=</code> 连接起来</strong>的，同名列可以有多个。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers c1, customers c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name <span class="operator">=</span> c2.cust_name</span><br><span class="line"><span class="keyword">AND</span> c2.cust_contact <span class="operator">=</span> <span class="string">&#x27;Jim Jones&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="自然连接（NATURAL-JOIN）"><a href="#自然连接（NATURAL-JOIN）" class="headerlink" title="自然连接（NATURAL JOIN）"></a>自然连接（NATURAL JOIN）</h5><p>内连接提供连接的列，而自然连接<strong>自动连接所有同名列</strong>。自然连接使用 <code>NATURAL JOIN</code> 关键字。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Customers;</span><br></pre></td></tr></table></figure>

<h4 id="外连接（OUTER-JOIN）"><a href="#外连接（OUTER-JOIN）" class="headerlink" title="外连接（OUTER JOIN）"></a>外连接（OUTER JOIN）</h4><p>外连接返回一个表中的所有行，并且仅返回来自此表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（Mysql 不支持）。</p>
<h5 id="左连接（LEFT-JOIN）"><a href="#左连接（LEFT-JOIN）" class="headerlink" title="左连接（LEFT JOIN）"></a>左连接（LEFT JOIN）</h5><p>左外连接就是保留左表没有关联的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<h5 id="右连接（RIGHT-JOIN）"><a href="#右连接（RIGHT-JOIN）" class="headerlink" title="右连接（RIGHT JOIN）"></a>右连接（RIGHT JOIN）</h5><p>右外连接就是保留右表没有关联的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<h3 id="组合（UNION）"><a href="#组合（UNION）" class="headerlink" title="组合（UNION）"></a>组合（UNION）</h3><blockquote>
<p><code>UNION</code> 运算符<strong>将两个或更多查询的结果组合起来，并生成一个结果集</strong>，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>
</blockquote>
<p><code>UNION</code> 基本规则：</p>
<ul>
<li>所有查询的列数和列顺序必须相同。</li>
<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>
<li>通常返回的列名取自第一个查询。</li>
</ul>
<p>默认会去除相同行，如果需要保留相同行，使用 <code>UNION ALL</code>。</p>
<p>只能包含一个 <code>ORDER BY</code> 子句，并且必须位于语句的最后。</p>
<p>应用场景：</p>
<ul>
<li>在一个查询中从不同的表返回结构数据。</li>
<li>对一个表执行多个查询，按一个查询返回数据。</li>
</ul>
<p>组合查询示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;MI&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="JOIN-vs-UNION"><a href="#JOIN-vs-UNION" class="headerlink" title="JOIN vs UNION"></a>JOIN vs UNION</h3><ul>
<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>
<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>🔔 注意：不同数据库的函数往往各不相同，因此不可移植。本节主要以 Mysql 的函数为例。</p>
</blockquote>
<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>LEFT()</code>、<code>RIGHT()</code></td>
<td align="center">左边或者右边的字符</td>
</tr>
<tr>
<td align="center"><code>LOWER()</code>、<code>UPPER()</code></td>
<td align="center">转换为小写或者大写</td>
</tr>
<tr>
<td align="center"><code>LTRIM()</code>、<code>RTIM()</code></td>
<td align="center">去除左边或者右边的空格</td>
</tr>
<tr>
<td align="center"><code>LENGTH()</code></td>
<td align="center">长度</td>
</tr>
<tr>
<td align="center"><code>SOUNDEX()</code></td>
<td align="center">转换为语音值</td>
</tr>
</tbody></table>
<p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(col1) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;apple&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul>
<li>日期格式：<code>YYYY-MM-DD</code></li>
<li>时间格式：<code>HH:MM:SS</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>AddDate()</code></td>
<td align="center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td align="center"><code>AddTime()</code></td>
<td align="center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="center"><code>CurDate()</code></td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center"><code>CurTime()</code></td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center"><code>Date()</code></td>
<td align="center">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center"><code>DateDiff()</code></td>
<td align="center">计算两个日期之差</td>
</tr>
<tr>
<td align="center"><code>Date_Add()</code></td>
<td align="center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center"><code>Date_Format()</code></td>
<td align="center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center"><code>Day()</code></td>
<td align="center">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center"><code>DayOfWeek()</code></td>
<td align="center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td align="center"><code>Hour()</code></td>
<td align="center">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center"><code>Minute()</code></td>
<td align="center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center"><code>Month()</code></td>
<td align="center">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center"><code>Now()</code></td>
<td align="center">返回当前日期和时间</td>
</tr>
<tr>
<td align="center"><code>Second()</code></td>
<td align="center">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center"><code>Time()</code></td>
<td align="center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center"><code>Year()</code></td>
<td align="center">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> NOW();</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2018</span>-<span class="number">4</span>-<span class="number">14</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN()</td>
<td align="center">正弦</td>
</tr>
<tr>
<td align="center">COS()</td>
<td align="center">余弦</td>
</tr>
<tr>
<td align="center">TAN()</td>
<td align="center">正切</td>
</tr>
<tr>
<td align="center">ABS()</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">SQRT()</td>
<td align="center">平方根</td>
</tr>
<tr>
<td align="center">MOD()</td>
<td align="center">余数</td>
</tr>
<tr>
<td align="center">EXP()</td>
<td align="center">指数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="center">圆周率</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="center">随机数</td>
</tr>
</tbody></table>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>AVG()</code></td>
<td align="center">返回某列的平均值</td>
</tr>
<tr>
<td align="center"><code>COUNT()</code></td>
<td align="center">返回某列的行数</td>
</tr>
<tr>
<td align="center"><code>MAX()</code></td>
<td align="center">返回某列的最大值</td>
</tr>
<tr>
<td align="center"><code>MIN()</code></td>
<td align="center">返回某列的最小值</td>
</tr>
<tr>
<td align="center"><code>SUM()</code></td>
<td align="center">返回某列值之和</td>
</tr>
</tbody></table>
<p><code>AVG()</code> 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><blockquote>
<p><code>GROUP BY</code> 子句将记录分组到汇总行中，<code>GROUP BY</code> 为每个组返回一个记录。</p>
</blockquote>
<p><code>GROUP BY</code> 可以按一列或多列进行分组。</p>
<p><code>GROUP BY</code> 通常还涉及聚合函数：COUNT，MAX，SUM，AVG 等。</p>
<p><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</p>
<p>分组示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<p>分组后排序示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><blockquote>
<p><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。<code>HAVING</code> 要求存在一个 <code>GROUP BY</code> 子句。</p>
</blockquote>
<p><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</p>
<p><code>HAVING</code> vs <code>WHERE</code>：</p>
<ul>
<li><code>WHERE</code> 和 <code>HAVING</code> 都是用于过滤。</li>
<li><code>HAVING</code> 适用于汇总的组记录；而 <code>WHERE</code> 适用于单个记录。</li>
</ul>
<p>使用 <code>WHERE</code> 和 <code>HAVING</code> 过滤数据示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>（以下为 DDL 语句用法）</strong></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p>
<p><strong>MySQL 默认采用隐式提交策略（<code>autocommit</code>）</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>
<p>事务处理指令：</p>
<ul>
<li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li>
<li><code>SAVEPOINT</code> - 指令用于创建保留点。</li>
<li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li>
<li><code>COMMIT</code> - 提交事务。</li>
<li><code>RELEASE SAVEPOINT</code>：删除某个保存点。</li>
<li><code>SET TRANSACTION</code>：设置事务的隔离级别。</li>
</ul>
<p>事务处理示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><hr>
<p><strong>（以下为 DCL 语句用法）</strong></p>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<p>新创建的账户没有任何权限。</p>
<p>账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。</p>
<p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改账户名"><a href="#修改账户名" class="headerlink" title="修改账户名"></a>修改账户名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;newuser&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h3 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="删除权限"><a href="#删除权限" class="headerlink" title="删除权限"></a>删除权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> myuser <span class="operator">=</span> <span class="string">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程的英文是 Stored Procedure。它可以视为一组 SQL 语句的批处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。</p>
<p>定义存储过程的语法格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    需要执行的语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>存储过程定义语句类型：</p>
<ul>
<li><code>CREATE PROCEDURE</code> 用于创建存储过程</li>
<li><code>DROP PROCEDURE</code> 用于删除存储过程</li>
<li><code>ALTER PROCEDURE</code> 用于修改存储过程</li>
</ul>
<h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><p>创建存储过程的要点：</p>
<ul>
<li><code>DELIMITER</code> 用于定义语句的结束符</li>
<li>存储过程的 3 种参数类型：<ul>
<li><code>IN</code>：存储过程的入参</li>
<li><code>OUT</code>：存储过程的出参</li>
<li><code>INPUT</code>：既是存储过程的入参，也是存储过程的出参</li>
</ul>
</li>
<li>流控制语句：<ul>
<li><code>BEGIN…END</code>：<code>BEGIN…END</code> 中间包含了多个语句，每个语句都以（<code>;</code>）号为结束符。</li>
<li><code>DECLARE</code>：<code>DECLARE</code> 用来声明变量，使用的位置在于 <code>BEGIN…END</code> 语句中间，而且需要在其他语句使用之前进行变量的声明。</li>
<li><code>SET</code>：赋值语句，用于对变量进行赋值。</li>
<li><code>SELECT…INTO</code>：把从数据表中查询的结果存放到变量中，也就是为变量赋值。每次只能给一个变量赋值，不支持集合的操作。</li>
<li><code>IF…THEN…ENDIF</code>：条件判断语句，可以在 <code>IF…THEN…ENDIF</code> 中使用 <code>ELSE</code> 和 <code>ELSEIF</code> 来进行条件判断。</li>
<li><code>CASE</code>：<code>CASE</code> 语句用于多条件的分支判断。</li>
</ul>
</li>
</ul>
<p>创建存储过程示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> `proc_adder`;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `proc_adder`(<span class="keyword">IN</span> a <span class="type">int</span>, <span class="keyword">IN</span> b <span class="type">int</span>, <span class="keyword">OUT</span> sum <span class="type">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> c <span class="type">int</span>;</span><br><span class="line">    if a <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> a <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    if b <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> b <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> sum  <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>使用存储过程示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@b</span><span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="keyword">call</span> proc_adder(<span class="number">2</span>,<span class="variable">@b</span>,<span class="variable">@s</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@s</span> <span class="keyword">as</span> sum;</span><br></pre></td></tr></table></figure>

<h3 id="存储过程的利弊"><a href="#存储过程的利弊" class="headerlink" title="存储过程的利弊"></a>存储过程的利弊</h3><p>存储过程的优点：</p>
<ul>
<li><strong>执行效率高</strong>：一次编译多次使用。</li>
<li><strong>安全性强</strong>：在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</li>
<li><strong>可复用</strong>：将代码封装，可以提高代码复用。</li>
<li><strong>性能好</strong><ul>
<li>由于是预先编译，因此具有很高的性能。</li>
<li>一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率。</li>
</ul>
</li>
</ul>
<p>存储过程的缺点：</p>
<ul>
<li><strong>可移植性差</strong>：存储过程不能跨数据库移植。由于不同数据库的存储过程语法几乎都不一样，十分难以维护（不通用）。</li>
<li><strong>调试困难</strong>：只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</li>
<li><strong>版本管理困难</strong>：比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li>
<li><strong>不适合高并发的场景</strong>：高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</li>
</ul>
<blockquote>
<p>_综上，存储过程的优缺点都非常突出，是否使用一定要慎重，需要根据具体应用场景来权衡_。</p>
</blockquote>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><blockquote>
<p>触发器可以视为一种特殊的存储过程。</p>
<p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p>
</blockquote>
<h4 id="触发器特性"><a href="#触发器特性" class="headerlink" title="触发器特性"></a>触发器特性</h4><p>可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p>
<p>MySQL 不允许在触发器中使用 <code>CALL</code> 语句 ，也就是不能调用存储过程。</p>
<p><strong><code>BEGIN</code> 和 <code>END</code></strong></p>
<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>
<blockquote>
<p>🔔 注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p>
<p>这时就会用到 <code>DELIMITER</code> 命令（<code>DELIMITER</code> 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：<code>DELIMITER new_delemiter</code>。<code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code>，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code>，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p>
</blockquote>
<p><strong><code>NEW</code> 和 <code>OLD</code></strong></p>
<ul>
<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>
<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li>
<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>
<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>
<li>使用方法： <code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li>
</ul>
<h4 id="触发器指令"><a href="#触发器指令" class="headerlink" title="触发器指令"></a>触发器指令</h4><blockquote>
<p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p>
</blockquote>
<p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  trigger_statements</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>trigger_name：触发器名</li>
<li>trigger_time: 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>
<li>trigger_event: 触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>
<li>table_name: 触发器的监听目标。指定在哪张表上建立触发器。</li>
<li>FOR EACH ROW: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>
<li>trigger_statements: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>
</ul>
<p>创建触发器示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `trigger_insert_user`</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;add a user&#x27;</span>,  now());</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>查看触发器示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>

<p>删除触发器示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>

<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><blockquote>
<p>游标（CURSOR）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
</blockquote>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的步骤：</p>
<ol>
<li><strong>定义游标</strong>：通过 <code>DECLARE cursor_name CURSOR FOR &lt;语句&gt;</code> 定义游标。这个过程没有实际检索出数据。</li>
<li><strong>打开游标</strong>：通过 <code>OPEN cursor_name</code> 打开游标。</li>
<li><strong>取出数据</strong>：通过 <code>FETCH cursor_name INTO var_name ...</code> 获取数据。</li>
<li><strong>关闭游标</strong>：通过 <code>CLOSE cursor_name</code> 关闭游标。</li>
<li><strong>释放游标</strong>：通过 <code>DEALLOCATE PREPARE</code> 释放游标。</li>
</ol>
<p>游标使用示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> getTotal()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> total <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建接收游标数据的变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sid <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> sname <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">-- 创建总数变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sage <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建结束标志变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">-- 创建游标</span></span><br><span class="line">    <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id,name,age <span class="keyword">from</span> cursor_table <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">30</span>;</span><br><span class="line">    <span class="comment">-- 指定游标循环结束时的返回值</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">SET</span> total <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">OPEN</span> cur;</span><br><span class="line">    <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    WHILE(<span class="keyword">NOT</span> done)</span><br><span class="line">    DO</span><br><span class="line">        <span class="keyword">SET</span> total <span class="operator">=</span> total <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CLOSE</span> cur;</span><br><span class="line">    <span class="keyword">SELECT</span> total;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> getTotal();</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35167240/">《SQL 必知必会》</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/mysql-transaction">『浅入深出』MySQL 中事务的实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CraryPrimitiveMan/p/4206942.html">MySQL 的学习–触发器</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SQL">维基百科词条 - SQL</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sitesbay.com/sql/index">https://www.sitesbay.com/sql/index</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php">SQL Subqueries</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6294778/mysql-quick-breakdown-of-the-types-of-joins">Quick breakdown of the types of joins</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3resource.com/sql/sql-union.php">SQL UNION</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3resource.com/sql/database-security/create-users.php">SQL database security</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenpi/p/5136483.html">Mysql 中的存储过程</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/496a7e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/496a7e/" class="post-title-link" itemprop="url">源码级深度理解 Java SPI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-26 19:11:59" itemprop="dateCreated datePublished" datetime="2022-04-26T19:11:59+08:00">2022-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">高级特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="源码级深度理解-Java-SPI"><a href="#源码级深度理解-Java-SPI" class="headerlink" title="源码级深度理解 Java SPI"></a>源码级深度理解 Java SPI</h1><h2 id="SPI-简介"><a href="#SPI-简介" class="headerlink" title="SPI 简介"></a>SPI 简介</h2><p>SPI 全称 Service Provider Interface，是 Java 提供的，旨在由第三方实现或扩展的 API，它是一种用于动态加载服务的机制。Java 中 SPI 机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p>
<p>Java SPI 有四个要素：</p>
<ul>
<li><strong>SPI 接口</strong>：为服务提供者实现类约定的的接口或抽象类。</li>
<li><strong>SPI 实现类</strong>：实际提供服务的实现类。</li>
<li><strong>SPI 配置</strong>：Java SPI 机制约定的配置文件，提供查找服务实现类的逻辑。配置文件必须置于 <code>META-INF/services</code> 目录中，并且，文件名应与服务提供者接口的完全限定名保持一致。文件中的每一行都有一个实现服务类的详细信息，同样是服务提供者类的完全限定名称。</li>
<li>**<code>ServiceLoader</code>**：Java SPI 的核心类，用于加载 SPI 实现类。 <code>ServiceLoader</code> 中有各种实用方法来获取特定实现、迭代它们或重新加载服务。</li>
</ul>
<h2 id="SPI-示例"><a href="#SPI-示例" class="headerlink" title="SPI 示例"></a>SPI 示例</h2><p>正所谓，实践出真知，我们不妨通过一个具体的示例来看一下，如何使用 Java SPI。</p>
<h3 id="SPI-接口"><a href="#SPI-接口" class="headerlink" title="SPI 接口"></a>SPI 接口</h3><p>首先，需要定义一个 SPI 接口，和普通接口并没有什么差别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataStorage</span> &#123;</span><br><span class="line">    String <span class="title function_">search</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPI-实现类"><a href="#SPI-实现类" class="headerlink" title="SPI 实现类"></a>SPI 实现类</h3><p>假设，我们需要在程序中使用两种不同的数据存储——Mysql 和 Redis。因此，我们需要两个不同的实现类去分别完成相应工作。</p>
<p>Mysql 查询 MOCK 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlStorage</span> <span class="keyword">implements</span> <span class="title class_">DataStorage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">search</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;【Mysql】搜索&quot;</span> + key + <span class="string">&quot;，结果：No&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 查询 MOCK 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisStorage</span> <span class="keyword">implements</span> <span class="title class_">DataStorage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">search</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;【Redis】搜索&quot;</span> + key + <span class="string">&quot;，结果：Yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，定义接口，并实现接口和普通的 Java 接口实现没有任何不同。</p>
<h3 id="SPI-配置"><a href="#SPI-配置" class="headerlink" title="SPI 配置"></a>SPI 配置</h3><p>如果想通过 Java SPI 机制来发现服务，就需要在 SPI 配置中约定好发现服务的逻辑。配置文件必须置于 <code>META-INF/services</code> 目录中，并且，文件名应与服务提供者接口的完全限定名保持一致。文件中的每一行都有一个实现服务类的详细信息，同样是服务提供者类的完全限定名称。以本示例代码为例，其文件名应该为 <code>io.github.dunwu.javacore.spi.DataStorage</code>，文件中的内容如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.spi</span><span class="selector-class">.MysqlStorage</span></span><br><span class="line">io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.spi</span>.RedisStorage</span><br></pre></td></tr></table></figure>

<h3 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h3><p>完成了上面的步骤，就可以通过 <code>ServiceLoader</code> 来加载服务。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpiDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;DataStorage&gt; serviceLoader = ServiceLoader.load(DataStorage.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;============ Java SPI 测试============&quot;</span>);</span><br><span class="line">        serviceLoader.forEach(loader -&gt; System.out.println(loader.search(<span class="string">&quot;Yes Or No&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> Java SPI 测试<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">【Mysql】搜索Yes Or No，结果：No</span><br><span class="line">【Redis】搜索Yes Or No，结果：Yes</span><br></pre></td></tr></table></figure>

<h2 id="SPI-原理"><a href="#SPI-原理" class="headerlink" title="SPI 原理"></a>SPI 原理</h2><p>上文中，我们已经了解 Java SPI 的要素以及使用 Java SPI 的方法。你有没有想过，Java SPI 和普通 Java 接口有何不同，Java SPI 是如何工作的。实际上，Java SPI 机制依赖于 <code>ServiceLoader</code> 类去解析、加载服务。因此，掌握了 <code>ServiceLoader</code> 的工作流程，就掌握了 SPI 的原理。<code>ServiceLoader</code> 的代码本身很精练，接下来，让我们通过走读源码的方式，逐一理解 <code>ServiceLoader</code> 的工作流程。</p>
<h3 id="ServiceLoader-的成员变量"><a href="#ServiceLoader-的成员变量" class="headerlink" title="ServiceLoader 的成员变量"></a>ServiceLoader 的成员变量</h3><p>先看一下 <code>ServiceLoader</code> 类的成员变量，大致有个印象，后面的源码中都会使用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SPI 配置文件目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要被加载的 SPI 服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于加载 SPI 服务的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceLoader 创建时的访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SPI 服务缓存，按实例化的顺序排列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒查询迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServiceLoader-的工作流程"><a href="#ServiceLoader-的工作流程" class="headerlink" title="ServiceLoader 的工作流程"></a>ServiceLoader 的工作流程</h3><p>（1）<code>ServiceLoader.load</code> 静态方法</p>
<p>应用程序加载 Java SPI 服务，都是先调用 <code>ServiceLoader.load</code> 静态方法。<code>ServiceLoader.load</code> 静态方法的作用是：</p>
<ol>
<li>指定类加载 <code>ClassLoader</code> 和访问控制上下文；</li>
<li>然后，重新加载 SPI 服务<ol>
<li>清空缓存中所有已实例化的 SPI 服务</li>
<li>根据 <code>ClassLoader</code> 和 SPI 类型，创建懒加载迭代器</li>
</ol>
</li>
</ol>
<p>这里，摘录 <code>ServiceLoader.load</code> 相关源码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service 传入的是期望加载的 SPI 接口类型</span></span><br><span class="line"><span class="comment">// loader 是用于加载 SPI 服务的类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service,</span></span><br><span class="line"><span class="params">										ClassLoader loader)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 清空缓存中所有已实例化的 SPI 服务</span></span><br><span class="line">	providers.clear();</span><br><span class="line">    <span class="comment">// 根据 ClassLoader 和 SPI 类型，创建懒加载迭代器</span></span><br><span class="line">	lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法</span></span><br><span class="line"><span class="comment">// 重新加载 SPI 服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">	service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定类加载 ClassLoader 和访问控制上下文</span></span><br><span class="line">	loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">	acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 然后，重新加载 SPI 服务</span></span><br><span class="line">	reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）应用程序通过 <code>ServiceLoader</code> 的 <code>iterator</code> 方法遍历 SPI 实例</p>
<p><code>ServiceLoader</code> 的类定义，明确了 <code>ServiceLoader</code> 类实现了 <code>Iterable&lt;T&gt;</code> 接口，所以，它是可以迭代遍历的。实际上，<code>ServiceLoader</code> 类维护了一个缓存 providers（ <code>LinkedHashMap</code> 对象），缓存 providers 中保存了已经被成功加载的 SPI 实例，这个 Map 的 key 是 SPI 接口实现类的全限定名，value 是该实现类的一个实例对象。</p>
<p>当应用程序调用 <code>ServiceLoader</code> 的 <code>iterator</code> 方法时，<code>ServiceLoader</code> 会先判断缓存 providers 中是否有数据：如果有，则直接返回缓存 providers 的迭代器；如果没有，则返回懒加载迭代器的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存 SPI providers</span></span><br><span class="line">		Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">			= providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lookupIterator 是 LazyIterator 实例，用于懒加载 SPI 实例</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">				<span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">			<span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）懒加载迭代器的工作流程</p>
<p>上面的源码中提到了，lookupIterator 是 <code>LazyIterator</code> 实例，而 <code>LazyIterator</code> 用于懒加载 SPI 实例。那么， <code>LazyIterator</code> 是如何工作的呢？</p>
<p>这里，摘取 <code>LazyIterator</code> 关键代码</p>
<ul>
<li><code>hasNextService</code> 方法：<ol>
<li>拼接 <code>META-INF/services/</code> + SPI 接口全限定名</li>
<li>通过类加载器，尝试加载资源文件</li>
<li>解析资源文件中的内容，获取 SPI 接口的实现类的全限定名 <code>nextName</code></li>
</ol>
</li>
<li><code>nextService</code> 方法：<ol>
<li><code>hasNextService()</code> 方法解析出了 SPI 实现类的的全限定名 <code>nextName</code>，通过反射，获取 SPI 实现类的类定义 <code>Class&lt;?&gt;</code>。</li>
<li>然后，尝试通过 <code>Class&lt;?&gt;</code> 的 <code>newInstance</code> 方法实例化一个 SPI 服务对象。如果成功，则将这个对象加入到缓存 providers 中并返回该对象。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.拼接 META-INF/services/ + SPI 接口全限定名</span></span><br><span class="line">            <span class="comment">// 2.通过类加载器，尝试加载资源文件</span></span><br><span class="line">            <span class="comment">// 3.解析资源文件中的内容</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">			<span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">				configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				configs = loader.getResources(fullName);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">			fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pending = parse(service, configs.nextElement());</span><br><span class="line">	&#125;</span><br><span class="line">	nextName = pending.next();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!hasNextService())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">	<span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">	nextName = <span class="literal">null</span>;</span><br><span class="line">	Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">		fail(service,</span><br><span class="line">			 <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">		fail(service,</span><br><span class="line">			 <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a s&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">		providers.put(cn, p);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">		fail(service,</span><br><span class="line">			 <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">			 x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPI-和类加载器"><a href="#SPI-和类加载器" class="headerlink" title="SPI 和类加载器"></a>SPI 和类加载器</h3><p>通过上面两个章节中，走读 <code>ServiceLoader</code> 代码，我们已经大致了解 Java SPI 的工作原理，即通过 <code>ClassLoader</code> 加载 SPI 配置文件，解析 SPI 服务，然后通过反射，实例化 SPI 服务实例。我们不妨思考一下，为什么加载 SPI 服务时，需要指定类加载器 <code>ClassLoader</code> 呢？</p>
<p>学习过 JVM 的读者，想必都了解过类加载器的<strong>双亲委派模型（Parents Delegation Model）</strong>。双亲委派模型要求除了顶层的 <strong><code>BootstrapClassLoader</code></strong> 外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。双亲委派继承体系图如下：</p>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jmm-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="img" style="zoom: 50%;" />

<p>双亲委派机制约定了：<strong>一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载</strong>。</p>
<p><strong>双亲委派的好处</strong>：使得 Java 类伴随着它的类加载器，天然具备一种带有优先级的层次关系，从而使得类加载得到统一，不会出现重复加载的问题：</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证 Java 程序安全稳定运行</li>
</ul>
<p>例如： <code>java.lang.Object</code> 存放在 <code>rt.jar</code> 中，如果编写另外一个 <code>java.lang.Object</code> 的类并放到 <code>classpath</code> 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 <code>Object</code> 比在 <code>classpath</code> 中的 <code>Object</code> 优先级更高，因为 rt.jar 中的 <code>Object</code> 使用的是启动类加载器，而 <code>classpath</code> 中的 <code>Object</code> 使用的是应用程序类加载器。正因为 rt.jar 中的 <code>Object</code> 优先级更高，因为程序中所有的 <code>Object</code> 都是这个 <code>Object</code>。</p>
<p><strong>双亲委派的限制</strong>：子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。——这就导致了双亲委派模型并不能解决所有的类加载器问题。Java SPI 就面临着这样的问题：</p>
<ul>
<li>SPI 的接口是 Java 核心库的一部分，是由 <code>BootstrapClassLoader</code> 加载的；</li>
<li>而 SPI 实现的 Java 类一般是由 <code>AppClassLoader</code> 来加载的。<code>BootstrapClassLoader</code> 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 <code>AppClassLoader</code>，因为它是最顶层的类加载器。这也解释了本节开始的问题——为什么加载 SPI 服务时，需要指定类加载器 <code>ClassLoader</code> 呢？因为如果不指定 <code>ClassLoader</code>，则无法获取 SPI 服务。</li>
</ul>
<p>如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是 <code>AppClassLoader</code>。在核心类库使用 SPI 接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p>
<p>通常可以通过 <code>Thread.currentThread().getClassLoader()</code> 和 <code>Thread.currentThread().getContextClassLoader()</code> 获取线程上下文类加载器。</p>
<h3 id="Java-SPI-的不足"><a href="#Java-SPI-的不足" class="headerlink" title="Java SPI 的不足"></a>Java SPI 的不足</h3><p>Java SPI 存在一些不足：</p>
<ul>
<li><p>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</p>
</li>
<li><p>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</p>
</li>
<li><p>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</p>
</li>
</ul>
<h2 id="SPI-应用场景"><a href="#SPI-应用场景" class="headerlink" title="SPI 应用场景"></a>SPI 应用场景</h2><p>SPI 在 Java 开发中应用十分广泛。首先，在 Java 的 <code>java.util.spi</code> package 中就约定了很多 SPI 接口。下面，列举一些 SPI 接口：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/spi/TimeZoneNameProvider.html"><em>TimeZoneNameProvider:</em></a> 为 TimeZone 类提供本地化的时区名称。</li>
<li><em><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/spi/DateFormatProvider.html">DateFormatProvider</a>:</em> 为指定的语言环境提供日期和时间格式。</li>
<li><em><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/spi/NumberFormatProvider.html">NumberFormatProvider</a>:</em> 为 NumberFormat 类提供货币、整数和百分比值。</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/Driver.html"><em>Driver:</em></a> 从 4.0 版开始，JDBC API 支持 SPI 模式。旧版本使用 Class.forName() 方法加载驱动程序。</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/persistence/spi/PersistenceProvider.html"><em>PersistenceProvider:</em></a> 提供 JPA API 的实现。</li>
<li>等等</li>
</ul>
<p>除此以外，SPI 还有很多应用，下面列举几个经典案例。</p>
<h3 id="SPI-应用案例之-JDBC-DriverManager"><a href="#SPI-应用案例之-JDBC-DriverManager" class="headerlink" title="SPI 应用案例之 JDBC DriverManager"></a>SPI 应用案例之 JDBC DriverManager</h3><p>作为 Java 工程师，尤其是 CRUD 工程师，相必都非常熟悉 JDBC。众所周知，关系型数据库有很多种，如：Mysql、Oracle、PostgreSQL 等等。JDBC 如何识别各种数据库的驱动呢？</p>
<h4 id="创建数据库连接"><a href="#创建数据库连接" class="headerlink" title="创建数据库连接"></a>创建数据库连接</h4><p>我们先回顾一下，JDBC 如何创建数据库连接的呢？</p>
<p>在 <strong>JDBC4.0 之前</strong>，连接数据库的时候，通常会用 <strong><code>Class.forName(XXX)</code></strong> 方法来加载数据库相应的驱动，然后再获取数据库连接，继而进行 CRUD 等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>而 J<strong>DBC4.0 之后</strong>，不再需要用 <strong><code>Class.forName(XXX)</code></strong> 方法来加载数据库驱动，直接获取连接就可以了。显然，这种方式很方便，但是如何做到的呢？</p>
<ul>
<li><p>JDBC 接口：首先，Java 中内置了接口 <code>java.sql.Driver</code>。</p>
</li>
<li><p>JDBC 接口实现：各个数据库的驱动自行实现 <code>java.sql.Driver</code> 接口，用于管理数据库连接。</p>
<ul>
<li>Mysql：在 mysql 的 Java 驱动包 <code>mysql-connector-java-XXX.jar</code> 中，可以找到 <code>META-INF/services</code> 目录，该目录下会有一个名字为<code>java.sql.Driver</code> 的文件，文件内容是 <code>com.mysql.cj.jdbc.Driver</code>。 <code>com.mysql.cj.jdbc.Driver</code> 正是 Mysql 版的 <code>java.sql.Driver</code> 实现。如下图所示：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220505201455.png"></p>
<ul>
<li>PostgreSQL 实现：在 PostgreSQL 的 Java 驱动包 <code>postgresql-42.0.0.jar</code> 中，也可以找到同样的配置文件，文件内容是 <code>org.postgresql.Driver</code>，<code>org.postgresql.Driver</code> 正是 PostgreSQL 版的 <code>java.sql.Driver</code> 实现。</li>
</ul>
</li>
<li><p>创建数据库连接</p>
<p>以 Mysql 为例，创建数据库连接代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> String.format(<span class="string">&quot;jdbc:mysql://%s:%s/%s&quot;</span>, DB_HOST, DB_PORT, DB_SCHEMA);</span><br><span class="line">connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h4><p>从前文，我们已经知道 <code>DriverManager</code> 是创建数据库连接的关键。它究竟是如何工作的呢？</p>
<p>可以看到是加载实例化驱动的，接着看 loadInitialDrivers 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">	String drivers;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;() &#123;</span><br><span class="line">			<span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		drivers = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过 classloader 获取所有实现 java.sql.Driver 的驱动类</span></span><br><span class="line">	AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">		<span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 利用 SPI，记载所有 Driver 服务</span></span><br><span class="line">			ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            <span class="comment">// 获取迭代器</span></span><br><span class="line">			Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 遍历迭代器</span></span><br><span class="line">				<span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">					driversIterator.next();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">			<span class="comment">// Do nothing</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数据库驱动信息</span></span><br><span class="line">	println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drivers == <span class="literal">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">	println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">	<span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">            <span class="comment">// 尝试实例化驱动</span></span><br><span class="line">			Class.forName(aDriver, <span class="literal">true</span>,</span><br><span class="line">					ClassLoader.getSystemClassLoader());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要步骤是：</p>
<ol>
<li>从系统变量中获取驱动的实现类。</li>
<li>利用 SPI 来获取所有驱动的实现类。</li>
<li>遍历所有驱动，尝试实例化各个实现类。</li>
<li>根据第 1 步获取到的驱动列表来实例化具体的实现类。</li>
</ol>
<p>需要关注的是下面这行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br></pre></td></tr></table></figure>

<p>这里实际获取的是 <code>java.util.ServiceLoader.LazyIterator</code> 迭代器。调用其 <code>hasNext</code> 方法时，会搜索 classpath 下以及 jar 包中的 <code>META-INF/services</code> 目录，查找 <code>java.sql.Driver</code> 文件，并找到文件中的驱动实现类的全限定名。调用其 <code>next</code> 方法时，会根据驱动类的全限定名去尝试实例化一个驱动类的对象。</p>
<h3 id="SPI-应用案例之-Common-Logging"><a href="#SPI-应用案例之-Common-Logging" class="headerlink" title="SPI 应用案例之 Common-Logging"></a>SPI 应用案例之 Common-Logging</h3><p>common-logging（也称 Jakarta Commons Logging，缩写 JCL）是常用的日志门面工具包。</p>
<p>common-logging 的核心类是入口是 <code>LogFactory</code>，<code>LogFatory</code> 是一个抽象类，它负责加载具体的日志实现。</p>
<p>其入口方法是 <code>LogFactory.getLog</code> 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title function_">getLog</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> LogConfigurationException &#123;</span><br><span class="line">	<span class="keyword">return</span> getFactory().getInstance(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title function_">getLog</span><span class="params">(String name)</span> <span class="keyword">throws</span> LogConfigurationException &#123;</span><br><span class="line">	<span class="keyword">return</span> getFactory().getInstance(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上源码可知，<code>getLog</code> 采用了工厂设计模式，是先调用 <code>getFactory</code> 方法获取具体日志库的工厂类，然后根据类名称或类型创建日志实例。</p>
<p><code>LogFatory.getFactory</code> 方法负责选出匹配的日志工厂，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LogFactory <span class="title function_">getFactory</span><span class="params">()</span> <span class="keyword">throws</span> LogConfigurationException &#123;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载 commons-logging.properties 配置文件</span></span><br><span class="line">	<span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 决定创建哪个 LogFactory 实例</span></span><br><span class="line">	<span class="comment">// （1）尝试读取全局属性 org.apache.commons.logging.LogFactory</span></span><br><span class="line">	<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">		logDiagnostic(<span class="string">&quot;[LOOKUP] Looking for system property [&quot;</span> + FACTORY_PROPERTY +</span><br><span class="line">					  <span class="string">&quot;] to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果指定了 org.apache.commons.logging.LogFactory 属性，尝试实例化具体实现类</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">factoryClass</span> <span class="operator">=</span> getSystemProperty(FACTORY_PROPERTY, <span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (factoryClass != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">				logDiagnostic(<span class="string">&quot;[LOOKUP] Creating an instance of LogFactory class &#x27;&quot;</span> + factoryClass +</span><br><span class="line">							  <span class="string">&quot;&#x27; as specified by system property &quot;</span> + FACTORY_PROPERTY);</span><br><span class="line">			&#125;</span><br><span class="line">			factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">				logDiagnostic(<span class="string">&quot;[LOOKUP] No system property [&quot;</span> + FACTORY_PROPERTY + <span class="string">&quot;] defined.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">	    <span class="comment">// 异常处理</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">	    <span class="comment">// 异常处理</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （2）利用 Java SPI 机制，尝试在 classpatch 的 META-INF/services 目录下寻找 org.apache.commons.logging.LogFactory 实现类</span></span><br><span class="line">	<span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">			logDiagnostic(<span class="string">&quot;[LOOKUP] Looking for a resource file of name [&quot;</span> + SERVICE_ID +</span><br><span class="line">						  <span class="string">&quot;] to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getResourceAsStream(contextClassLoader, SERVICE_ID);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( is != <span class="literal">null</span> ) &#123;</span><br><span class="line">				<span class="comment">// This code is needed by EBCDIC and other strange systems.</span></span><br><span class="line">				<span class="comment">// It&#x27;s a fix for bugs reported in xerces</span></span><br><span class="line">				BufferedReader rd;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					rd = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">				&#125; <span class="keyword">catch</span> (java.io.UnsupportedEncodingException e) &#123;</span><br><span class="line">					rd = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> rd.readLine();</span><br><span class="line">				rd.close();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (factoryClassName != <span class="literal">null</span> &amp;&amp; ! <span class="string">&quot;&quot;</span>.equals(factoryClassName)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">						logDiagnostic(<span class="string">&quot;[LOOKUP]  Creating an instance of LogFactory class &quot;</span> +</span><br><span class="line">									  factoryClassName +</span><br><span class="line">									  <span class="string">&quot; as specified by file &#x27;&quot;</span> + SERVICE_ID +</span><br><span class="line">									  <span class="string">&quot;&#x27; which was present in the path of the context classloader.&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader );</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// is == null</span></span><br><span class="line">				<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">					logDiagnostic(<span class="string">&quot;[LOOKUP] No resource file with name &#x27;&quot;</span> + SERVICE_ID + <span class="string">&quot;&#x27; found.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="comment">// note: if the specified LogFactory class wasn&#x27;t compatible with LogFactory</span></span><br><span class="line">			<span class="comment">// for some reason, a ClassCastException will be caught here, and attempts will</span></span><br><span class="line">			<span class="comment">// continue to find a compatible class.</span></span><br><span class="line">			<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">				logDiagnostic(</span><br><span class="line">					<span class="string">&quot;[LOOKUP] A security exception occurred while trying to create an&quot;</span> +</span><br><span class="line">					<span class="string">&quot; instance of the custom factory class&quot;</span> +</span><br><span class="line">					<span class="string">&quot;: [&quot;</span> + trim(ex.getMessage()) +</span><br><span class="line">					<span class="string">&quot;]. Trying alternative implementations...&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// ignore</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// （3）尝试从 classpath 目录下的 commons-logging.properties 文件中查找 org.apache.commons.logging.LogFactory 属性</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">				logDiagnostic(</span><br><span class="line">					<span class="string">&quot;[LOOKUP] Looking in properties file for entry with key &#x27;&quot;</span> + FACTORY_PROPERTY +</span><br><span class="line">					<span class="string">&quot;&#x27; to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">factoryClass</span> <span class="operator">=</span> props.getProperty(FACTORY_PROPERTY);</span><br><span class="line">			<span class="keyword">if</span> (factoryClass != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">					logDiagnostic(</span><br><span class="line">						<span class="string">&quot;[LOOKUP] Properties file specifies LogFactory subclass &#x27;&quot;</span> + factoryClass + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> think about whether we need to handle exceptions from newFactory</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">					logDiagnostic(<span class="string">&quot;[LOOKUP] Properties file has no entry specifying LogFactory subclass.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">				logDiagnostic(<span class="string">&quot;[LOOKUP] No properties file available to determine&quot;</span> + <span class="string">&quot; LogFactory subclass from..&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// （4）以上情况都不满足，实例化默认实现类 org.apache.commons.logging.impl.LogFactoryImpl</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">			logDiagnostic(</span><br><span class="line">				<span class="string">&quot;[LOOKUP] Loading the default LogFactory implementation &#x27;&quot;</span> + FACTORY_DEFAULT +</span><br><span class="line">				<span class="string">&quot;&#x27; via the same classloader that loaded this LogFactory&quot;</span> +</span><br><span class="line">				<span class="string">&quot; class (ie not looking in the context classloader).&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Always cache using context class loader.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cacheFactory(contextClassLoader, factory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">Enumeration</span> <span class="variable">names</span> <span class="operator">=</span> props.propertyNames();</span><br><span class="line">			<span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) names.nextElement();</span><br><span class="line">				<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> props.getProperty(name);</span><br><span class="line">				factory.setAttribute(name, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 getFactory 方法的源码可以看出，其核心逻辑分为 4 步：</p>
<ol>
<li>首先，尝试查找全局属性 <code>org.apache.commons.logging.LogFactory</code>，如果指定了具体类，尝试创建实例。</li>
<li>利用 Java SPI 机制，尝试在 classpatch 的 <code>META-INF/services</code> 目录下寻找 <code>org.apache.commons.logging.LogFactory</code> 的实现类。</li>
<li>尝试从 classpath 目录下的 <code>commons-logging.properties</code> 文件中查找 <code>org.apache.commons.logging.LogFactory</code> 属性，如果指定了具体类，尝试创建实例。</li>
<li>以上情况如果都不满足，则实例化默认实现类，即 <code>org.apache.commons.logging.impl.LogFactoryImpl</code>。</li>
</ol>
<h3 id="SPI-应用案例之-Spring-Boot"><a href="#SPI-应用案例之-Spring-Boot" class="headerlink" title="SPI 应用案例之 Spring Boot"></a>SPI 应用案例之 Spring Boot</h3><p>Spring Boot 是基于 Spring 构建的框架，其设计目的在于简化 Spring 应用的配置、运行。在 Spring Boot 中，大量运用了自动装配来尽可能减少配置。</p>
<p>下面是一个 Spring Boot 入口示例，可以看到，代码非常简洁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> String.format(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，Spring Boot 是如何做到寥寥几行代码，就可以运行一个 Spring Boot 应用的呢。我们不妨带着疑问，从源码入手，一步步探究其原理。</p>
<h4 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a><code>@SpringBootApplication</code> 注解</h4><p>首先，Spring Boot 应用的启动类上都会标记一个 <code>@SpringBootApplication</code> 注解。<code>@SpringBootApplication</code> 注解定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">		<span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 <code>@Target</code>、 <code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code> 这几个元注解， <code>@SpringBootApplication</code> 注解的定义中还标记了 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 三个注解。</p>
<h4 id="SpringBootConfiguration-注解"><a href="#SpringBootConfiguration-注解" class="headerlink" title="@SpringBootConfiguration 注解"></a><code>@SpringBootConfiguration</code> 注解</h4><p>从<code>@SpringBootConfiguration</code> 注解的定义来看，<code>@SpringBootConfiguration</code> 注解本质上就是一个 <code>@Configuration</code> 注解，这意味着被<code>@SpringBootConfiguration</code> 注解修饰的类会被 Spring Boot 识别为一个配置类。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Configuration</span></span><br><span class="line">public <span class="variable">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="variable">@AliasFor</span>(</span><br><span class="line">        annotation = Configuration.class</span><br><span class="line">    )</span><br><span class="line">    boolean proxyBeanMethods() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EnableAutoConfiguration-注解"><a href="#EnableAutoConfiguration-注解" class="headerlink" title="@EnableAutoConfiguration 注解"></a><code>@EnableAutoConfiguration</code> 注解</h4><p><code>@EnableAutoConfiguration</code> 注解定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableAutoConfiguration</code> 注解包含了 <code>@AutoConfigurationPackage</code> 与 <code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code> 两个注解。</p>
<h4 id="AutoConfigurationPackage-注解"><a href="#AutoConfigurationPackage-注解" class="headerlink" title="@AutoConfigurationPackage 注解"></a><code>@AutoConfigurationPackage</code> 注解</h4><p><code>@AutoConfigurationPackage</code> 会将被修饰的类作为主配置类，该类所在的 package 会被视为根路径，Spring Boot 默认会自动扫描根路径下的所有 Spring Bean（被 <code>@Component</code> 以及继承 <code>@Component</code> 的各个注解所修饰的类）。——这就是为什么 Spring Boot 的启动类一般要置于根路径的原因。这个功能等同于在 Spring xml 配置中通过 <code>context:component-scan</code> 来指定扫描路径。<code>@Import</code> 注解的作用是向 Spring 容器中直接注入指定组件。<code>@AutoConfigurationPackage</code> 注解中注明了 <code>@Import(&#123;Registrar.class&#125;)</code>。<code>Registrar</code> 类用于保存 Spring Boot 的入口类、根路径等信息。</p>
<h4 id="SpringFactoriesLoader-loadFactoryNames-方法"><a href="#SpringFactoriesLoader-loadFactoryNames-方法" class="headerlink" title="SpringFactoriesLoader.loadFactoryNames 方法"></a><code>SpringFactoriesLoader.loadFactoryNames</code> 方法</h4><p><code>@Import(AutoConfigurationImportSelector.class)</code> 表示直接注入 <code>AutoConfigurationImportSelector</code>。<code>AutoConfigurationImportSelector</code> 有一个核心方法 <code>getCandidateConfigurations</code> 用于获取候选配置。该方法调用了 <code>SpringFactoriesLoader.loadFactoryNames</code> 方法，这个方法即为 Spring Boot SPI 的关键，它负责加载所有 <code>META-INF/spring.factories</code> 文件，加载的过程由 <code>SpringFactoriesLoader</code> 负责。</p>
<p>Spring Boot 的 <code>META-INF/spring.factories</code> 文件本质上就是一个 properties 文件，数据内容就是一个个键值对。</p>
<p><code>SpringFactoriesLoader.loadFactoryNames</code> 方法的关键源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spring.factories 文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 遍历所有 META-INF/spring.factories 文件</span></span><br><span class="line"><span class="comment">// 解析文件，获得 key=factoryClass 的类名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line">	<span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">  <span class="comment">// 尝试获取缓存，如果缓存中有数据，直接返回</span></span><br><span class="line">	MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">	<span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取资源文件路径</span></span><br><span class="line">		Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?</span><br><span class="line">				classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">				ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">		result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有路径</span></span><br><span class="line">		<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">			<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">			<span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">      <span class="comment">// 解析文件，得到对应的一组 Properties</span></span><br><span class="line">			<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">      <span class="comment">// 遍历解析出的 properties，组装数据</span></span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">				<span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">					result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cache.put(classLoader, result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">				FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归纳上面的方法，主要作了这些事：</p>
<p>加载所有 <code>META-INF/spring.factories</code> 文件，加载过程有 <code>SpringFactoriesLoader</code> 负责。</p>
<ul>
<li>在 CLASSPATH 中搜寻所有 <code>META-INF/spring.factories</code> 配置文件</li>
<li>然后，解析 <code>spring.factories</code> 文件，获取指定自动装配类的全限定名</li>
</ul>
<h4 id="Spring-Boot-的-AutoConfiguration-类"><a href="#Spring-Boot-的-AutoConfiguration-类" class="headerlink" title="Spring Boot 的 AutoConfiguration 类"></a>Spring Boot 的 <code>AutoConfiguration</code> 类</h4><p>Spring Boot 有各种 starter 包，可以根据实际项目需要，按需取材。在项目开发中，只要将 starter 包引入，我们就可以用很少的配置，甚至什么都不配置，即可获取相关的能力。通过前面的 Spring Boot SPI 流程，只完成了自动装配工作的一半，剩下的工作如何处理呢 ？</p>
<p>以 spring-boot-starter-web 的 jar 包为例，查看其 maven pom，可以看到，它依赖于 spring-boot-starter，所有 Spring Boot 官方 starter 包都会依赖于这个 jar 包。而 spring-boot-starter 又依赖于 spring-boot-autoconfigure，Spring Boot 的自动装配秘密，就在于这个 jar 包。</p>
<p>从 spring-boot-autoconfigure 包的结构来看，它有一个 <code>META-INF/spring.factories</code> ，显然利用了 Spring Boot SPI，来自动装配其中的配置类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220505004100.png"></p>
<p>下图是 spring-boot-autoconfigure 的 <code>META-INF/spring.factories</code> 文件的部分内容，可以看到其中注册了一长串会被自动加载的 <code>AutoConfiguration</code> 类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220505005130.png"></p>
<p>以 <code>RedisAutoConfiguration</code> 为例，这个配置类中，会根据 <code>@ConditionalXXX</code> 中的条件去决定是否实例化对应的 Bean，实例化 Bean 所依赖的重要参数则通过 <code>RedisProperties</code> 传入。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220505005548.png"></p>
<p><code>RedisProperties</code> 中维护了 Redis 连接所需要的关键属性，只要在 yml 或 properties 配置文件中，指定 spring.redis 开头的属性，都会被自动装载到 <code>RedisProperties</code> 实例中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220505005836.png"></p>
<p>通过以上分析，已经一步步解读出 Spring Boot 自动装载的原理。</p>
<h2 id="SPI-应用案例之-Dubbo"><a href="#SPI-应用案例之-Dubbo" class="headerlink" title="SPI 应用案例之 Dubbo"></a>SPI 应用案例之 Dubbo</h2><p>Dubbo 并未使用 Java SPI，而是自己封装了一套新的 SPI 机制。Dubbo SPI 所需的配置文件需放置在 <code>META-INF/dubbo</code> 路径下，配置内容形式如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimusPrime = org<span class="selector-class">.apache</span><span class="selector-class">.spi</span><span class="selector-class">.OptimusPrime</span></span><br><span class="line">bumblebee = org<span class="selector-class">.apache</span><span class="selector-class">.spi</span>.Bumblebee</span><br></pre></td></tr></table></figure>

<p>与 Java SPI 实现类配置不同，Dubbo SPI 是<strong>通过键值对的方式进行配置</strong>，这样可以<strong>按需加载</strong>指定的实现类。Dubbo SPI 除了支持按需加载接口实现类，还增加了 IOC 和 AOP 等特性。</p>
<h4 id="ExtensionLoader-入口"><a href="#ExtensionLoader-入口" class="headerlink" title="ExtensionLoader 入口"></a><code>ExtensionLoader</code> 入口</h4><p>Dubbo SPI 的相关逻辑被封装在了 <code>ExtensionLoader</code> 类中，通过 <code>ExtensionLoader</code>，可以加载指定的实现类。</p>
<p><code>ExtensionLoader</code> 的 <code>getExtension</code> 方法是其入口方法，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 获取默认的拓展实现类</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Holder，顾名思义，用于持有目标对象</span></span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建拓展实例</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                <span class="comment">// 设置实例到 holder 中</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个方法的作用就是：首先检查缓存，缓存未命中则调用 <code>createExtension</code> 方法创建拓展对象。那么，<code>createExtension</code> 是如何创建拓展对象的呢，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射创建实例</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="literal">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环创建 Wrapper 实例</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span></span><br><span class="line">                <span class="comment">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span></span><br><span class="line">                instance = injectExtension(</span><br><span class="line">                    (T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createExtension</code> 方法的的工作步骤可以归纳为：</p>
<ol>
<li>通过 <code>getExtensionClasses</code> 获取所有的拓展类</li>
<li>通过反射创建拓展对象</li>
<li>向拓展对象中注入依赖</li>
<li>将拓展对象包裹在相应的 <code>Wrapper</code> 对象中</li>
</ol>
<p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。</p>
<h4 id="获取所有的拓展类"><a href="#获取所有的拓展类" class="headerlink" title="获取所有的拓展类"></a>获取所有的拓展类</h4><p>Dubbo 在通过名称获取拓展类之前，首先需要根据配置文件解析出拓展项名称到拓展类的映射关系表（Map&lt;名称, 拓展类&gt;），之后再根据拓展项名称从映射关系表中取出相应的拓展类即可。相关过程的代码分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取已加载的拓展类</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加载拓展类</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也是先检查缓存，若缓存未命中，则通过 <code>synchronized</code> 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则通过 <code>loadExtensionClasses</code> 加载拓展类。下面分析 <code>loadExtensionClasses</code> 方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 获取 SPI 注解，这里的 type 变量是在调用 getExtensionLoader 方法时传入的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SPI</span> <span class="variable">defaultAnnotation</span> <span class="operator">=</span> type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> defaultAnnotation.value();</span><br><span class="line">        <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对 SPI 注解内容进行切分</span></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            <span class="comment">// 检测 SPI 注解内容是否合法，不合法则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;more than 1 default extension name on extension...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置默认名称，参考 getDefaultExtension 方法</span></span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">                cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">// 加载指定文件夹下的配置文件</span></span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loadExtensionClasses</code> 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 <code>loadDirectory</code> 方法加载指定文件夹配置文件。SPI 注解解析过程比较简单，无需多说。下面我们来看一下 <code>loadDirectory</code> 做了哪些事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> &#123;</span><br><span class="line">    <span class="comment">// fileName = 文件夹路径 + type 全限定名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dir + type.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">        <span class="comment">// 根据文件名加载所有的同名文件</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.<span class="type">URL</span> <span class="variable">resourceURL</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载资源</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadDirectory 方法先通过 classLoader 获取所有资源链接，然后再通过 loadResource 方法加载资源。我们继续跟下去，看一下 loadResource 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses,</span></span><br><span class="line"><span class="params">	ClassLoader classLoader, java.net.URL resourceURL)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resourceURL.openStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 按行读取配置内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 定位 # 字符</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 截取 # 之前的字符串，# 之后的内容为注释，需要忽略</span></span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 以等于号 = 为界，截取键与值</span></span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载类，并通过 loadClass 方法对类进行缓存</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL,</span><br><span class="line">                                      Class.forName(line, <span class="literal">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to load extension class...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception when load extension class...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadResource 方法用于读取和解析配置文件，并通过反射加载类，最后调用 loadClass 方法进行其他操作。loadClass 方法用于主要用于操作缓存，该方法的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL,</span></span><br><span class="line"><span class="params">    Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测目标类上是否有 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 cachedAdaptiveClass缓存</span></span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测 clazz 是否是 Wrapper 类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrappers == <span class="literal">null</span>) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            wrappers = cachedWrapperClasses;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储 clazz 到 cachedWrapperClasses 缓存中</span></span><br><span class="line">        wrappers.add(clazz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序进入此分支，表明 clazz 是一个普通的拓展类</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 检测 clazz 是否有默认的构造方法，如果没有，则抛出异常</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 name 为空，则尝试从 Extension 注解中获取 name，或使用小写的类名作为 name</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切分 name</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (names != <span class="literal">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Activate</span> <span class="variable">activate</span> <span class="operator">=</span> clazz.getAnnotation(Activate.class);</span><br><span class="line">            <span class="keyword">if</span> (activate != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果类上有 Activate 注解，则使用 names 数组的第一个元素作为键，</span></span><br><span class="line">                <span class="comment">// 存储 name 到 Activate 注解对象的映射关系</span></span><br><span class="line">                cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                    <span class="comment">// 存储 Class 到名称的映射关系</span></span><br><span class="line">                    cachedNames.put(clazz, n);</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储名称到 Class 的映射关系</span></span><br><span class="line">                    extensionClasses.put(n, clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，<code>loadClass</code> 方法操作了不同的缓存，比如 <code>cachedAdaptiveClass</code>、<code>cachedWrapperClasses</code> 和 <code>cachedNames</code> 等等。除此之外，该方法没有其他什么逻辑了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28909673">Java SPI 思想梳理</a></li>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/dubbo-spi/#m-zhdocsv27devsourcedubbo-spi">Dubbo SPI</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0d196ad23915">springboot 中 SPI 机制</a></li>
<li><a target="_blank" rel="noopener" href="https://cdmana.com/2021/09/20210912140742519L.html">SpringBoot 的自动装配原理、自定义 starter 与 spi 机制，一网打尽</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/5bdbcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/5bdbcd/" class="post-title-link" itemprop="url">Dubbo 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-25 19:12:19" itemprop="dateCreated datePublished" datetime="2022-04-25T19:12:19+08:00">2022-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo-快速入门"><a href="#Dubbo-快速入门" class="headerlink" title="Dubbo 快速入门"></a>Dubbo 快速入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache Dubbo 是一款高性能、轻量级的开源微服务框架。它提供了 <strong>RPC 通信</strong> 与 <strong>微服务治理</strong> 两大关键能力。</p>
<h3 id="Dubbo-的核心功能"><a href="#Dubbo-的核心功能" class="headerlink" title="Dubbo 的核心功能"></a>Dubbo 的核心功能</h3><p>Dubbo 提供了六大核心能力：</p>
<ul>
<li><strong>面向接口代理的高性能 RPC 调用</strong>：提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节。</li>
<li><strong>智能容错和负载均衡</strong>：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。</li>
<li><strong>服务自动注册和发现</strong>：支持多种注册中心服务，服务实例上下线实时感知。</li>
<li><strong>高度可扩展能力</strong>：遵循微内核+插件的设计原则，所有核心能力如 Protocol、Transport、Serialization 被设计为扩展点，平等对待内置实现和第三方实现。</li>
<li><strong>运行期流量调度</strong>：内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能。</li>
<li><strong>可视化的服务治理与运维</strong>：提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。</li>
</ul>
<h3 id="Dubbo-的优势"><a href="#Dubbo-的优势" class="headerlink" title="Dubbo 的优势"></a>Dubbo 的优势</h3><p>Dubbo 提供了一站式微服务解决方案，包括服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，并且尝试从使用上对用户屏蔽底层细节，以提供更好的易用性。</p>
<p><strong>定义服务</strong>在 Dubbo 中非常简单与直观:</p>
<ul>
<li>使用与某种语言绑定的方式（如 Java 中可直接定义 Interface）</li>
<li>使用 Protobuf IDL 语言的方式。</li>
</ul>
<p>Dubbo 提供了丰富的<strong>通信模型</strong>：</p>
<ul>
<li>消费端异步请求(Client Side Asynchronous Request-Response)</li>
<li>提供端异步执行（Server Side Asynchronous Request-Response）</li>
<li>消费端请求流（Request Streaming）</li>
<li>提供端响应流（Response Streaming）</li>
<li>双向流式通信（Bidirectional Streaming）</li>
</ul>
<p>Dubbo 提供基于客户端的<strong>服务发现</strong>机制，可以采用多种方式启用服务发现：</p>
<ul>
<li>使用第三方的注册中心组件，如 Nacos、Zookeeper、Consul、Etcd 等。</li>
<li>将服务的组织与注册交给底层容器平台，如 Kubernetes，这被理解是一种更云原生的方式</li>
</ul>
<p>Dubbo 提供了多种<strong>流量控制</strong>手段，包括负载均衡、流量路由、请求超时、流量降级、重试等策略。基于这些基础能力可以轻松的实现更多场景化的路由方案，包括金丝雀发布、A&#x2F;B 测试、权重路由、同区域优先等。</p>
<p>Dubbo 的<strong>扩展性</strong>良好：通过 Filter、Router、Protocol 等几乎存在于每一个关键流程上的扩展点定义，我们可以丰富 Dubbo 的功能或实现与其他微服务配套系统的对接，包括 Transaction、Tracing 目前都有通过 SPI 扩展的实现方案，具体可以参见 Dubbo 扩展性的详情，也可以在 <a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-spi-extensions">apache&#x2F;dubbo-spi-extensions</a> 项目中发现与更多的扩展实现。</p>
<p>Dubbo 在支持微服务集群方面有着非常大的规模与非常久的实践经验积累，是最具有企业规模化微服务实践话语权的框架之一。</p>
<p>Dubbo3 的设计是面向<strong>云原生</strong>的：</p>
<ul>
<li>首先是对云原生基础设施与部署架构的支持，包括 Kubernetes、Service Mesh 等。</li>
<li>另一方面，Dubbo 众多核心组件都已面向云原生升级，包括 Triple 协议、统一路由规则、对多语言支持。</li>
</ul>
<h2 id="Dubbo3-新特性"><a href="#Dubbo3-新特性" class="headerlink" title="Dubbo3 新特性"></a>Dubbo3 新特性</h2><h3 id="全新服务发现模型"><a href="#全新服务发现模型" class="headerlink" title="全新服务发现模型"></a>全新服务发现模型</h3><p>相比于 2.x 版本中的基于<code>接口</code>粒度的服务发现机制，3.x 引入了全新的<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/concepts/service-discovery">基于应用粒度的服务发现机制</a>， 新模型带来两方面的巨大优势：</p>
<ul>
<li><strong>进一步提升了 Dubbo3 在大规模集群实践中的性能与稳定性</strong>。新模型可大幅提高系统资源利用率，降低 Dubbo 地址的单机内存消耗（50%），降低注册中心集群的存储与推送压力（90%）， Dubbo 可支持集群规模步入百万实例层次。</li>
<li><strong>打通与其他异构微服务体系的地址互发现障碍</strong>。新模型使得 Dubbo3 能实现与异构微服务体系如 Spring Cloud、Kubernetes Service、gRPC 等，在地址发现层面的互通， 为连通 Dubbo 与其他微服务体系提供可行方案。</li>
</ul>
<h3 id="下一代-RPC-通信协议"><a href="#下一代-RPC-通信协议" class="headerlink" title="下一代 RPC 通信协议"></a>下一代 RPC 通信协议</h3><p>定义了全新的 RPC 通信协议 – Triple，一句话概括 Triple：它是基于 HTTP&#x2F;2 上构建的 RPC 协议，完全兼容 gRPC，并在此基础上扩展出了更丰富的语义。 使用 Triple 协议，用户将获得以下能力</p>
<ul>
<li>更容易到适配网关、Mesh 架构，Triple 协议让 Dubbo 更方便的与各种网关、Sidecar 组件配合工作。</li>
<li>多语言友好，推荐配合 Protobuf 使用 Triple 协议，使用 IDL 定义服务，使用 Protobuf 编码业务数据。</li>
<li>流式通信支持。Triple 协议支持 Request Stream、Response Stream、Bi-direction Stream</li>
</ul>
<h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><p>Dubbo3 构建的业务应用可直接部署在 VM、Container、Kubernetes 等平台，Dubbo3 很好的解决了 Dubbo 服务与调度平台之间的生命周期对齐，Dubbo 服务发现地址 与容器平台绑定的问题。</p>
<p>在服务发现层面，Dubbo3 支持与 <a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/new-in-dubbo3/">Kubernetes Native Service</a> 的融合，目前限于 Headless Service。</p>
<p>Dubbo3 规划了两种形态的 Service Mesh 方案，在不同的业务场景、不同的迁移阶段、不同的基础设施保障情况下，Dubbo 都会有 Mesh 方案可供选择， 而这进一步的都可以通过统一的控制面进行治理。</p>
<ul>
<li>经典的基于 Sidecar 的 Service Mesh</li>
<li>无 Sidecar 的 Proxyless Mesh</li>
</ul>
<p>用户在 Dubbo2 中熟知的路由规则，在 3.x 中将被一套<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/concepts/traffic-management"><code>统一的流量治理规则</code></a>取代，这套统一流量规则将覆盖未来 Dubbo3 的 Service Mesh、SDK 等多种部署形态， 实现对整套微服务体系的治理。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>定义服务</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo Github</a></li>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Dubbo 官方文档</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">46:19</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>




  <script src="/blog/js/third-party/pace.js"></script>

  




<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"2f77a1d950319325283ec38ac290a654"}</script>
<script src="/blog/js/third-party/comments/gitalk.js"></script>

</body>
</html>
