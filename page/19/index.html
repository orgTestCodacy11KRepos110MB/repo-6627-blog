<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/19/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/19/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/19/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">279</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">118</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">385</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">385</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">118</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">279</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e25d81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e25d81/" class="post-title-link" itemprop="url">Java IO 工具类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-30 21:34:59" itemprop="dateCreated datePublished" datetime="2020-06-30T21:34:59+08:00">2020-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-IO-工具类"><a href="#Java-IO-工具类" class="headerlink" title="Java IO 工具类"></a>Java IO 工具类</h1><blockquote>
<p><strong><em>关键词：<code>File</code>、<code>RandomAccessFile</code>、<code>System</code>、<code>Scanner</code></em></strong></p>
<p>本文介绍 Java IO 的一些常见工具类的用法和特性。</p>
</blockquote>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p><code>File</code> 类是 <code>java.io</code> 包中唯一对文件本身进行操作的类。它可以对文件、目录进行增删查操作。</p>
<h3 id="createNewFille"><a href="#createNewFille" class="headerlink" title="createNewFille"></a>createNewFille</h3><p><strong>可以使用 <code>createNewFille()</code> 方法创建一个新文件</strong>。</p>
<p>注：</p>
<p>Windows 中使用反斜杠表示目录的分隔符 <code>\</code>。~~~~~~~~</p>
<p>Linux 中使用正斜杠表示目录的分隔符 <code>/</code>。</p>
<p>最好的做法是使用 <code>File.separator</code> 静态常量，可以根据所在操作系统选取对应的分隔符。</p>
<p>【示例】创建文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.createNewFile();</span><br></pre></td></tr></table></figure>

<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><strong>可以使用 <code>mkdir()</code> 来创建文件夹</strong>，但是如果要创建的目录的父路径不存在，则无法创建成功。</p>
<p>如果要解决这个问题，可以使用 <code>mkdirs()</code>，当父路径不存在时，会连同上级目录都一并创建。</p>
<p>【示例】创建目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.mkdir();</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><strong>可以使用 <code>delete()</code> 来删除文件或目录</strong>。</p>
<p>需要注意的是，如果删除的是目录，且目录不为空，直接用 <code>delete()</code> 删除会失败。</p>
<p>【示例】删除文件或目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.delete();</span><br></pre></td></tr></table></figure>

<h3 id="list-和-listFiles"><a href="#list-和-listFiles" class="headerlink" title="list 和 listFiles"></a>list 和 listFiles</h3><p><code>File</code> 中给出了两种列出文件夹内容的方法：</p>
<ul>
<li><strong><code>list()</code>: 列出全部名称，返回一个字符串数组</strong>。</li>
<li><strong><code>listFiles()</code>: 列出完整的路径，返回一个 <code>File</code> 对象数组</strong>。</li>
</ul>
<p><code>list()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">String str[] = f.list();</span><br></pre></td></tr></table></figure>

<p><code>listFiles()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">File files[] = f.listFiles();</span><br></pre></td></tr></table></figure>

<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><blockquote>
<p>注：<code>RandomAccessFile</code> 类虽然可以实现对文件内容的读写操作，但是比较复杂。所以一般操作文件内容往往会使用字节流或字符流方式。</p>
</blockquote>
<p><code>RandomAccessFile</code> 类是随机读取类，它是一个完全独立的类。</p>
<p>它适用于由大小已知的记录组成的文件，所以我们可以使用 <code>seek()</code> 将记录从一处转移到另一处，然后读取或者修改记录。</p>
<p>文件中记录的大小不一定都相同，只要能够确定哪些记录有多大以及它们在文件中的位置即可。</p>
<h3 id="RandomAccessFile-写操作"><a href="#RandomAccessFile-写操作" class="headerlink" title="RandomAccessFile 写操作"></a>RandomAccessFile 写操作</h3><p>当用 <code>rw</code> 方式声明 <code>RandomAccessFile</code> 对象时，如果要写入的文件不存在，系统将自行创建。</p>
<p><code>r</code> 为只读；<code>w</code> 为只写；<code>rw</code> 为读写。</p>
<p>【示例】文件随机读写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>); <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">rdf</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明RandomAccessFile类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);<span class="comment">// 读写模式，如果文件不存在，会自动创建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">30</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">&quot;lisi    &quot;</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">31</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">&quot;wangwu  &quot;</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">32</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        rdf.close(); <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RandomAccessFile-读操作"><a href="#RandomAccessFile-读操作" class="headerlink" title="RandomAccessFile 读操作"></a>RandomAccessFile 读操作</h3><p>读取是直接使用 <code>r</code> 的模式即可，以只读的方式打开文件。</p>
<p>读取时所有的字符串只能按照 byte 数组方式读取出来，而且长度必须和写入时的固定大小相匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);    <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">rdf</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="comment">// 声明RandomAccessFile类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;r&quot;</span>);<span class="comment">// 以只读的方式打开文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span> b[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];    <span class="comment">// 开辟byte数组</span></span><br><span class="line">        <span class="comment">// 读取第二个人的信息，意味着要空出第一个人的信息</span></span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);        <span class="comment">// 跳过第一个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        <span class="comment">// 读取第一个人的信息</span></span><br><span class="line">        rdf.seek(<span class="number">0</span>);    <span class="comment">// 指针回到文件的开头</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);    <span class="comment">// 空出第二个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第三个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        rdf.close();                <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p><code>System</code> 类中提供了大量的静态方法，可以获取系统相关的信息或系统级操作，其中提供了三个常用于 IO 的静态成员：</p>
<ul>
<li><code>System.out</code> - 一个 PrintStream 流。System.out 一般会把你写到其中的数据输出到控制台上。System.out 通常仅用在类似命令行工具的控制台程序上。System.out 也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。</li>
<li><code>System.err</code> - 一个 PrintStream 流。System.err 与 System.out 的运行方式类似，但它更多的是用于打印错误文本。一些类似 Eclipse 的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过 System.err 输出到控制台上。</li>
<li><code>System.in</code> - 一个典型的连接控制台程序和键盘输入的 InputStream 流。通常当数据通过命令行参数或者配置文件传递给命令行 Java 程序的时候，System.in 并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的 Java IO 输入机制。</li>
</ul>
<p>【示例】重定向 <code>System.out</code> 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemOutDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\test.txt&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;人生若只如初见，何事秋风悲画扇&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】重定向 <code>System.err</code> 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemErrDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();        <span class="comment">// 实例化</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(bos);        <span class="comment">// 实例化</span></span><br><span class="line">        System.setErr(ps);    <span class="comment">// 输出重定向</span></span><br><span class="line">        System.err.print(<span class="string">&quot;此处有误&quot;</span>);</span><br><span class="line">        System.out.println(bos);    <span class="comment">// 输出内存中的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】<code>System.in</code> 接受控制台输入信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemInDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> System.in;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入内容：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) temp;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的内容为：&quot;</span> + buf);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p><strong><code>Scanner</code> 可以获取用户的输入，并对数据进行校验</strong>。</p>
<p>【示例】校验输入数据是否格式正确</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);    <span class="comment">// 从键盘接收数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextInt()) &#123;    <span class="comment">// 判断输入的是否是整数</span></span><br><span class="line">            i = scan.nextInt();    <span class="comment">// 接收整数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;整数数据：&quot;</span> + i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是整数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;输入小数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat()) &#123;    <span class="comment">// 判断输入的是否是小数</span></span><br><span class="line">            f = scan.nextFloat();    <span class="comment">// 接收小数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;小数数据：&quot;</span> + f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是小数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入日期（yyyy-MM-dd）：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext(<span class="string">&quot;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&quot;</span>)) &#123;    <span class="comment">// 判断</span></span><br><span class="line">            str = scan.next(<span class="string">&quot;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&quot;</span>);    <span class="comment">// 接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                date = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的日期格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入整数：20</span><br><span class="line">整数数据：20</span><br><span class="line">输入小数：3.2</span><br><span class="line">小数数据：3.2</span><br><span class="line">输入日期（yyyy-MM-dd）：1988<span class="string">-13</span><span class="string">-1</span></span><br><span class="line">输入的日期格式错误！</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html">System 官方 API 手册</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/db5b69/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/db5b69/" class="post-title-link" itemprop="url">Java 内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-28 16:19:00" itemprop="dateCreated datePublished" datetime="2020-06-28T16:19:00+08:00">2020-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-内存管理"><a href="#Java-内存管理" class="headerlink" title="Java 内存管理"></a>Java 内存管理</h1><h2 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h2><h3 id="物理内存和虚拟内存"><a href="#物理内存和虚拟内存" class="headerlink" title="物理内存和虚拟内存"></a>物理内存和虚拟内存</h3><p>所谓物理内存就是通常所说的 RAM（随机存储器）。</p>
<p>虚拟内存使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上共享，在逻辑上彼此仍然是隔离的。</p>
<h3 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h3><p>一个计算通常有固定大小的内存空间，但是程序并不能使用全部的空间。因为这些空间被划分为内核空间和用户空间，而程序只能使用用户空间的内存。</p>
<h3 id="使用内存的-Java-组件"><a href="#使用内存的-Java-组件" class="headerlink" title="使用内存的 Java 组件"></a>使用内存的 Java 组件</h3><p>Java 启动后，作为一个进程运行在操作系统中。</p>
<p>有哪些 Java 组件需要占用内存呢？</p>
<ul>
<li>堆内存：Java 堆、类和类加载器</li>
<li>栈内存：线程</li>
<li>本地内存：NIO、JNI</li>
</ul>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-memory-runtime-data-area.png" alt="img"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong><code>程序计数器（Program Counter Register）</code></strong> 是一块较小的内存空间，它可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>。例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>
<p>当执行的线程数量超过 CPU 数量时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令，从而在线程切换后能恢复到正确的执行位置。各条线程间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</li>
<li>如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
</ul>
<blockquote>
<p>🔔 注意：此内存区域是唯一一个在 JVM 中没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p>
</blockquote>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p><strong><code>Java 虚拟机栈（Java Virtual Machine Stacks）</code></strong> 也<strong>是线程私有的，它的生命周期与线程相同</strong>。</p>
<p>每个 Java 方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 <strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>常量池引用</strong> 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-stack.png!w640" alt="img"></p>
<ul>
<li><strong>局部变量表</strong> - 32 位变量槽，存放了编译期可知的各种基本数据类型、对象引用、<code>ReturnAddress</code> 类型。</li>
<li><strong>操作数栈</strong> - 基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。</li>
<li><strong>动态链接</strong> - 每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态链接。</li>
<li><strong>方法出口</strong> - 返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。</li>
</ul>
<blockquote>
<p>🔔 注意：</p>
<p>该区域可能抛出以下异常：</p>
<ul>
<li>如果线程请求的栈深度超过最大值，就会抛出 <code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机栈进行动态扩展时，无法申请到足够内存，就会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<p>💡 提示：</p>
<p>可以通过 <code>-Xss</code> 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss=512M HackTheJava</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong><code>本地方法栈（Native Method Stack）</code></strong> 与虚拟机栈的作用相似。</p>
<p>二者的区别在于：<strong>虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务</strong>。本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-native-method-stack.gif!w640" alt="img"></p>
<blockquote>
<p>🔔 注意：本地方法栈也会抛出 <code>StackOverflowError</code> 异常和 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p><strong><code>Java 堆（Java Heap）</code> 的作用就是存放对象实例，几乎所有的对象实例都是在这里分配内存</strong>。</p>
<p>Java 堆是垃圾收集的主要区域（因此也被叫做”GC 堆”）。现代的垃圾收集器基本都是采用<strong>分代收集算法</strong>，该算法的思想是针对不同的对象采取不同的垃圾回收算法。</p>
<p>因此虚拟机把 Java 堆分成以下三块：</p>
<ul>
<li><strong><code>新生代（Young Generation）</code></strong><ul>
<li><code>Eden</code> - Eden 和 Survivor 的比例为 8:1</li>
<li><code>From Survivor</code></li>
<li><code>To Survivor</code></li>
</ul>
</li>
<li><strong><code>老年代（Old Generation）</code></strong></li>
<li><strong><code>永久代（Permanent Generation）</code></strong></li>
</ul>
<p>当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-heap.gif!w640" alt="img"></p>
<blockquote>
<p>🔔 注意：Java 堆不需要连续内存，并且可以动态扩展其内存，扩展失败会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>💡 提示：可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms=1M -Xmx=2M HackTheJava</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）也被称为永久代。<strong>方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<blockquote>
<p>🔔 注意：和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>💡 提示：</p>
<ul>
<li>JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。可通过参数 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置。</li>
<li>JDK 1.8 之后，取消了永久代，用 **<code>metaspace（元数据）</code>**区替代。可通过参数 <code>-XX:MaxMetaspaceSize</code> 设置。</li>
</ul>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong><code>运行时常量池（Runtime Constant Pool）</code> 是方法区的一部分</strong>，Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池（Constant Pool Table），<strong>用于存放编译器生成的各种字面量和符号引用</strong>，这部分内容会在类加载后被放入这个区域。</p>
<ul>
<li><strong>字面量</strong> - 文本字符串、声明为 <code>final</code> 的常量值等。</li>
<li><strong>符号引用</strong> - 类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。</li>
</ul>
<p>除了在编译期生成的常量，还允许动态生成，例如 <code>String</code> 类的 <code>intern()</code>。这部分常量也会被放入运行时常量池。</p>
<blockquote>
<p>🔔 注意：当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。</p>
<p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<blockquote>
<p>🔔 注意：直接内存这部分也被频繁的使用，且也可能导致 <code>OutOfMemoryError</code> 异常。</p>
<p>💡 提示：直接内存容量可通过 <code>-XX:MaxDirectMemorySize</code> 指定，如果不指定，则默认与 Java 堆最大值（<code>-Xmx</code> 指定）一样。</p>
</blockquote>
<h3 id="Java-内存区域对比"><a href="#Java-内存区域对比" class="headerlink" title="Java 内存区域对比"></a>Java 内存区域对比</h3><table>
<thead>
<tr>
<th>内存区域</th>
<th>内存作用范围</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>线程私有</td>
<td>无</td>
</tr>
<tr>
<td>Java 虚拟机栈</td>
<td>线程私有</td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>本地方法栈</td>
<td>线程私有</td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>Java 堆</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>运行时常量池</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>直接内存</td>
<td>非运行时数据区</td>
<td><code>OutOfMemoryError</code></td>
</tr>
</tbody></table>
<h2 id="JVM-运行原理"><a href="#JVM-运行原理" class="headerlink" title="JVM 运行原理"></a>JVM 运行原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMCase</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">MAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态变量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">WOMAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;woman&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		stu.setName(<span class="string">&quot;nick&quot;</span>);</span><br><span class="line">		stu.setSexType(MAN_SEX_TYPE);</span><br><span class="line">		stu.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">JVMCase</span> <span class="variable">jvmcase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JVMCase</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用静态方法</span></span><br><span class="line">		print(stu);</span><br><span class="line">		<span class="comment">// 调用非静态方法</span></span><br><span class="line">		jvmcase.sayHello(stu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 常规静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;name: &quot;</span> + stu.getName() + <span class="string">&quot;; sex:&quot;</span> + stu.getSexType() + <span class="string">&quot;; age:&quot;</span> + stu.getAge());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">		System.out.println(stu.getName() + <span class="string">&quot;say: hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sexType;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSexType</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sexType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSexType</span><span class="params">(String sexType)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.sexType = sexType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码时，JVM 处理过程如下：</p>
<p>（1）JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。</p>
<p>（2）JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p>
<p>（3）class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630094250.png" alt="img"></p>
<p>（4）完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 <code>&lt;clinit&gt;</code> 方法，编译器会在 <code>.java</code> 文件被编译成 <code>.class</code> 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <code>&lt;clinit&gt;()</code> 方法。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630094329.png" alt="img"></p>
<p>（5）执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630094651.png" alt="img"></p>
<p>（6）此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，sayHello 方法属于对象 JVMCase，此时 sayHello 方法入栈，并通过栈中的 student 引用调用堆中的 Student 对象；之后，调用静态方法 print，print 静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630094714.png" alt="img"></p>
<h2 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h2><h3 id="什么是-OutOfMemoryError"><a href="#什么是-OutOfMemoryError" class="headerlink" title="什么是 OutOfMemoryError"></a>什么是 OutOfMemoryError</h3><p><code>OutOfMemoryError</code> 简称为 OOM。Java 中对 OOM 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。通俗的解释是：JVM 内存不足了。</p>
<p>在 JVM 规范中，<strong>除了程序计数器区域外，其他运行时区域都可能发生 <code>OutOfMemoryError</code> 异常（简称 OOM）</strong>。</p>
<p>下面逐一介绍 OOM 发生场景。</p>
<h3 id="堆空间溢出"><a href="#堆空间溢出" class="headerlink" title="堆空间溢出"></a>堆空间溢出</h3><p><code>java.lang.OutOfMemoryError: Java heap space</code> 这个错误意味着：<strong>堆空间溢出</strong>。</p>
<p>更细致的说法是：Java 堆内存已经达到 <code>-Xmx</code> 设置的最大值。Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾收集器回收这些对象，那么当堆空间到达最大容量限制后就会产生 OOM。</p>
<p>堆空间溢出有可能是**<code>内存泄漏（Memory Leak）</code>** 或 <strong><code>内存溢出（Memory Overflow）</code></strong> 。需要使用 jstack 和 jmap 生成 threaddump 和 heapdump，然后用内存分析工具（如：MAT）进行分析。</p>
<h4 id="Java-heap-space-分析步骤"><a href="#Java-heap-space-分析步骤" class="headerlink" title="Java heap space 分析步骤"></a>Java heap space 分析步骤</h4><ol>
<li>使用 <code>jmap</code> 或 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 获取堆快照。</li>
<li>使用内存分析工具（visualvm、mat、jProfile 等）对堆快照文件进行分析。</li>
<li>根据分析图，重点是确认内存中的对象是否是必要的，分清究竟是是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</li>
</ol>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p><strong>内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况</strong>。</p>
<p>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏随着被执行的次数不断增加，最终会导致内存溢出。</p>
<p>内存泄漏常见场景：</p>
<ul>
<li>静态容器<ul>
<li>声明为静态（<code>static</code>）的 <code>HashMap</code>、<code>Vector</code> 等集合</li>
<li>通俗来讲 A 中有 B，当前只把 B 设置为空，A 没有设置为空，回收时 B 无法回收。因为被 A 引用。</li>
</ul>
</li>
<li>监听器<ul>
<li>监听器被注册后释放对象时没有删除监听器</li>
</ul>
</li>
<li>物理连接<ul>
<li>各种连接池建立了连接，必须通过 <code>close()</code> 关闭链接</li>
</ul>
</li>
<li>内部类和外部模块等的引用<ul>
<li>发现它的方式同内存溢出，可再加个实时观察</li>
<li><code>jstat -gcutil 7362 2500 70</code></li>
</ul>
</li>
</ul>
<p>重点关注：</p>
<ul>
<li><code>FGC</code> — 从应用程序启动到采样时发生 Full GC 的次数。</li>
<li><code>FGCT</code> — 从应用程序启动到采样时 Full GC 所用的时间（单位秒）。</li>
<li><code>FGC</code> 次数越多，<code>FGCT</code> 所需时间越多，越有可能存在内存泄漏。</li>
</ul>
<p>如果是内存泄漏，可以进一步查看泄漏对象到 GC Roots 的对象引用链。这样就能找到泄漏对象是怎样与 GC Roots 关联并导致 GC 无法回收它们的。掌握了这些原因，就可以较准确的定位出引起内存泄漏的代码。</p>
<p>导致内存泄漏的常见原因是使用容器，且不断向容器中添加元素，但没有清理，导致容器内存不断膨胀。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存泄漏示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * VM Args：-verbose:gc -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OomObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OomObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OomObject</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>如果不存在内存泄漏，即内存中的对象确实都必须存活着，则应当检查虚拟机的堆参数（<code>-Xmx</code> 和 <code>-Xms</code>），与机器物理内存进行对比，看看是否可以调大。并从代码上检查是否存在某些对象生命周期过长、持有时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆溢出示例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * VM Args：-verbose:gc -Xms10M -Xmx10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:forbreak@163.com&quot;&gt;Zhang Peng&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-06-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Double[] array = <span class="keyword">new</span> <span class="title class_">Double</span>[<span class="number">999999999</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;array length = [&quot;</span> + array.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>java -verbose:gc -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError io.github.dunwu.javacore.jvm.memory.HeapMemoryLeakMemoryErrorDemo</code></p>
<p>上面的例子是一个极端的例子，试图创建一个维度很大的数组，堆内存无法分配这么大的内存，从而报错：<code>Java heap space</code>。</p>
<p>但如果在现实中，代码并没有问题，仅仅是因为堆内存不足，可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 适当调整堆内存大小。</p>
<h3 id="GC-开销超过限制"><a href="#GC-开销超过限制" class="headerlink" title="GC 开销超过限制"></a>GC 开销超过限制</h3><p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> 这个错误，官方给出的定义是：<strong>超过 <code>98%</code> 的时间用来做 GC 并且回收了不到 <code>2%</code> 的堆内存时会抛出此异常</strong>。这意味着，发生在 GC 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC overhead limit exceeded 示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span><br><span class="line"><span class="comment"> * 发生在GC占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。</span></span><br><span class="line"><span class="comment"> * 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms10M -Xmx10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcOverheadLimitExceededDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(d++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【处理】</p>
<p>与 <strong>Java heap space</strong> 错误处理方法类似，先判断是否存在内存泄漏。如果有，则修正代码；如果没有，则通过 <code>-Xms</code> 和 <code>-Xmx</code> 适当调整堆内存大小。</p>
<h3 id="永久代空间不足"><a href="#永久代空间不足" class="headerlink" title="永久代空间不足"></a>永久代空间不足</h3><p>【错误】</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: PermGen space</span><br></pre></td></tr></table></figure>

<p>【原因】</p>
<p>Perm （永久代）空间主要用于存放 <code>Class</code> 和 Meta 信息，包括类的名称和字段，带有方法字节码的方法，常量池信息，与类关联的对象数组和类型数组以及即时编译器优化。GC 在主程序运行期间不会对永久代空间进行清理，默认是 64M 大小。</p>
<p>根据上面的定义，可以得出 <strong>PermGen 大小要求取决于加载的类的数量以及此类声明的大小</strong>。因此，可以说造成该错误的主要原因是永久代中装入了太多的类或太大的类。</p>
<p>在 JDK8 之前的版本中，可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置永久代空间大小，从而限制方法区大小，并间接限制其中常量池的容量。</p>
<h4 id="初始化时永久代空间不足"><a href="#初始化时永久代空间不足" class="headerlink" title="初始化时永久代空间不足"></a>初始化时永久代空间不足</h4><p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 永久代内存空间不足示例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 错误现象：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;java.lang.OutOfMemoryError: PermGen space (JDK8 以前版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;java.lang.OutOfMemoryError: Metaspace (JDK8 及以后版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * VM Args:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;-Xmx100M -XX:MaxPermSize=16M (JDK8 以前版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;-Xmx100M -XX:MaxMetaspaceSize=16M (JDK8 及以后版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermOutOfMemoryErrorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000_000</span>; i++) &#123;</span><br><span class="line">            generate(<span class="string">&quot;eu.plumbr.demo.Generated&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title function_">generate</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">return</span> pool.makeClass(name).toClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，源代码遍历循环并在运行时生成类。javassist 库正在处理类生成的复杂性。</p>
<h4 id="重部署时永久代空间不足"><a href="#重部署时永久代空间不足" class="headerlink" title="重部署时永久代空间不足"></a>重部署时永久代空间不足</h4><p>对于更复杂，更实际的示例，让我们逐步介绍一下在应用程序重新部署期间发生的 Permgen 空间错误。重新部署应用程序时，你希望垃圾回收会摆脱引用所有先前加载的类的加载器，并被加载新类的类加载器取代。</p>
<p>不幸的是，许多第三方库以及对线程，JDBC 驱动程序或文件系统句柄等资源的不良处理使得无法卸载以前使用的类加载器。反过来，这意味着在每次重新部署期间，所有先前版本的类仍将驻留在 PermGen 中，从而在每次重新部署期间生成数十兆的垃圾。</p>
<p>让我们想象一个使用 JDBC 驱动程序连接到关系数据库的示例应用程序。启动应用程序时，初始化代码将加载 JDBC 驱动程序以连接到数据库。对应于规范，JDBC 驱动程序向 java.sql.DriverManager 进行注册。该注册包括将对驱动程序实例的引用存储在 DriverManager 的静态字段中。</p>
<p>现在，当从应用程序服务器取消部署应用程序时，java.sql.DriverManager 仍将保留该引用。我们最终获得了对驱动程序类的实时引用，而驱动程序类又保留了用于加载应用程序的 java.lang.Classloader 实例的引用。反过来，这意味着垃圾回收算法无法回收空间。</p>
<p>而且该 java.lang.ClassLoader 实例仍引用应用程序的所有类，通常在 PermGen 中占据数十兆字节。这意味着只需少量重新部署即可填充通常大小的 PermGen。</p>
<h4 id="PermGen-space-解决方案"><a href="#PermGen-space-解决方案" class="headerlink" title="PermGen space 解决方案"></a>PermGen space 解决方案</h4><p>（1）解决初始化时的 <code>OutOfMemoryError</code></p>
<p>在应用程序启动期间触发由于 PermGen 耗尽导致的 <code>OutOfMemoryError</code> 时，解决方案很简单。该应用程序仅需要更多空间才能将所有类加载到 PermGen 区域，因此我们只需要增加其大小即可。为此，更改你的应用程序启动配置并添加（或增加，如果存在）<code>-XX:MaxPermSize</code> 参数，类似于以下示例：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:<span class="attribute">MaxPermSize</span>=512m com.yourcompany.YourClass</span><br></pre></td></tr></table></figure>

<p>上面的配置将告诉 JVM，PermGen 可以增长到 512MB。</p>
<p>清理应用程序中 <code>WEB-INF/lib</code> 下的 jar，用不上的 jar 删除掉，多个应用公共的 jar 移动到 Tomcat 的 lib 目录，减少重复加载。</p>
<p>🔔 注意：<code>-XX:PermSize</code> 一般设为 64M</p>
<p>（2）解决重新部署时的 <code>OutOfMemoryError</code></p>
<p>重新部署应用程序后立即发生 OutOfMemoryError 时，应用程序会遭受类加载器泄漏的困扰。在这种情况下，解决问题的最简单，继续进行堆转储分析–使用类似于以下命令的重新部署后进行堆转储：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -<span class="keyword">dump</span>:format=b,<span class="keyword">file</span>=<span class="keyword">dump</span>.hprof &lt;process-id&gt;</span><br></pre></td></tr></table></figure>

<p>然后使用你最喜欢的堆转储分析器打开转储（Eclipse MAT 是一个很好的工具）。在分析器中可以查找重复的类，尤其是那些正在加载应用程序类的类。从那里，你需要进行所有类加载器的查找，以找到当前活动的类加载器。</p>
<p>对于非活动类加载器，你需要通过从非活动类加载器收集到 GC 根的最短路径来确定阻止它们被垃圾收集的引用。有了此信息，你将找到根本原因。如果根本原因是在第三方库中，则可以进入 Google&#x2F;StackOverflow 查看是否是已知问题以获取补丁&#x2F;解决方法。</p>
<p>（3）解决运行时 <code>OutOfMemoryError</code></p>
<p>第一步是检查是否允许 GC 从 PermGen 卸载类。在这方面，标准的 JVM 相当保守-类是天生的。因此，一旦加载，即使没有代码在使用它们，类也会保留在内存中。当应用程序动态创建许多类并且长时间不需要生成的类时，这可能会成为问题。在这种情况下，允许 JVM 卸载类定义可能会有所帮助。这可以通过在启动脚本中仅添加一个配置参数来实现：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+CMSClassUnloadingEnabled</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，此选项设置为 false，因此要启用此功能，你需要在 Java 选项中显式设置。如果启用 CMSClassUnloadingEnabled，GC 也会扫描 PermGen 并删除不再使用的类。请记住，只有同时使用 UseConcMarkSweepGC 时此选项才起作用。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure>

<p>在确保可以卸载类并且问题仍然存在之后，你应该继续进行堆转储分析–使用类似于以下命令的方法进行堆转储：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -<span class="keyword">dump</span>:<span class="keyword">file</span>=<span class="keyword">dump</span>.hprof,format=b &lt;process-id&gt;</span><br></pre></td></tr></table></figure>

<p>然后，使用你最喜欢的堆转储分析器（例如 Eclipse MAT）打开转储，然后根据已加载的类数查找最昂贵的类加载器。从此类加载器中，你可以继续提取已加载的类，并按实例对此类进行排序，以使可疑对象排在首位。</p>
<p>然后，对于每个可疑者，就需要你手动将根本原因追溯到生成此类的应用程序代码。</p>
<h3 id="元数据区空间不足"><a href="#元数据区空间不足" class="headerlink" title="元数据区空间不足"></a>元数据区空间不足</h3><p>【错误】</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Exception</span> <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.<span class="built_in">OutOfMemoryError</span>: Metaspace</span><br></pre></td></tr></table></figure>

<p>【原因】</p>
<p>Java8 以后，JVM 内存空间发生了很大的变化。取消了永久代，转而变为元数据区。</p>
<p><strong>元数据区的内存不足，即方法区和运行时常量池的空间不足</strong>。</p>
<p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<p>一个类要被垃圾收集器回收，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的回收状况。这类常见除了 CGLib 字节码增强和动态语言以外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<p>【示例】方法区出现 <code>OutOfMemoryError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(Bean.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解决】</p>
<p>当由于元空间而面临 <code>OutOfMemoryError</code> 时，第一个解决方案应该是显而易见的。如果应用程序耗尽了内存中的 Metaspace 区域，则应增加 Metaspace 的大小。更改应用程序启动配置并增加以下内容：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:<span class="attribute">MaxMetaspaceSize</span>=512m</span><br></pre></td></tr></table></figure>

<p>上面的配置示例告诉 JVM，允许 Metaspace 增长到 512 MB。</p>
<p>另一种解决方案甚至更简单。你可以通过删除此参数来完全解除对 Metaspace 大小的限制，JVM 默认对 Metaspace 的大小没有限制。但是请注意以下事实：这样做可能会导致大量交换或达到本机物理内存而分配失败。</p>
<h3 id="无法新建本地线程"><a href="#无法新建本地线程" class="headerlink" title="无法新建本地线程"></a>无法新建本地线程</h3><p><code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 这个错误意味着：<strong>Java 应用程序已达到其可以启动线程数的限制</strong>。</p>
<p>【原因】</p>
<p>当发起一个线程的创建时，虚拟机会在 JVM 内存创建一个 <code>Thread</code> 对象同时创建一个操作系统线程，而这个系统线程的内存用的不是 JVM 内存，而是系统中剩下的内存。</p>
<p>那么，究竟能创建多少线程呢？这里有一个公式：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 = <span class="comment">(MaxProcessMemory - JVMMemory - ReservedOsMemory)</span> / <span class="comment">(ThreadStackSize)</span></span><br></pre></td></tr></table></figure>

<p>【参数】</p>
<ul>
<li><code>MaxProcessMemory</code> - 一个进程的最大内存</li>
<li><code>JVMMemory</code> - JVM 内存</li>
<li><code>ReservedOsMemory</code> - 保留的操作系统内存</li>
<li><code>ThreadStackSize</code> - 线程栈的大小</li>
</ul>
<p>**给 JVM 分配的内存越多，那么能用来创建系统线程的内存就会越少，越容易发生 <code>unable to create new native thread</code>**。所以，JVM 内存不是分配的越大越好。</p>
<p>但是，通常导致 <code>java.lang.OutOfMemoryError</code> 的情况：无法创建新的本机线程需要经历以下阶段：</p>
<ol>
<li>JVM 内部运行的应用程序请求新的 Java 线程</li>
<li>JVM 本机代码代理为操作系统创建新本机线程的请求</li>
<li>操作系统尝试创建一个新的本机线程，该线程需要将内存分配给该线程</li>
<li>操作系统将拒绝本机内存分配，原因是 32 位 Java 进程大小已耗尽其内存地址空间（例如，已达到（2-4）GB 进程大小限制）或操作系统的虚拟内存已完全耗尽</li>
<li>引发 <code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 错误。</li>
</ol>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnableCreateNativeThreadErrorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MINUTES.sleep(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【处理】</p>
<p>可以通过增加操作系统级别的限制来绕过无法创建新的本机线程问题。例如，如果限制了 JVM 可在用户空间中产生的进程数，则应检查出并可能增加该限制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dev ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">--- cut for brevity ---</span><br><span class="line">max user processes              (-u) 1800</span><br></pre></td></tr></table></figure>

<p>通常，<code>OutOfMemoryError</code> 对新的本机线程的限制表示编程错误。当应用程序产生数千个线程时，很可能出了一些问题—很少有应用程序可以从如此大量的线程中受益。</p>
<p>解决问题的一种方法是开始进行线程转储以了解情况。</p>
<h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><p>由直接内存导致的内存溢出，一个明显的特征是在 Head Dump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，就可以考虑检查一下是不是这方面的原因。</p>
<p>【示例】直接内存 <code>OutOfMemoryError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本机直接内存溢出示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h2><p>对于 HotSpot 虚拟机来说，栈容量只由 <code>-Xss</code> 参数来决定如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常。</p>
<p>从实战来说，栈溢出的常见原因：</p>
<ul>
<li><strong>递归函数调用层数太深</strong></li>
<li><strong>大量循环或死循环</strong></li>
</ul>
<p>【示例】递归函数调用层数太深导致 <code>StackOverflowError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        recursion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackOverflowDemo</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackOverflowDemo</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj.recursion();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈深度：&quot;</span> + obj.stackLength);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.douban.com/doulist/2545443/">从表到里学习 JVM 实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/28935cbfbae0">作为测试你应该知道的 JAVA OOM 及定位分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_29912455/article/details/51125748">异常、堆内存溢出、OOM 的几种情况</a></li>
<li><a target="_blank" rel="noopener" href="https://tianmingxing.com/2019/11/17/%E4%BB%8B%E7%BB%8DJVM%E4%B8%ADOOM%E7%9A%848%E7%A7%8D%E7%B1%BB%E5%9E%8B/">介绍 JVM 中 OOM 的 8 种类型</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ed757c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ed757c/" class="post-title-link" itemprop="url">Redis 数据类型和应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-数据类型和应用"><a href="#Redis-数据类型和应用" class="headerlink" title="Redis 数据类型和应用"></a>Redis 数据类型和应用</h1><blockquote>
<p>Redis 提供了多种数据类型，每种数据类型有丰富的命令支持。</p>
<p>使用 Redis ，不仅要了解其数据类型的特性，还需要根据业务场景，灵活的、高效的使用其数据类型来建模。</p>
</blockquote>
<h2 id="一、Redis-基本数据类型"><a href="#一、Redis-基本数据类型" class="headerlink" title="一、Redis 基本数据类型"></a>一、Redis 基本数据类型</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200226113813.png" alt="Redis 数据类型"></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody></table>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p>
</blockquote>
<h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-string.png" width="400"/>
</div>
**适用场景：缓存、计数器、共享 Session**

<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>GET</code></td>
<td>获取存储在给定键中的值。</td>
</tr>
<tr>
<td><code>SET</code></td>
<td>设置存储在给定键中的值。</td>
</tr>
<tr>
<td><code>DEL</code></td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）。</td>
</tr>
<tr>
<td><code>INCR</code></td>
<td>为键 <code>key</code> 储存的数字值加一</td>
</tr>
<tr>
<td><code>DECR</code></td>
<td>为键 <code>key</code> 储存的数字值减一</td>
</tr>
</tbody></table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#string">Redis String 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-hash.png" width="400"/>
</div>
**适用场景：存储结构化数据**，如一个对象：用户信息、产品信息等。

<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>HSET</code></td>
<td>在散列里面关联起给定的键值对。</td>
</tr>
<tr>
<td><code>HGET</code></td>
<td>获取指定散列键的值。</td>
</tr>
<tr>
<td><code>HGETALL</code></td>
<td>获取散列包含的所有键值对。</td>
</tr>
<tr>
<td><code>HDEL</code></td>
<td>如果给定键存在于散列里面，那么移除这个键。</td>
</tr>
</tbody></table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#hash">Redis Hash 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key3 value2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-list.png" width="400"/>
</div>
**适用场景：用于存储列表型数据**。如：粉丝列表、商品列表等。

<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>LPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>RPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>LPOP</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>RPOP</code></td>
<td>从列表的右端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LRANGE</code></td>
<td>获取列表在给定范围上的所有值。</td>
</tr>
<tr>
<td><code>LINDEX</code></td>
<td>获取列表在给定位置上的单个元素。</td>
</tr>
<tr>
<td><code>LREM</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LTRIM</code></td>
<td>只保留指定区间内的元素，删除其他元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#list">Redis List 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-set.png" width="400"/>
</div>
**适用场景：用于存储去重的列表型数据**。

<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD</code></td>
<td>将给定元素添加到集合。</td>
</tr>
<tr>
<td><code>SMEMBERS</code></td>
<td>返回集合包含的所有元素。</td>
</tr>
<tr>
<td><code>SISMEMBER</code></td>
<td>检查给定元素是否存在于集合中。</td>
</tr>
<tr>
<td><code>SREM</code></td>
<td>如果给定的元素存在于集合中，那么移除这个元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#set">Redis Set 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<h3 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-zset.png" width="400"/>
</div>

<p>适用场景：由于可以设置 score，且不重复。<strong>适合用于存储各种排行数据</strong>，如：按评分排序的有序商品集合、按时间排序的有序文章集合。</p>
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD</code></td>
<td>将一个带有给定分值的成员添加到有序集合里面。</td>
</tr>
<tr>
<td><code>ZRANGE</code></td>
<td>根据元素在有序排列中所处的位置，从有序集合里面获取多个元素。</td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE</code></td>
<td>获取有序集合在给定分值范围内的所有元素。</td>
</tr>
<tr>
<td><code>ZREM</code></td>
<td>如果给定成员存在于有序集合，那么移除这个成员。</td>
</tr>
</tbody></table>
<blockquote>
<p>更多命令请参考：<a target="_blank" rel="noopener" href="https://redis.io/commands#sorted_set">Redis ZSet 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>Redis 的 <code>SORT</code> 命令可以对 <code>LIST</code>、<code>SET</code>、<code>ZSET</code> 进行排序。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SORT</code></td>
<td>&#96;SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; RPUSH &#x27;sort-input&#x27; 23 15 110 7</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27;</span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;23&quot;</span><br><span class="line">4) &quot;110&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27; alpha</span><br><span class="line">1) &quot;110&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;23&quot;</span><br><span class="line">4) &quot;7&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-7&#x27; &#x27;field&#x27; 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-15&#x27; &#x27;field&#x27; 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-23&#x27; &#x27;field&#x27; 9</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET &#x27;d-110&#x27; &#x27;field&#x27; 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27; by &#x27;d-*-&gt;field&#x27;</span><br><span class="line">1) &quot;15&quot;</span><br><span class="line">2) &quot;110&quot;</span><br><span class="line">3) &quot;7&quot;</span><br><span class="line">4) &quot;23&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT &#x27;sort-input&#x27; by &#x27;d-*-&gt;field&#x27; get &#x27;d-*-&gt;field&#x27;</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">4) &quot;9&quot;</span><br></pre></td></tr></table></figure>

<h4 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h4><p>Redis 的 <code>EXPIRE</code> 命令可以指定一个键的过期时间，当达到过期时间后，Redis 会自动删除该键。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PERSIST</code></td>
<td><code>PERSIST key-name</code>—移除键的过期时间</td>
</tr>
<tr>
<td><code>TTL</code></td>
<td><code>TTL key-name</code>—查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td><code>EXPIRE</code></td>
<td><code>EXPIRE key-name seconds</code>—让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td><code>EXPIREAT</code></td>
<td><code>EXPIREAT key-name timestamp</code>—将给定键的过期时间设置为给定的 UNIX 时间戳</td>
</tr>
<tr>
<td><code>PTTL</code></td>
<td><code>PTTL key-name</code>—查看给定键距离过期时间还有多少毫秒（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIRE</code></td>
<td><code>PEXPIRE key-name milliseconds</code>—让给定键在指定的毫秒数之后过期（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIREAT</code></td>
<td><code>PEXPIREAT key-name timestamp-milliseconds</code>—将一个毫秒级精度的 UNIX 时间戳设置为给定键的过期时间（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[15]&gt; GET key</span><br><span class="line">&quot;value&quot;</span><br><span class="line">127.0.0.1:6379[15]&gt; EXPIRE key 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; GET key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h2 id="二、Redis-高级数据类型"><a href="#二、Redis-高级数据类型" class="headerlink" title="二、Redis 高级数据类型"></a>二、Redis 高级数据类型</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>BitMap 即位图。BitMap 不是一个真实的数据结构。而是 STRING 类型上的一组面向 bit 操作的集合。由于 STRING 是二进制安全的 blob，并且它们的最大长度是 512m，所以 BitMap 能最大设置 $$2^{32}$$ 个不同的 bit。</p>
<p>Bitmaps 的最大优点就是存储信息时可以节省大量的空间。例如在一个系统中，不同的用户被一个增长的用户 ID 表示。40 亿（$$2^{32}$$ &#x3D; $$4<em>1024</em>1024*1024$$ ≈ 40 亿）用户只需要 512M 内存就能记住某种信息，例如用户是否登录过。</p>
<h4 id="BitMap-命令"><a href="#BitMap-命令" class="headerlink" title="BitMap 命令"></a>BitMap 命令</h4><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/setbit.html">SETBIT</a> - 对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/getbit.html">GETBIT</a> - 对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitcount.html">BITCOUNT</a> - 计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitpos.html">BITPOS</a></li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitop.html">BITOP</a></li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitfield.html">BITFIELD</a></li>
</ul>
<h4 id="BitMap-示例"><a href="#BitMap-示例" class="headerlink" title="BitMap 示例"></a>BitMap 示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXISTS bit</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GETBIT bit 10086</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对已存在的 offset 进行 GETBIT</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SETBIT bit 10086 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GETBIT bit 10086</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">BITCOUNT bit</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="BitMap-应用"><a href="#BitMap-应用" class="headerlink" title="BitMap 应用"></a>BitMap 应用</h4><p>Bitmap 对于一些特定类型的计算非常有效。例如：使用 bitmap 实现用户上线次数统计。</p>
<p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 <a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/setbit.html#setbit">SETBIT key offset value</a> 和 [BITCOUNT key <a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitcount.html#bitcount">start] [end]</a> 来实现。</p>
<p>比如说，每当用户在某一天上线的时候，我们就使用 <a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/setbit.html#setbit">SETBIT key offset value</a> ，以用户名作为 <code>key</code>，将那天所代表的网站的上线日作为 <code>offset</code> 参数，并将这个 <code>offset</code> 上的为设置为 <code>1</code> 。</p>
<blockquote>
<p>更详细的实现可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011957758/article/details/74783347">一看就懂系列之 详解 redis 的 bitmap 在亿级项目中的应用</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">Fast, easy, realtime metrics using Redis bitmaps</a></p>
</blockquote>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 是用于计算唯一事物的概率数据结构（从技术上讲，这被称为估计集合的基数）。如果统计唯一项，项目越多，需要的内存就越多。因为需要记住过去已经看过的项，从而避免多次统计这些项。</p>
<h4 id="HyperLogLog-命令"><a href="#HyperLogLog-命令" class="headerlink" title="HyperLogLog 命令"></a>HyperLogLog 命令</h4><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/hyperloglog/pfadd.html">PFADD</a> - 将任意数量的元素添加到指定的 HyperLogLog 里面。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/hyperloglog/pfcount.html">PFCOUNT</a> - 返回 HyperLogLog 包含的唯一元素的近似数量。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/hyperloglog/pfmerge.html">PFMERGE</a> - 将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。合并得出的 HyperLogLog 会被储存在 <code>destkey</code> 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD  databases  <span class="string">&quot;Redis&quot;</span>  <span class="string">&quot;MongoDB&quot;</span>  <span class="string">&quot;MySQL&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT  databases</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD  databases  <span class="string">&quot;Redis&quot;</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFADD  databases  <span class="string">&quot;PostgreSQL&quot;</span>    <span class="comment"># 添加一个不存在的元素</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span></span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>这个功能可以将用户给定的地理位置（经度和纬度）信息储存起来，并对这些信息进行操作。</p>
<h4 id="GEO-命令"><a href="#GEO-命令" class="headerlink" title="GEO 命令"></a>GEO 命令</h4><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geoadd.html">GEOADD</a> - 将指定的地理空间位置（纬度、经度、名称）添加到指定的 key 中。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geopos.html">GEOPOS</a> - 从 key 里返回所有给定位置元素的位置（经度和纬度）。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geodist.html">GEODIST</a> - 返回两个给定位置之间的距离。</li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/geohash.html">GEOHASH</a> - 回一个或多个位置元素的标准 Geohash 值，它可以在<a target="_blank" rel="noopener" href="http://geohash.org/%E4%BD%BF%E7%94%A8%E3%80%82">http://geohash.org/使用。</a></li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/georadius.html">GEORADIUS</a></li>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/geo/georadiusbymember.html">GEORADIUSBYMEMBER</a></li>
</ul>
<h2 id="三、Redis-数据类型应用"><a href="#三、Redis-数据类型应用" class="headerlink" title="三、Redis 数据类型应用"></a>三、Redis 数据类型应用</h2><h3 id="案例-最受欢迎文章"><a href="#案例-最受欢迎文章" class="headerlink" title="案例-最受欢迎文章"></a>案例-最受欢迎文章</h3><p>选出最受欢迎文章，需要支持对文章进行评分。</p>
<h4 id="对文章进行投票"><a href="#对文章进行投票" class="headerlink" title="对文章进行投票"></a>对文章进行投票</h4><p>（1）使用 HASH 存储文章</p>
<p>使用 <code>HASH</code> 类型存储文章信息。其中：key 是文章 ID；field 是文章的属性 key；value 是属性对应值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225143038.jpg" alt="img"></p>
<p>操作：</p>
<ul>
<li>存储文章信息 - 使用 <code>HSET</code> 或 <code>HMGET</code> 命令</li>
<li>查询文章信息 - 使用 <code>HGETALL</code> 命令</li>
<li>添加投票 - 使用 <code>HINCRBY</code> 命令</li>
</ul>
<p>（2）使用 <code>ZSET</code> 针对不同维度集合排序</p>
<p>使用 <code>ZSET</code> 类型分别存储按照时间排序和按照评分排序的文章 ID 集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225145742.jpg" alt="img"></p>
<p>操作：</p>
<ul>
<li>添加记录 - 使用 <code>ZADD</code> 命令</li>
<li>添加分数 - 使用 <code>ZINCRBY</code> 命令</li>
<li>取出多篇文章 - 使用 <code>ZREVRANGE</code> 命令</li>
</ul>
<p>（3）为了防止重复投票，使用 <code>SET</code> 类型记录每篇文章 ID 对应的投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225150105.jpg" alt="img"></p>
<p>操作：</p>
<ul>
<li>添加投票者 - 使用 <code>SADD</code> 命令</li>
<li>设置有效期 - 使用 <code>EXPIRE</code> 命令</li>
</ul>
<p>（4）假设 user:115423 给 article:100408 投票，分别需要高更新评分排序集合以及投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225150138.jpg" alt="img"></p>
<p>当需要对一篇文章投票时，程序需要用 ZSCORE 命令检查记录文章发布时间的有序集合，判断文章的发布时间是否超过投票有效期（比如：一星期）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">articleVote</span><span class="params">(Jedis conn, String user, String article)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算文章的投票截止时间。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">cutoff</span> <span class="operator">=</span> (System.currentTimeMillis() / <span class="number">1000</span>) - ONE_WEEK_IN_SECONDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否还可以对文章进行投票</span></span><br><span class="line">    <span class="comment">// （虽然使用散列也可以获取文章的发布时间，</span></span><br><span class="line">    <span class="comment">// 但有序集合返回的文章发布时间为浮点数，</span></span><br><span class="line">    <span class="comment">// 可以不进行转换直接使用）。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.zscore(<span class="string">&quot;time:&quot;</span>, article) &lt; cutoff) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从article:id标识符（identifier）里面取出文章的ID。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">articleId</span> <span class="operator">=</span> article.substring(article.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户是第一次为这篇文章投票，那么增加这篇文章的投票数量和评分。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.sadd(<span class="string">&quot;voted:&quot;</span> + articleId, user) == <span class="number">1</span>) &#123;</span><br><span class="line">        conn.zincrby(<span class="string">&quot;score:&quot;</span>, VOTE_SCORE, article);</span><br><span class="line">        conn.hincrBy(article, <span class="string">&quot;votes&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发布并获取文章"><a href="#发布并获取文章" class="headerlink" title="发布并获取文章"></a>发布并获取文章</h4><p>发布文章：</p>
<ul>
<li>添加文章 - 使用 <code>INCR</code> 命令计算新的文章 ID，填充文章信息，然后用 <code>HSET</code> 命令或 <code>HMSET</code> 命令写入到 <code>HASH</code> 结构中。</li>
<li>将文章作者 ID 添加到投票名单 - 使用 <code>SADD</code> 命令添加到代表投票名单的 <code>SET</code> 结构中。</li>
<li>设置投票有效期 - 使用 <code>EXPIRE</code> 命令设置投票有效期。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postArticle</span><span class="params">(Jedis conn, String user, String title, String link)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成一个新的文章ID。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">articleId</span> <span class="operator">=</span> String.valueOf(conn.incr(<span class="string">&quot;article:&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">voted</span> <span class="operator">=</span> <span class="string">&quot;voted:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将发布文章的用户添加到文章的已投票用户名单里面，</span></span><br><span class="line">    conn.sadd(voted, user);</span><br><span class="line">    <span class="comment">// 然后将这个名单的过期时间设置为一周（第3章将对过期时间作更详细的介绍）。</span></span><br><span class="line">    conn.expire(voted, ONE_WEEK_IN_SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;article:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章信息存储到一个散列里面。</span></span><br><span class="line">    HashMap&lt;String, String&gt; articleData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    articleData.put(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line">    articleData.put(<span class="string">&quot;link&quot;</span>, link);</span><br><span class="line">    articleData.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    articleData.put(<span class="string">&quot;now&quot;</span>, String.valueOf(now));</span><br><span class="line">    articleData.put(<span class="string">&quot;votes&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    conn.hmset(article, articleData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文章添加到根据发布时间排序的有序集合和根据评分排序的有序集合里面。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;score:&quot;</span>, now + VOTE_SCORE, article);</span><br><span class="line">    conn.zadd(<span class="string">&quot;time:&quot;</span>, now, article);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articleId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分页查询最受欢迎文章：</p>
<p>使用 <code>ZINTERSTORE</code> 命令根据页码、每页记录数、排序号，根据评分值从大到小分页查出文章 ID 列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">getArticles</span><span class="params">(Jedis conn, <span class="type">int</span> page, String order)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置获取文章的起始索引和结束索引。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (page - <span class="number">1</span>) * ARTICLES_PER_PAGE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + ARTICLES_PER_PAGE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多个文章ID。</span></span><br><span class="line">    Set&lt;String&gt; ids = conn.zrevrange(order, start, end);</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; articles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根据文章ID获取文章的详细信息。</span></span><br><span class="line">    <span class="keyword">for</span> (String id : ids) &#123;</span><br><span class="line">        Map&lt;String, String&gt; articleData = conn.hgetAll(id);</span><br><span class="line">        articleData.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        articles.add(articleData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对文章进行分组"><a href="#对文章进行分组" class="headerlink" title="对文章进行分组"></a>对文章进行分组</h4><p>如果文章需要分组，功能需要分为两块：</p>
<ul>
<li>记录文章属于哪个群组</li>
<li>负责取出群组里的文章</li>
</ul>
<p>将文章添加、删除群组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addRemoveGroups</span><span class="params">(Jedis conn, String articleId, String[] toAdd, String[] toRemove)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建存储文章信息的键名。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;article:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章添加到它所属的群组里面。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toAdd) &#123;</span><br><span class="line">        conn.sadd(<span class="string">&quot;group:&quot;</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从群组里面移除文章。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toRemove) &#123;</span><br><span class="line">        conn.srem(<span class="string">&quot;group:&quot;</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取出群组里的文章：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225214210.jpg" alt="img"></p>
<ul>
<li>通过对存储群组文章的集合和存储文章评分的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章评分排序的群组文章。</li>
<li>通过对存储群组文章的集合和存储文章发布时间的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章发布时间排序的群组文章。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">getGroupArticles</span><span class="params">(Jedis conn, String group, <span class="type">int</span> page, String order)</span> &#123;</span><br><span class="line">    <span class="comment">// 为每个群组的每种排列顺序都创建一个键。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> order + group;</span><br><span class="line">    <span class="comment">// 检查是否有已缓存的排序结果，如果没有的话就现在进行排序。</span></span><br><span class="line">    <span class="keyword">if</span> (!conn.exists(key)) &#123;</span><br><span class="line">        <span class="comment">// 根据评分或者发布时间，对群组文章进行排序。</span></span><br><span class="line">        <span class="type">ZParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZParams</span>().aggregate(ZParams.Aggregate.MAX);</span><br><span class="line">        conn.zinterstore(key, params, <span class="string">&quot;group:&quot;</span> + group, order);</span><br><span class="line">        <span class="comment">// 让Redis在60秒钟之后自动删除这个有序集合。</span></span><br><span class="line">        conn.expire(key, <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用之前定义的getArticles函数来进行分页并获取文章数据。</span></span><br><span class="line">    <span class="keyword">return</span> getArticles(conn, page, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-管理令牌"><a href="#案例-管理令牌" class="headerlink" title="案例-管理令牌"></a>案例-管理令牌</h3><p>网站一般会以 Cookie、Session、令牌这类信息存储用户身份信息。</p>
<p>可以将 Cookie&#x2F;Session&#x2F;令牌 和用户的映射关系存储在 <code>HASH</code> 结构。</p>
<p>下面以令牌来举例。</p>
<h4 id="查询令牌"><a href="#查询令牌" class="headerlink" title="查询令牌"></a>查询令牌</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">checkToken</span><span class="params">(Jedis conn, String token)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取并返回令牌对应的用户。</span></span><br><span class="line">    <span class="keyword">return</span> conn.hget(<span class="string">&quot;login:&quot;</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h4><ul>
<li>用户每次访问页面，可以记录下令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中，以便分析用户是否活跃，继而可以周期性清理最老的令牌，统计当前在线用户数等行为。</li>
<li>用户如果正在浏览商品，可以记录到用户最近浏览过的商品有序集合中（集合可以限定数量，超过数量进行裁剪），存入到一个 <code>ZSET</code> 结构中，以便分析用户最近可能感兴趣的商品，以便推荐商品。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateToken</span><span class="params">(Jedis conn, String token, String user, String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间戳。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 维持令牌与已登录用户之间的映射。</span></span><br><span class="line">    conn.hset(<span class="string">&quot;login:&quot;</span>, token, user);</span><br><span class="line">    <span class="comment">// 记录令牌最后一次出现的时间。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;recent:&quot;</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录用户浏览过的商品。</span></span><br><span class="line">        conn.zadd(<span class="string">&quot;viewed:&quot;</span> + token, timestamp, item);</span><br><span class="line">        <span class="comment">// 移除旧的记录，只保留用户最近浏览过的25个商品。</span></span><br><span class="line">        conn.zremrangeByRank(<span class="string">&quot;viewed:&quot;</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        conn.zincrby(<span class="string">&quot;viewed:&quot;</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清理令牌"><a href="#清理令牌" class="headerlink" title="清理令牌"></a>清理令牌</h4><p>上一节提到，更新令牌时，将令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中。所以可以通过排序得知哪些令牌最老。如果没有清理操作，更新令牌占用的内存会不断膨胀，直到导致机器宕机。</p>
<p>比如：最多允许存储 1000 万条令牌信息，周期性检查，一旦发现记录数超出 1000 万条，将 ZSET 从新到老排序，将超出 1000 万条的记录清除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CleanSessionsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> quit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CleanSessionsThread</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.conn.select(<span class="number">15</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        quit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            <span class="comment">// 找出目前已有令牌的数量。</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> conn.zcard(<span class="string">&quot;recent:&quot;</span>);</span><br><span class="line">            <span class="comment">// 令牌数量未超过限制，休眠并在之后重新检查。</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要移除的令牌ID。</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">endIndex</span> <span class="operator">=</span> Math.min(size - limit, <span class="number">100</span>);</span><br><span class="line">            Set&lt;String&gt; tokenSet = conn.zrange(<span class="string">&quot;recent:&quot;</span>, <span class="number">0</span>, endIndex - <span class="number">1</span>);</span><br><span class="line">            String[] tokens = tokenSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[tokenSet.size()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为那些将要被删除的令牌构建键名。</span></span><br><span class="line">            ArrayList&lt;String&gt; sessionKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">                sessionKeys.add(<span class="string">&quot;viewed:&quot;</span> + token);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除最旧的那些令牌。</span></span><br><span class="line">            conn.del(sessionKeys.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[sessionKeys.size()]));</span><br><span class="line">            conn.hdel(<span class="string">&quot;login:&quot;</span>, tokens);</span><br><span class="line">            conn.zrem(<span class="string">&quot;recent:&quot;</span>, tokens);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-购物车"><a href="#案例-购物车" class="headerlink" title="案例-购物车"></a>案例-购物车</h3><p>可以使用 HASH 结构来实现购物车功能。</p>
<p>每个用户的购物车，存储了商品 ID 和商品数量的映射。</p>
<h4 id="在购物车中添加、删除商品"><a href="#在购物车中添加、删除商品" class="headerlink" title="在购物车中添加、删除商品"></a>在购物车中添加、删除商品</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToCart</span><span class="params">(Jedis conn, String session, String item, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从购物车里面移除指定的商品。</span></span><br><span class="line">        conn.hdel(<span class="string">&quot;cart:&quot;</span> + session, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将指定的商品添加到购物车。</span></span><br><span class="line">        conn.hset(<span class="string">&quot;cart:&quot;</span> + session, item, String.valueOf(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h4><p>在 <a href="#%E6%B8%85%E7%90%86%E4%BB%A4%E7%89%8C">清理令牌</a> 的基础上，清空会话时，顺便将购物车缓存一并清理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> conn.zcard(<span class="string">&quot;recent:&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (size &lt;= limit) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> <span class="variable">endIndex</span> <span class="operator">=</span> Math.min(size - limit, <span class="number">100</span>);</span><br><span class="line">     Set&lt;String&gt; sessionSet = conn.zrange(<span class="string">&quot;recent:&quot;</span>, <span class="number">0</span>, endIndex - <span class="number">1</span>);</span><br><span class="line">     String[] sessions = sessionSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[sessionSet.size()]);</span><br><span class="line"></span><br><span class="line">     ArrayList&lt;String&gt; sessionKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">     <span class="keyword">for</span> (String sess : sessions) &#123;</span><br><span class="line">         sessionKeys.add(<span class="string">&quot;viewed:&quot;</span> + sess);</span><br><span class="line">         <span class="comment">// 新增加的这行代码用于删除旧会话对应用户的购物车。</span></span><br><span class="line">         sessionKeys.add(<span class="string">&quot;cart:&quot;</span> + sess);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     conn.del(sessionKeys.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[sessionKeys.size()]));</span><br><span class="line">     conn.hdel(<span class="string">&quot;login:&quot;</span>, sessions);</span><br><span class="line">     conn.zrem(<span class="string">&quot;recent:&quot;</span>, sessions);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-页面缓存"><a href="#案例-页面缓存" class="headerlink" title="案例-页面缓存"></a>案例-页面缓存</h3><p>大部分网页内容并不会经常改变，但是访问时，后台需要动态计算，这可能耗时较多，此时可以使用 <code>STRING</code> 结构存储页面缓存，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">cacheRequest</span><span class="params">(Jedis conn, String request, Callback callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于不能被缓存的请求，直接调用回调函数。</span></span><br><span class="line">    <span class="keyword">if</span> (!canCache(conn, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback != <span class="literal">null</span> ? callback.call(request) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将请求转换成一个简单的字符串键，方便之后进行查找。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">pageKey</span> <span class="operator">=</span> <span class="string">&quot;cache:&quot;</span> + hashRequest(request);</span><br><span class="line">    <span class="comment">// 尝试查找被缓存的页面。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> conn.get(pageKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content == <span class="literal">null</span> &amp;&amp; callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果页面还没有被缓存，那么生成页面。</span></span><br><span class="line">        content = callback.call(request);</span><br><span class="line">        <span class="comment">// 将新生成的页面放到缓存里面。</span></span><br><span class="line">        conn.setex(pageKey, <span class="number">300</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回页面。</span></span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-数据行缓存"><a href="#案例-数据行缓存" class="headerlink" title="案例-数据行缓存"></a>案例-数据行缓存</h3><p>电商网站可能会有促销、特卖、抽奖等活动，这些活动页面只需要从数据库中加载几行数据，如：用户信息、商品信息。</p>
<p>可以使用 <code>STRING</code> 结构来缓存这些数据，使用 JSON 存储结构化的信息。</p>
<p>此外，需要有两个 <code>ZSET</code> 结构来记录更新缓存的时机：</p>
<ul>
<li>第一个为调度有序集合；</li>
<li>第二个为延时有序集合。</li>
</ul>
<p>记录缓存时机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleRowCache</span><span class="params">(Jedis conn, String rowId, <span class="type">int</span> delay)</span> &#123;</span><br><span class="line">    <span class="comment">// 先设置数据行的延迟值。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;delay:&quot;</span>, delay, rowId);</span><br><span class="line">    <span class="comment">// 立即缓存数据行。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;schedule:&quot;</span>, System.currentTimeMillis() / <span class="number">1000</span>, rowId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时更新数据行缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRowsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> quit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheRowsThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.conn.select(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        quit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取下一个需要被缓存的数据行以及该行的调度时间戳，</span></span><br><span class="line">            <span class="comment">// 命令会返回一个包含零个或一个元组（tuple）的列表。</span></span><br><span class="line">            Set&lt;Tuple&gt; range = conn.zrangeWithScores(<span class="string">&quot;schedule:&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">next</span> <span class="operator">=</span> range.size() &gt; <span class="number">0</span> ? range.iterator().next() : <span class="literal">null</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span> || next.getScore() &gt; now) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 暂时没有行需要被缓存，休眠50毫秒后重试。</span></span><br><span class="line">                    sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rowId</span> <span class="operator">=</span> next.getElement();</span><br><span class="line">            <span class="comment">// 获取下一次调度前的延迟时间。</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">delay</span> <span class="operator">=</span> conn.zscore(<span class="string">&quot;delay:&quot;</span>, rowId);</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 不必再缓存这个行，将它从缓存中移除。</span></span><br><span class="line">                conn.zrem(<span class="string">&quot;delay:&quot;</span>, rowId);</span><br><span class="line">                conn.zrem(<span class="string">&quot;schedule:&quot;</span>, rowId);</span><br><span class="line">                conn.del(<span class="string">&quot;inv:&quot;</span> + rowId);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据行。</span></span><br><span class="line">            <span class="type">Inventory</span> <span class="variable">row</span> <span class="operator">=</span> Inventory.get(rowId);</span><br><span class="line">            <span class="comment">// 更新调度时间并设置缓存值。</span></span><br><span class="line">            conn.zadd(<span class="string">&quot;schedule:&quot;</span>, now + delay, rowId);</span><br><span class="line">            conn.set(<span class="string">&quot;inv:&quot;</span> + rowId, gson.toJson(row));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-网页分析"><a href="#案例-网页分析" class="headerlink" title="案例-网页分析"></a>案例-网页分析</h3><p>网站可以采集用户的访问、交互、购买行为，再分析用户习惯、喜好，从而判断市场行情和潜在商机等。</p>
<p>那么，简单的，如何记录用户在一定时间内访问的商品页面呢？</p>
<p>参考 <a href="#%E6%9B%B4%E6%96%B0%E4%BB%A4%E7%89%8C">更新令牌</a> 代码示例，记录用户访问不同商品的浏览次数，并排序。</p>
<p>判断页面是否需要缓存，根据评分判断商品页面是否热门：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canCache</span><span class="params">(Jedis conn, String request)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(request);</span><br><span class="line">        HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (url.getQuery() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String param : url.getQuery().split(<span class="string">&quot;&amp;&quot;</span>)) &#123;</span><br><span class="line">                String[] pair = param.split(<span class="string">&quot;=&quot;</span>, <span class="number">2</span>);</span><br><span class="line">                params.put(pair[<span class="number">0</span>], pair.length == <span class="number">2</span> ? pair[<span class="number">1</span>] : <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从页面里面取出商品ID。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itemId</span> <span class="operator">=</span> extractItemId(params);</span><br><span class="line">        <span class="comment">// 检查这个页面能否被缓存以及这个页面是否为商品页面。</span></span><br><span class="line">        <span class="keyword">if</span> (itemId == <span class="literal">null</span> || isDynamic(params)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取得商品的浏览次数排名。</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">rank</span> <span class="operator">=</span> conn.zrank(<span class="string">&quot;viewed:&quot;</span>, itemId);</span><br><span class="line">        <span class="comment">// 根据商品的浏览次数排名来判断是否需要缓存这个页面。</span></span><br><span class="line">        <span class="keyword">return</span> rank != <span class="literal">null</span> &amp;&amp; rank &lt; <span class="number">10000</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException mue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-记录日志"><a href="#案例-记录日志" class="headerlink" title="案例-记录日志"></a>案例-记录日志</h3><p>可用使用 <code>LIST</code> 结构存储日志数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logRecent</span><span class="params">(Jedis conn, String name, String message, String severity)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> <span class="string">&quot;recent:&quot;</span> + name + <span class="string">&#x27;:&#x27;</span> + severity;</span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> conn.pipelined();</span><br><span class="line">    pipe.lpush(destination, TIMESTAMP.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&#x27; &#x27;</span> + message);</span><br><span class="line">    pipe.ltrim(destination, <span class="number">0</span>, <span class="number">99</span>);</span><br><span class="line">    pipe.sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-统计数据"><a href="#案例-统计数据" class="headerlink" title="案例-统计数据"></a>案例-统计数据</h3><p>更新计数器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] PRECISION = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">60</span>, <span class="number">300</span>, <span class="number">3600</span>, <span class="number">18000</span>, <span class="number">86400</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCounter</span><span class="params">(Jedis conn, String name, <span class="type">int</span> count, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">trans</span> <span class="operator">=</span> conn.multi();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> prec : PRECISION) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">pnow</span> <span class="operator">=</span> (now / prec) * prec;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hash</span> <span class="operator">=</span> String.valueOf(prec) + <span class="string">&#x27;:&#x27;</span> + name;</span><br><span class="line">        trans.zadd(<span class="string">&quot;known:&quot;</span>, <span class="number">0</span>, hash);</span><br><span class="line">        trans.hincrBy(<span class="string">&quot;count:&quot;</span> + hash, String.valueOf(pnow), count);</span><br><span class="line">    &#125;</span><br><span class="line">    trans.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看计数器数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Pair&lt;Integer&gt;&gt; <span class="title function_">getCounter</span><span class="params">(</span></span><br><span class="line"><span class="params">    Jedis conn, String name, <span class="type">int</span> precision)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hash</span> <span class="operator">=</span> String.valueOf(precision) + <span class="string">&#x27;:&#x27;</span> + name;</span><br><span class="line">    Map&lt;String, String&gt; data = conn.hgetAll(<span class="string">&quot;count:&quot;</span> + hash);</span><br><span class="line">    List&lt;Pair&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">        results.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(</span><br><span class="line">            entry.getKey(),</span><br><span class="line">            Integer.parseInt(entry.getValue())));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(results);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-查找-IP-所属地"><a href="#案例-查找-IP-所属地" class="headerlink" title="案例-查找 IP 所属地"></a>案例-查找 IP 所属地</h3><p>Redis 实现的 IP 所属地查找比关系型数据实现方式更快。</p>
<h4 id="载入-IP-数据"><a href="#载入-IP-数据" class="headerlink" title="载入 IP 数据"></a>载入 IP 数据</h4><p>IP 地址转为整数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ipToScore</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String v : ipAddress.split(<span class="string">&quot;\\.&quot;</span>)) &#123;</span><br><span class="line">        score = score * <span class="number">256</span> + Integer.parseInt(v, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 IP 地址与城市 ID 之间的映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importIpsToRedis</span><span class="params">(Jedis conn, File file)</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 载入 csv 文件数据</span></span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">CSVFormat</span> <span class="variable">csvFormat</span> <span class="operator">=</span> CSVFormat.DEFAULT.withRecordSeparator(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">CSVParser</span> <span class="variable">csvParser</span> <span class="operator">=</span> csvFormat.parse(reader);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;CSVRecord&gt; records = csvParser.getRecords();</span><br><span class="line">        <span class="keyword">for</span> (CSVRecord line : records) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">startIp</span> <span class="operator">=</span> line.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (startIp.toLowerCase().indexOf(<span class="string">&#x27;i&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 IP 地址转为整数值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (startIp.indexOf(<span class="string">&#x27;.&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                score = ipToScore(startIp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    score = Integer.parseInt(startIp, <span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// 略过文件的第一行以及格式不正确的条目</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建唯一的城市 ID</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cityId</span> <span class="operator">=</span> line.get(<span class="number">2</span>) + <span class="string">&#x27;_&#x27;</span> + count;</span><br><span class="line">            <span class="comment">// 将城市 ID 及其对应的 IP 地址整数值添加到 ZSET</span></span><br><span class="line">            conn.zadd(<span class="string">&quot;ip2cityid:&quot;</span>, score, cityId);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储城市信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importCitiesToRedis</span><span class="params">(Jedis conn, File file)</span> &#123;</span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载 csv 信息</span></span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">CSVFormat</span> <span class="variable">csvFormat</span> <span class="operator">=</span> CSVFormat.DEFAULT.withRecordSeparator(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">CSVParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSVParser</span>(reader, csvFormat);</span><br><span class="line">        <span class="comment">// String[] line;</span></span><br><span class="line">        List&lt;CSVRecord&gt; records = parser.getRecords();</span><br><span class="line">        <span class="keyword">for</span> (CSVRecord record : records) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record.size() &lt; <span class="number">4</span> || !Character.isDigit(record.get(<span class="number">0</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将城市地理信息转为 json 结构，存入 HASH 结构中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cityId</span> <span class="operator">=</span> record.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> record.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">region</span> <span class="operator">=</span> record.get(<span class="number">2</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> record.get(<span class="number">3</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; city, region, country &#125;);</span><br><span class="line">            conn.hset(<span class="string">&quot;cityid2city:&quot;</span>, cityId, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找-IP-所属城市"><a href="#查找-IP-所属城市" class="headerlink" title="查找 IP 所属城市"></a>查找 IP 所属城市</h4><p>操作步骤：</p>
<ol>
<li>将要查找的 IP 地址转为整数值；</li>
<li>查找所有分值小于等于要查找的 IP 地址的地址，取出其中最大分值的那个记录；</li>
<li>用找到的记录所对应的城市 ID 去检索城市信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findCityByIp(Jedis conn, String ipAddress) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> ipToScore(ipAddress);</span><br><span class="line">    Set&lt;String&gt; results = conn.zrevrangeByScore(<span class="string">&quot;ip2cityid:&quot;</span>, score, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (results.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">cityId</span> <span class="operator">=</span> results.iterator().next();</span><br><span class="line">    cityId = cityId.substring(<span class="number">0</span>, cityId.indexOf(<span class="string">&#x27;_&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(conn.hget(<span class="string">&quot;cityid2city:&quot;</span>, cityId), String[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-服务的发现与配置"><a href="#案例-服务的发现与配置" class="headerlink" title="案例-服务的发现与配置"></a>案例-服务的发现与配置</h3><h3 id="案例-自动补全"><a href="#案例-自动补全" class="headerlink" title="案例-自动补全"></a>案例-自动补全</h3><p>需求：根据用户输入，自动补全信息，如：联系人、商品名等。</p>
<ul>
<li>典型场景一：社交网站后台记录用户最近联系过的 100 个好友，当用户查找好友时，根据输入的关键字自动补全姓名。</li>
<li>典型场景二：电商网站后台记录用户最近浏览过的 10 件商品，当用户查找商品是，根据输入的关键字自动补全商品名称。</li>
</ul>
<p>数据模型：使用 Redis 的 LIST 类型存储最近联系人列表。</p>
<p>构建自动补全列表通常有以下操作：</p>
<ul>
<li>如果指定联系人已经存在于最近联系人列表里，那么从列表里移除他。对应 <code>LREM</code> 命令。</li>
<li>将指定联系人添加到最近联系人列表的最前面。对应 <code>LPUSH</code> 命令。</li>
<li>添加操作完成后，如果联系人列表中的数量超过 100 个，进行裁剪操作。对应 <code>LTRIM</code> 命令。</li>
</ul>
<h3 id="案例-广告定向"><a href="#案例-广告定向" class="headerlink" title="案例-广告定向"></a>案例-广告定向</h3><h3 id="案例-职位搜索"><a href="#案例-职位搜索" class="headerlink" title="案例-职位搜索"></a>案例-职位搜索</h3><p>需求：在一个招聘网站上，求职者有自己的技能清单；用人公司的职位有必要的技能清单。用人公司需要查询满足自己职位要求的求职者；求职者需要查询自己可以投递简历的职位。</p>
<p>关键数据模型：使用 <code>SET</code> 类型存储求职者的技能列表，使用 <code>SET</code> 类型存储职位的技能列表。</p>
<p>关键操作：使用 <code>SDIFF</code> 命令对比两个 <code>SET</code> 的差异，返回 <code>empty</code> 表示匹配要求。</p>
<p>redis cli 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis 职位搜索数据模型示例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（1）职位技能表：使用 <span class="built_in">set</span> 存储</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">job:001 职位添加 4 种技能</span></span><br><span class="line">SADD job:001 skill:001</span><br><span class="line">SADD job:001 skill:002</span><br><span class="line">SADD job:001 skill:003</span><br><span class="line">SADD job:001 skill:004</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">job:002 职位添加 3 种技能</span></span><br><span class="line">SADD job:002 skill:001</span><br><span class="line">SADD job:002 skill:002</span><br><span class="line">SADD job:002 skill:003</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">job:003 职位添加 2 种技能</span></span><br><span class="line">SADD job:003 skill:001</span><br><span class="line">SADD job:003 skill:003</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">SMEMBERS job:001</span><br><span class="line">SMEMBERS job:002</span><br><span class="line">SMEMBERS job:003</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（2）求职者技能表：使用 <span class="built_in">set</span> 存储</span></span><br><span class="line">SADD interviewee:001 skill:001</span><br><span class="line">SADD interviewee:001 skill:003</span><br><span class="line"></span><br><span class="line">SADD interviewee:002 skill:001</span><br><span class="line">SADD interviewee:002 skill:002</span><br><span class="line">SADD interviewee:002 skill:003</span><br><span class="line">SADD interviewee:002 skill:004</span><br><span class="line">SADD interviewee:002 skill:005</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">SMEMBERS interviewee:001</span><br><span class="line">SMEMBERS interviewee:002</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（3）求职者遍历查找自己符合要求的职位（返回结果为 empty 表示要求的技能全部命中）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较职位技能清单和求职者技能清单的差异</span></span><br><span class="line">SDIFF job:001 interviewee:001</span><br><span class="line">SDIFF job:002 interviewee:001</span><br><span class="line">SDIFF job:003 interviewee:001</span><br><span class="line"></span><br><span class="line">SDIFF job:001 interviewee:002</span><br><span class="line">SDIFF job:002 interviewee:002</span><br><span class="line">SDIFF job:003 interviewee:002</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（4）用人公司根据遍历查找符合自己职位要求的求职者（返回结果为 empty 表示要求的技能全部命中）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较职位技能清单和求职者技能清单的差异</span></span><br><span class="line">SDIFF interviewee:001 job:001</span><br><span class="line">SDIFF interviewee:002 job:001</span><br><span class="line"></span><br><span class="line">SDIFF interviewee:001 job:002</span><br><span class="line">SDIFF interviewee:002 job:002</span><br><span class="line"></span><br><span class="line">SDIFF interviewee:001 job:003</span><br><span class="line">SDIFF interviewee:002 job:003</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官网</strong><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011957758/article/details/74783347">一看就懂系列之 详解 redis 的 bitmap 在亿级项目中的应用</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">Fast, easy, realtime metrics using Redis bitmaps</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/4de901/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/4de901/" class="post-title-link" itemprop="url">Redis 持久化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><blockquote>
<p>Redis 支持持久化，即把数据存储到硬盘中。</p>
<p>Redis 提供了两种持久化方式：</p>
<ul>
<li><strong><code>RDB 快照（snapshot）</code></strong> - 将存在于某一时刻的所有数据都写入到硬盘中。</li>
<li><strong><code>只追加文件（append-only file，AOF）</code></strong> - 它会在执行写命令时，将被执行的写命令复制到硬盘中。</li>
</ul>
<p>这两种持久化方式既可以同时使用，也可以单独使用。</p>
<p>将内存中的数据存储到硬盘的一个主要原因是为了在之后重用数据，或者是为了防止系统故障而将数据备份到一个远程位置。另外，存储在 Redis 里面的数据有可能是经过长时间计算得出的，或者有程序正在使用 Redis 存储的数据进行计算，所以用户会希望自己可以将这些数据存储起来以便之后使用，这样就不必重新计算了。</p>
<p>Redis 提供了两种持久方式：RDB 和 AOF。你可以同时开启两种持久化方式。在这种情况下, 当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p>
</blockquote>
<h2 id="一、RDB"><a href="#一、RDB" class="headerlink" title="一、RDB"></a>一、RDB</h2><h3 id="RDB-简介"><a href="#RDB-简介" class="headerlink" title="RDB 简介"></a>RDB 简介</h3><p><strong>RDB 即快照方式，它将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中</strong>。</p>
<p>创建 RDB 后，用户可以对 RDB 进行<strong>备份</strong>，可以将 RDB <strong>复制</strong>到其他服务器从而创建具有相同数据的服务器副本，还可以在<strong>重启</strong>服务器时使用。一句话来说：RDB 适合作为 <strong>冷备</strong>。</p>
<p>RDB 既可以手动执行，也可以根据服务器配置选项定期执行。该功能可以将某个时间点的数据库状态保存到一个 RDB 文件中。</p>
<h4 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h4><ul>
<li>RDB 文件非常紧凑，<strong>适合作为冷备</strong>。比如你可以在每个小时报保存一下过去 24 小时内的数据，同时每天保存过去 30 天的数据，这样即使出了问题你也可以根据需求恢复到不同版本的数据集。</li>
<li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 Redis 的性能。</li>
<li><strong>恢复大数据集时，RDB 比 AOF 更快</strong>。</li>
</ul>
<h4 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h4><ul>
<li><strong>如果系统发生故障，将会丢失最后一次创建快照之后的数据</strong>。如果你希望在 Redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 快照不适合你。虽然你可以配置不同的 save 时间点(例如每隔 5 分钟并且对数据集有 100 个写的操作)，是 Redis 要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔 5 分钟或者更久做一次完整的保存，万一在 Redis 意外宕机，你可能会丢失几分钟的数据。</li>
<li><strong>如果数据量很大，保存快照的时间会很长</strong>。快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续 1 秒。AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。</li>
</ul>
<h3 id="RDB-的创建"><a href="#RDB-的创建" class="headerlink" title="RDB 的创建"></a>RDB 的创建</h3><p>有两个 Redis 命令可以用于生成 RDB 文件：<code>SAVE</code> 和 <code>BGSAVE</code>。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/commands/save"><strong><code>SAVE</code></strong></a> 命令会阻塞 Redis 服务器进程，直到 RDB 创建完成为止，在阻塞期间，服务器不能响应任何命令请求。</li>
<li><a target="_blank" rel="noopener" href="https://redis.io/commands/bgsave"><strong><code>BGSAVE</code></strong></a> 命令会派生出（fork）一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求。</li>
</ul>
<blockquote>
<p>:bell: 注意：<code>BGSAVE</code> 命令执行期间，<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code> 三个命令会被拒绝，以免与当前的 <code>BGSAVE</code> 操作产生竞态条件，降低性能。</p>
</blockquote>
<h4 id="自动间隔保存"><a href="#自动间隔保存" class="headerlink" title="自动间隔保存"></a>自动间隔保存</h4><p>Redis 允许用户通过设置服务器配置的 <code>save</code> 选项，让服务器每隔一段时间自动执行一次 <code>BGSAVE</code> 命令。</p>
<p>用户可以通过 <code>save</code> 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 <code>BGSAVE</code> 命令。</p>
<p>举例来说，<code>redis.conf</code> 中设置了如下配置：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span>       -- <span class="number">900</span> 秒内，至少对数据库进行了 <span class="number">1</span> 次修改</span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span>      -- <span class="number">300</span> 秒内，至少对数据库进行了 <span class="number">10</span> 次修改</span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span>    -- <span class="number">60</span> 秒内，至少对数据库进行了 <span class="number">10000</span> 次修改</span><br></pre></td></tr></table></figure>

<p>只要满足以上任意条件，Redis 服务就会执行 BGSAVE 命令。</p>
<h3 id="RDB-的载入"><a href="#RDB-的载入" class="headerlink" title="RDB 的载入"></a>RDB 的载入</h3><p><strong>RDB 文件的载入工作是在服务器启动时自动执行的</strong>，Redis 并没有专门用于载入 RDB 文件的命令。</p>
<p>服务器载入 RDB 文件期间，会一直处于阻塞状态，直到载入完成为止。</p>
<blockquote>
<p>🔔 注意：因为 AOF 通常更新频率比 RDB 高，所以丢失数据相对更少。基于这个原因，Redis 有以下默认行为：</p>
<ul>
<li>只有在关闭 AOF 功能的情况下，才会使用 RDB 还原数据，否则优先使用 AOF 文件来还原数据。</li>
</ul>
</blockquote>
<h3 id="RDB-的文件结构"><a href="#RDB-的文件结构" class="headerlink" title="RDB 的文件结构"></a>RDB 的文件结构</h3><p>RDB 文件是一个经过压缩的二进制文件，由多个部分组成。</p>
<p>对于不同类型（STRING、HASH、LIST、SET、SORTED SET）的键值对，RDB 文件会使用不同的方式来保存它们。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-rdb-structure.png" alt="img"></p>
<p>Redis 本身提供了一个 RDB 文件检查工具 redis-check-dump。</p>
<h3 id="RDB-的配置"><a href="#RDB-的配置" class="headerlink" title="RDB 的配置"></a>RDB 的配置</h3><p>Redis RDB 默认配置如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"><span class="attribute">stop</span>-writes-<span class="literal">on</span>-bgsave-error yes</span><br><span class="line"><span class="attribute">rdbcompression</span> yes</span><br><span class="line"><span class="attribute">rdbchecksum</span> yes</span><br><span class="line"><span class="attribute">dbfilename</span> dump.rdb</span><br><span class="line"><span class="attribute">dir</span> ./</span><br></pre></td></tr></table></figure>

<p>Redis 的配置文件 <code>redis.conf</code> 中与 RDB 有关的选项：</p>
<ul>
<li><p><code>save</code> - Redis 会根据 <code>save</code> 选项，让服务器每隔一段时间自动执行一次 <code>BGSAVE</code> 命令。</p>
</li>
<li><p><code>stop-writes-on-bgsave-error</code> - 当 BGSAVE 命令出现错误时停止写 RDB 文件</p>
</li>
<li><p><code>rdbcompression</code> - RDB 文件开启压缩功能。</p>
</li>
<li><p><code>rdbchecksum</code> - 对 RDB 文件进行校验。</p>
</li>
<li><p><code>dbfilename</code> - RDB 文件名。</p>
</li>
<li><p><code>dir</code> - RDB 文件和 AOF 文件的存储路径。</p>
</li>
</ul>
<h2 id="二、AOF"><a href="#二、AOF" class="headerlink" title="二、AOF"></a>二、AOF</h2><h3 id="AOF-简介"><a href="#AOF-简介" class="headerlink" title="AOF 简介"></a>AOF 简介</h3><p><code>AOF(Append Only File)</code> 是以 <strong>文本日志形式</strong> 将 <strong>所有写命令以 Redis 命令请求协议格式追加到 AOF 文件的末尾</strong>，以此来记录数据的变化。<strong>当服务器重启时，会重新载入和执行 AOF 文件中的命令，就可以恢复原始的数据</strong>。AOF 适合作为 <strong>热备</strong>。</p>
<p>AOF 可以通过 <code>appendonly yes</code> 配置选项来开启。</p>
<p>命令请求会先保存到 AOF 缓冲区中，之后再定期写入并同步到 AOF 文件。</p>
<h4 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h4><ul>
<li><strong>如果系统发生故障，AOF 丢失数据比 RDB 少</strong>。你可以使用不同的 fsync 策略：无 fsync；每秒 fsync；每次写的时候 fsync。使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，你最多丢失 1 秒的数据。</li>
<li><strong>AOF 文件可修复</strong> - AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li>
<li><strong>AOF 文件可压缩</strong>。Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li><strong>AOF 文件可读</strong> - AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 命令的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单。举个例子，如果你不小心执行了 FLUSHALL 命令，但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis ，就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
<h4 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h4><ul>
<li><strong>AOF 文件体积一般比 RDB 大</strong> - 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li><strong>恢复大数据集时，AOF 比 RDB 慢。</strong> - 根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h3 id="AOF-的创建"><a href="#AOF-的创建" class="headerlink" title="AOF 的创建"></a>AOF 的创建</h3><p><strong>Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件</strong>。</p>
<p>AOF 的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<ul>
<li><strong>命令追加</strong> - 当 Redis 服务器开启 AOF 功能时，服务器在执行完一个写命令后，会以 Redis 命令协议格式将被执行的写命令追加到 AOF 缓冲区的末尾。</li>
<li><strong>文件写入</strong>和<strong>文件同步</strong> - Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行定时运行的函数。因为服务器在处理文件事件时可能会执行写命令，这些写命令会被追加到 AOF 缓冲区，服务器每次结束事件循环前，都会根据 <code>appendfsync</code> 选项来判断 AOF 缓冲区内容是否需要写入和同步到 AOF 文件中。</li>
</ul>
<p><code>appendfsync</code> 不同选项决定了不同的持久化行为：</p>
<ul>
<li><strong><code>always</code></strong> - 将缓冲区所有内容写入并同步到 AOF 文件。</li>
<li><strong><code>everysec</code></strong> - 将缓冲区所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，这个同步操作是有一个线程专门负责执行的。</li>
<li><strong><code>no</code></strong> - 将缓冲区所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定。</li>
</ul>
<h3 id="AOF-的载入"><a href="#AOF-的载入" class="headerlink" title="AOF 的载入"></a>AOF 的载入</h3><p>因为 AOF 文件中包含了重建数据库所需的所有写命令，所以服务器只要载入并执行一遍 AOF 文件中保存的写命令，就可以还原服务器关闭前的数据库状态。</p>
<p>AOF 载入过程如下：</p>
<ol>
<li>服务器启动载入程序。</li>
<li>创建一个伪客户端。因为 Redis 命令只能在客户端上下文中执行，所以需要创建一个伪客户端来载入、执行 AOF 文件中记录的命令。</li>
<li>从 AOF 文件中分析并读取一条写命令。</li>
<li>使用伪客户端执行写命令。</li>
<li>循环执行步骤 3、4，直到所有写命令都被处理完毕为止。</li>
<li>载入完毕。</li>
</ol>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-aof-flow.png" />
</div>

<h3 id="AOF-的重写"><a href="#AOF-的重写" class="headerlink" title="AOF 的重写"></a>AOF 的重写</h3><p>随着 Redis 不断运行，AOF 的体积也会不断增长，这将导致两个问题：</p>
<ul>
<li>AOF 耗尽磁盘可用空间。</li>
<li>Redis 重启后需要执行 AOF 文件记录的所有写命令来还原数据集，如果 AOF 过大，则还原操作执行的时间就会非常长。</li>
</ul>
<p>为了解决 AOF 体积膨胀问题，Redis 提供了 AOF 重写功能，来对 AOF 文件进行压缩。<strong>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原来的 AOF 文件所保存的数据库状态一致，但体积更小</strong>。</p>
<p>AOF 重写并非读取和分析现有 AOF 文件的内容，而是直接从数据库中读取当前的数据库状态。即<strong>依次读取数据库中的每个键值对，然后用一条命令去记录该键值对</strong>，以此代替之前可能存在冗余的命令。</p>
<h4 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h4><p>作为一种辅助性功能，显然 Redis 并不想在 AOF 重写时阻塞 Redis 服务接收其他命令。因此，Redis 决定通过 <code>BGREWRITEAOF</code> 命令创建一个子进程，然后由子进程负责对 AOF 文件进行重写，这与 <code>BGSAVE</code> 原理类似。</p>
<ul>
<li>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区。当 AOF 重写子进程开始工作后，Redis 每执行完一个写命令，会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</li>
<li>由于彼此不是在同一个进程中工作，AOF 重写不影响 AOF 写入和同步。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换就的 AOF 文件，以此来完成 AOF 重写操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200130153716.png" alt="img"></p>
<p>可以通过设置 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code>，使得 Redis 在满足条件时，自动执行 <code>BGREWRITEAOF</code>。</p>
<p>假设配置如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>

<p>表明，当 AOF 大于 <code>64MB</code>，且 AOF 体积比上一次重写后的体积大了至少 <code>100%</code> 时，执行 <code>BGREWRITEAOF</code>。</p>
<h3 id="AOF-的配置"><a href="#AOF-的配置" class="headerlink" title="AOF 的配置"></a>AOF 的配置</h3><p>AOF 的默认配置：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly no</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-<span class="built_in">rewrite</span> no</span><br><span class="line"><span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>

<p>AOF 持久化通过在 <code>redis.conf</code> 中的 <code>appendonly yes</code> 配置选项来开启。</p>
<ul>
<li><strong><code>appendonly</code></strong> - 开启 AOF 功能。</li>
<li><strong><code>appendfilename</code></strong> - AOF 文件名。</li>
<li><strong><code>appendfsync</code></strong> - 用于设置同步频率，它有以下可选项：<ul>
<li><strong><code>always</code></strong> - 每个 Redis 写命令都要同步写入硬盘。这样做会严重降低 Redis 的速度。</li>
<li><strong><code>everysec</code></strong> - 每秒执行一次同步，显示地将多个写命令同步到硬盘。为了兼顾数据安全和写入性能，推荐使用 <code>appendfsync everysec</code> 选项。Redis 每秒同步一次 AOF 文件时的性能和不使用任何持久化特性时的性能相差无几。</li>
<li><strong><code>no</code></strong> - 让操作系统来决定应该何时进行同步。</li>
</ul>
</li>
<li><code>no-appendfsync-on-rewrite</code> - AOF 重写时不支持追加命令。</li>
<li><code>auto-aof-rewrite-percentage</code> - AOF 重写百分比。</li>
<li><code>auto-aof-rewrite-min-size</code> - AOF 重写文件的最小大小。</li>
<li><code>dir</code> - RDB 文件和 AOF 文件的存储路径。</li>
</ul>
<h2 id="三、RDB-和-AOF"><a href="#三、RDB-和-AOF" class="headerlink" title="三、RDB 和 AOF"></a>三、RDB 和 AOF</h2><blockquote>
<p>当 Redis 启动时， 如果 RDB 和 AOF 功能都开启了，那么程序会优先使用 AOF 文件来恢复数据集，因为 AOF 文件所保存的数据通常是最完整的。</p>
</blockquote>
<h3 id="如何选择持久化"><a href="#如何选择持久化" class="headerlink" title="如何选择持久化"></a>如何选择持久化</h3><ul>
<li>如果不关心数据丢失，可以不持久化。</li>
<li>如果可以承受数分钟以内的数据丢失，可以只使用 RDB。</li>
<li>如果不能承受数分钟以内的数据丢失，可以同时使用 RDB 和 AOF。</li>
</ul>
<p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份，并且快照恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用快照还可以避免之前提到的 AOF 程序的 bug 。</p>
<h3 id="RDB-切换为-AOF"><a href="#RDB-切换为-AOF" class="headerlink" title="RDB 切换为 AOF"></a>RDB 切换为 AOF</h3><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换为 AOF ：</p>
<ul>
<li>为最新的 dump.rdb 文件创建一个备份。</li>
<li>将备份放到一个安全的地方。</li>
<li>执行以下两条命令:</li>
<li>redis-cli config set appendonly yes</li>
<li>redis-cli config set save</li>
<li>确保写命令会被正确地追加到 AOF 文件的末尾。</li>
<li>执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</li>
</ul>
<p>执行的第二条命令用于关闭快照功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用快照和 AOF 这两种持久化功能。</p>
<blockquote>
<p>:bell: 重要：别忘了在 <code>redis.conf</code> 中打开 AOF 功能！否则的话，服务器重启之后，之前通过 CONFIG SET 设置的配置就会被遗忘，程序会按原来的配置来启动服务器。</p>
</blockquote>
<h3 id="AOF-和-RDB-的相互作用"><a href="#AOF-和-RDB-的相互作用" class="headerlink" title="AOF 和 RDB 的相互作用"></a>AOF 和 RDB 的相互作用</h3><p><code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 命令不可以同时执行。这是为了避免两个 Redis 后台进程同时对磁盘进行大量的 I&#x2F;O 操作。</p>
<p>如果 <code>BGSAVE</code> 正在执行，并且用户显示地调用 <code>BGREWRITEAOF</code> 命令，那么服务器将向用户回复一个 OK 状态，并告知用户，<code>BGREWRITEAOF</code> 已经被预定执行。一旦 <code>BGSAVE</code> 执行完毕， <code>BGREWRITEAOF</code> 就会正式开始。</p>
<h2 id="四、Redis-备份"><a href="#四、Redis-备份" class="headerlink" title="四、Redis 备份"></a>四、Redis 备份</h2><p>应该确保 Redis 数据有完整的备份。</p>
<p>备份 Redis 数据建议采用 RDB。</p>
<h3 id="备份过程"><a href="#备份过程" class="headerlink" title="备份过程"></a>备份过程</h3><ol>
<li>创建一个定期任务（cron job），每小时将一个 RDB 文件备份到一个文件夹，并且每天将一个 RDB 文件备份到另一个文件夹。</li>
<li>确保快照的备份都带有相应的日期和时间信息，每次执行定期任务脚本时，使用 find 命令来删除过期的快照：比如说，你可以保留最近 48 小时内的每小时快照，还可以保留最近一两个月的每日快照。</li>
<li>至少每天一次，将 RDB 备份到你的数据中心之外，或者至少是备份到你运行 Redis 服务器的物理机器之外。</li>
</ol>
<h3 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h3><p>Redis 的容灾备份基本上就是对数据进行备份，并将这些备份传送到多个不同的外部数据中心。</p>
<p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时，仍然让数据处于安全状态。</p>
<h2 id="五、要点总结"><a href="#五、要点总结" class="headerlink" title="五、要点总结"></a>五、要点总结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224214047.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官网</strong><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/379cd8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/379cd8/" class="post-title-link" itemprop="url">Redis 复制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h1><blockquote>
<p>在 Redis 中，<strong>可以通过执行 <code>SLAVEOF</code> 命令或设置 <code>slaveof</code> 选项，让一个服务器去复制（replicate）另一个服务器</strong>，其中，后者叫主服务器（master），前者叫从服务器（slave）。</p>
<p>Redis 2.8 以前的复制不能高效处理断线后重复制的情况，而 Redis 2.8 新添的部分重同步可以解决这个问题。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712182603.png" alt="img"></p>
<h2 id="一、复制简介"><a href="#一、复制简介" class="headerlink" title="一、复制简介"></a>一、复制简介</h2><p>Redis 通过 <code>slaveof host port</code> 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p><strong>一个主服务器可以有多个从服务器</strong>。不仅主服务器可以有从服务器，从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个主从链。</p>
<p><strong>一个从服务器只能有一个主服务器，并且不支持主主复制</strong>。</p>
<p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p>
<p>在使用 Redis 复制功能时的设置中，强烈建议在 master 和在 slave 中启用持久化。当不启用时，例如由于非常慢的磁盘性能而导致的延迟问题，<strong>应该配置实例来避免重置后自动重启</strong>。</p>
<p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p>
<ul>
<li>只读模式由 <code>redis.conf</code> 文件中的 <code>slave-read-only</code> 选项控制， 也可以通过 <a target="_blank" rel="noopener" href="http://redisdoc.com/configure/config_set.html#config-set">CONFIG SET parameter value</a> 命令来开启或关闭这个模式。</li>
<li>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</li>
</ul>
<h2 id="二、旧版复制"><a href="#二、旧版复制" class="headerlink" title="二、旧版复制"></a>二、旧版复制</h2><blockquote>
<p>Redis 2.8 版本以前实现方式：<code>SYNC</code> 命令</p>
</blockquote>
<p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li><strong><code>同步（sync）</code></strong> - 用于将从服务器的数据库状态更新至主服务器当前的数据库状态。</li>
<li><strong><code>命令传播（command propagate）</code></strong> - 当主服务器的数据库状态被修改，导致主从数据库状态不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p><code>SYNC</code> 命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送 <code>SYNC</code> 命令。</li>
<li>收到 <code>SYNC</code> 命令的主服务器执行 <code>BGSAVE</code> 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>主服务器执行 <code>BGSAVE</code> 完毕后，主服务器会将生成的 RDB 文件发送给从服务器。从服务器接收并载入 RDB 文件，更新自己的数据库状态。</li>
<li>主服务器将记录在缓冲区中的所有写命令发送给从服务器，从服务器执行这些写命令，更新自己的数据库状态。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224220353.png" alt="img"></p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步操作完成后，主从数据库的数据库状态将达到一致。每当主服务器执行客户端发送的写命令时，主从数据库状态不再一致。需要将写命令发送给从服务器执行，使得二者的数据库状态重新达到一致。</p>
<h3 id="旧版复制的缺陷"><a href="#旧版复制的缺陷" class="headerlink" title="旧版复制的缺陷"></a>旧版复制的缺陷</h3><p>从服务器对主服务器的复制存在两种情况：</p>
<ul>
<li><strong>初次复制</strong> - 从服务器以前没有复制过将要复制的主服务器。</li>
<li><strong>断线后重复制</strong> - 处于命令传播阶段的主从服务器因为网络原因而中断了复制，当从服务器通过自动重连重新连上了主服务器后，继续复制主服务器。</li>
</ul>
<p>对于初次复制，旧版复制功能可用很好完成任务；但是<strong>对于断线后重复制，由于每次任然需要生成 RDB 并传输，效率很低</strong>。</p>
<blockquote>
<p>:bell: 注意：<strong>SYNC 命令是一个非常耗费资源的操作。</strong></p>
<ul>
<li>主服务器执行 <code>BGSAVE</code> 命令生成 RDB 文件，这个操作会耗费主服务器大量的 CPU、内存和磁盘 I&#x2F;O 资源。</li>
<li>主服务器传输 RDB 文件给从服务器，这个操作会耗费主从服务器大量的网络资源，并对主服务器响应时延产生影响。</li>
<li>从服务器载入 RDB 文件期间，会阻塞其他命令请求。</li>
</ul>
</blockquote>
<h2 id="三、新版复制"><a href="#三、新版复制" class="headerlink" title="三、新版复制"></a>三、新版复制</h2><blockquote>
<p>Redis 2.8 版本以后的新实现方式：使用 <code>PSYNC</code> 命令替代 <code>SYNC</code> 命令。</p>
</blockquote>
<p><code>PSYNC</code> 命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> - 用于断线后重复制。<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器</strong>，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
<h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>部分重同步功能实现由三个部分构成：</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主服务器和从服务器会分别维护一个复制偏移量。</p>
<ul>
<li>如果主从服务器的复制偏移量相同，则说明二者的数据库状态一致；</li>
<li>反之，则说明二者的数据库状态不一致。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-replication-offset.png" alt="img"></p>
<h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p><strong>复制积压缓冲区是主服务器维护的一个固定长度的先进先出（FIFO）队列</strong>，默认大小为 <code>1MB</code>。</p>
<p>复制积压缓冲区会保存一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。</p>
<p>当从服务器断线重连主服务时，从服务器会通过 <code>PSYNC</code> 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作。</p>
<ul>
<li>如果 offset 之后的数据仍然在复制积压缓冲区，则主服务器对从服务器执行部分重同步操作。</li>
<li>反之，则主服务器对从服务器执行完整重同步操作。</li>
</ul>
<blockquote>
<p>🔔 注意：<strong>合理调整复制积压缓冲区的大小</strong></p>
<ul>
<li><p>Redis 复制积压缓冲区默认大小为 <code>1MB</code>。</p>
</li>
<li><p>复制积压缓冲区的最小大小可以根据公式 <code>second * write_size_per_second</code> 估算。</p>
</li>
</ul>
</blockquote>
<h4 id="服务器的运行-ID"><a href="#服务器的运行-ID" class="headerlink" title="服务器的运行 ID"></a>服务器的运行 ID</h4><ul>
<li>每个 Redis 服务器，都有运行 ID，用于唯一识别身份。</li>
<li>运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制字符组成。例如：132e358005e29741f8d7b0a42d666aace286edda</li>
</ul>
<p>从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器，从服务器会将这个运行 ID 保存下来。</p>
<p>当从服务器断线重连一个主服务器时，从服务器会发送之前保存的运行 ID：</p>
<ul>
<li>如果保存的运行 ID 和当前主服务器的运行 ID 一致，则说明从服务器断线之前连接的就是这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>
<li>反之，若运行 ID 不一致，则说明从服务器断线之前连接的不是这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h3 id="PSYNC-命令"><a href="#PSYNC-命令" class="headerlink" title="PSYNC 命令"></a>PSYNC 命令</h3><p>了解了部分重同步的实现，PSYNC 的实现就很容易理解了，它的基本工作原理大致如下：</p>
<p>当从服务接收到 <code>SLAVEOF</code> 命令时，先判断从服务器以前是否执行过复制操作。</p>
<ul>
<li>如果没有复制过任何主服务器，向要复制的主服务器<strong>发送 <code>PSYNC ? -1</code> 命令，主动请求进行完整重同步</strong>。</li>
<li>反之，向要复制的主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令。<ul>
<li><code>runid</code> 是上一次复制的主服务器的运行 ID。</li>
<li><code>offset</code> 是复制偏移量。</li>
</ul>
</li>
</ul>
<p>接收到 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令的主服务会进行分析：</p>
<ul>
<li>假如主从服务器的 <strong>master run id 相同</strong>，并且<strong>指定的偏移量（offset）在内存缓冲区中还有效</strong>，复制就会从上次中断的点开始继续。</li>
<li>如果其中一个条件不满足，就会进行完全重新同步（在 2.8 版本之前就是直接进行完全重新同步）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-psync-workflow.png" alt="img"></p>
<h2 id="四、心跳检测"><a href="#四、心跳检测" class="headerlink" title="四、心跳检测"></a>四、心跳检测</h2><p>在<strong>命令传播</strong>阶段，从服务器默认会以<strong>每秒一次</strong>的频率，向主服务器发送命令：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_offset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>replication_offset</code> 是从服务器当前的复制偏移量。</p>
<p>发送 <code>REPLCONF ACK</code> 命令对于主从服务器有三个作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slaves 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h3 id="检测主从连接状态"><a href="#检测主从连接状态" class="headerlink" title="检测主从连接状态"></a>检测主从连接状态</h3><p><strong>可以通过发送和接收 <code>REPLCONF ACK</code> 命令来检查主从服务器之间的网络连接</strong>是否正常：如果主服务器超过一秒没有收到从服务器发来的 <code>REPLCONF ACK</code> 命令，那么主服务器就知道主从服务器之间的连接出现问题了。</p>
<p>可以通过向主服务器发送 <code>INFO replication</code> 命令，在列出的从服务器列表的 lag 一栏中，可以看到从服务器向主服务器发送 <code>REPLCONF ACK</code> 命令已经过去多少秒。</p>
<h3 id="辅助实现-min-slaves-选项"><a href="#辅助实现-min-slaves-选项" class="headerlink" title="辅助实现 min-slaves 选项"></a>辅助实现 min-slaves 选项</h3><p>Redis 的 <strong><code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 两个选项可以防止主服务器在不安全的情况下执行写命令</strong>。</p>
<p>【示例】min-slaves 配置项</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>以上配置表示：从服务器小于 3 个，或三个从服务器的延迟（lag）都大于等于 10 秒时，主服务器将拒绝执行写命令。</p>
<h3 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h3><p>如果因为网络故障，主服务传播给从服务器的写命令丢失，那么从服务器定时向主服务器发送 <code>REPLCONF ACK</code> 命令时，主服务器将发觉从服务器的复制偏移量少于自己的。然后，主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区中找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<h2 id="五、复制的流程"><a href="#五、复制的流程" class="headerlink" title="五、复制的流程"></a>五、复制的流程</h2><p>通过向从服务器发送如下 SLAVEOF 命令，可以让一个从服务器去复制一个主服务器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF <span class="tag">&lt;<span class="name">master_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">master_port</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤-1-设置主从服务器"><a href="#步骤-1-设置主从服务器" class="headerlink" title="步骤 1. 设置主从服务器"></a>步骤 1. 设置主从服务器</h3><p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slaveof</span> <span class="number">127.0.0.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>当然， 你需要将代码中的 <code>127.0.0.1</code> 和 <code>6379</code> 替换成你的主服务器的 IP 和端口号。</p>
<p>另外一种方法是调用 <a target="_blank" rel="noopener" href="http://redisdoc.com/replication/slaveof.html#slaveof">SLAVEOF host port</a> 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SLAVEOF <span class="number">127.0.0.1</span> <span class="number">10086</span></span><br><span class="line"><span class="attribute">OK</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤-2-主从服务器建立-TCP-连接。"><a href="#步骤-2-主从服务器建立-TCP-连接。" class="headerlink" title="步骤 2. 主从服务器建立 TCP 连接。"></a>步骤 2. 主从服务器建立 TCP 连接。</h3><h3 id="步骤-3-发送-PING-检查通信状态。"><a href="#步骤-3-发送-PING-检查通信状态。" class="headerlink" title="步骤 3. 发送 PING 检查通信状态。"></a>步骤 3. 发送 PING 检查通信状态。</h3><h3 id="步骤-4-身份验证。"><a href="#步骤-4-身份验证。" class="headerlink" title="步骤 4. 身份验证。"></a>步骤 4. 身份验证。</h3><p>如果主服务器没有设置 <code>requirepass</code> ，从服务器没有设置 <code>masterauth</code>，则不进行身份验证；反之，则需要进行身份验证。如果身份验证失败，则放弃执行复制工作。</p>
<p>如果主服务器通过 <code>requirepass</code> 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p>
<p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure>

<p>要永久地设置这个密码， 那么可以将它加入到配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h3 id="步骤-5-发送端口信息。"><a href="#步骤-5-发送端口信息。" class="headerlink" title="步骤 5. 发送端口信息。"></a>步骤 5. 发送端口信息。</h3><p>从服务器执行 <code>REPLCONF listening-port &lt;port-number&gt;</code> ，向主服务器发送从服务器的监听端口号。</p>
<h3 id="步骤-6-同步。"><a href="#步骤-6-同步。" class="headerlink" title="步骤 6. 同步。"></a>步骤 6. 同步。</h3><p>前文已介绍，此处不赘述。</p>
<h3 id="步骤-7-命令传播。"><a href="#步骤-7-命令传播。" class="headerlink" title="步骤 7. 命令传播。"></a>步骤 7. 命令传播。</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务发送命令：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_coffset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>命令的作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slave 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h2 id="六、复制的配置项"><a href="#六、复制的配置项" class="headerlink" title="六、复制的配置项"></a>六、复制的配置项</h2><p>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p>
<p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p>
<p>以下是这个特性的运作原理：</p>
<ul>
<li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li>
<li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li>
<li>用户可以通过配置， 指定网络延迟的最大值 <code>min-slaves-max-lag</code> ， 以及执行写操作所需的至少从服务器数量 <code>min-slaves-to-write</code> 。</li>
</ul>
<p>如果至少有 <code>min-slaves-to-write</code> 个从服务器， 并且这些服务器的延迟值都少于 <code>min-slaves-max-lag</code>秒， 那么主服务器就会执行客户端请求的写操作。</p>
<p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p>
<p>另一方面， 如果条件达不到 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p>
<p>以下是这个特性的两个选项和它们所需的参数：</p>
<ul>
<li><code>min-slaves-to-write &lt;number of slaves&gt;</code></li>
<li><code>min-slaves-max-lag &lt;number of seconds&gt;</code></li>
</ul>
<p>详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官网</strong><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/615afe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/615afe/" class="post-title-link" itemprop="url">Redis 哨兵</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h1><blockquote>
<p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（Hight Availability）解决方案。</p>
<p>Redis 哨兵是 <a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md">Raft 算法</a> 的具体实现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713072747.png" alt="img"></p>
<h2 id="一、哨兵简介"><a href="#一、哨兵简介" class="headerlink" title="一、哨兵简介"></a>一、哨兵简介</h2><p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（Hight Availability）解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131135847.png" alt="img"></p>
<p>Sentinel 的主要功能如下：</p>
<ul>
<li><strong><code>监控（Monitoring）</code></strong> - Sentinel 不断检查主从服务器是否正常在工作。</li>
<li><strong><code>通知（Notification）</code></strong> - Sentinel 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li>
<li><strong><code>自动故障转移（Automatic Failover）</code></strong> - 如果一个主服务器下线，Sentinel 会开始自动故障转移：把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li>
<li><strong><code>配置提供者（Configuration provider）</code></strong> - Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinel 将报告新的地址。</li>
</ul>
<h2 id="二、启动哨兵"><a href="#二、启动哨兵" class="headerlink" title="二、启动哨兵"></a>二、启动哨兵</h2><p>启动一个 Sentinel 可以使用下面任意一条命令，两条命令效果完全相同。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>当一个 Sentinel 启动时，它需要执行以下步骤：</p>
<ol>
<li>初始化服务器。</li>
<li>使用 Sentinel 专用代码。</li>
<li>初始化 Sentinel 状态。</li>
<li>初始化 Sentinel 的主服务器列表。</li>
<li>创建连向被监视的主服务器的网络连接。</li>
</ol>
<p><strong>Sentinel 本质上是一个运行在特殊状模式下的 Redis 服务器</strong>。</p>
<p>Sentinel 模式下 Redis 服务器只支持 <code>PING</code>、<code>SENTINEL</code>、<code>INFO</code>、<code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>、<code>PSUBSCRIBE</code>、<code>PUNSUBSCRIBE</code> 七个命令。</p>
<p>创建连向被监视的主服务器的网络连接，Sentinel 将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。对于每个被 Sentinel 监视的主服务器，Sentinel 会创建两个连向主服务器的异步网络：</p>
<ul>
<li>命令连接：专门用于向主服务器发送命令，并接受命令回复。</li>
<li>订阅连接：专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li>
</ul>
<h2 id="三、监控"><a href="#三、监控" class="headerlink" title="三、监控"></a>三、监控</h2><h3 id="检测服务器状态"><a href="#检测服务器状态" class="headerlink" title="检测服务器状态"></a>检测服务器状态</h3><blockquote>
<p><strong>Sentinel 向 Redis 服务器发送 <code>PING</code> 命令，检查其状态</strong>。</p>
</blockquote>
<p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p>
<ul>
<li><strong>主观下线</strong>：<strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</li>
<li><strong>客观下线</strong>：<strong>客观下线</strong> 只适用于 <strong>主节点</strong>。当 <code>Sentinel</code> 将一个主服务器判断为主管下线后，为了确认这个主服务器是否真的下线，会向同样监视这一主服务器的其他 Sentinel 询问，看它们是否也认为主服务器已经下线。当足够数量的 Sentinel 认为主服务器已下线，就判定其为客观下线，并对其执行故障转移操作。<ul>
<li><code>Sentinel</code> 节点通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。</li>
</ul>
</li>
</ul>
<h3 id="获取服务器信息"><a href="#获取服务器信息" class="headerlink" title="获取服务器信息"></a>获取服务器信息</h3><blockquote>
<p><strong>Sentinel 向主服务器发送 <code>INFO</code> 命令，获取主服务器及它的从服务器信息</strong>。</p>
</blockquote>
<ul>
<li><strong>获取主服务器信息</strong> - Sentinel <strong>默认</strong>会以<strong>每十秒一次</strong>的频率，通过命令连接<strong>向被监视的主服务器发送 <code>INFO</code> 命令，并通过分析 <code>INFO</code> 命令的回复来获取主服务器的当前信息</strong>。<ul>
<li>主服务自身信息：包括 run_id 域记录的服务器运行 ID，以及 role 域记录的服务器角色</li>
<li>主服务的从服务器信息：包括 IP 地址和端口号</li>
</ul>
</li>
<li><strong>获取从服务器信息</strong> - 当 Sentinel 发现主服务器有新的从服务器出现时，Sentinel 除了会为这个新的从服务器创建相应的实例结构之外，Sentinel 还会创建连接到从服务器的命令连接和订阅连接。</li>
</ul>
<h2 id="四、通知"><a href="#四、通知" class="headerlink" title="四、通知"></a>四、通知</h2><p>对于每个与 Sentinel 连接的服务器，Sentinel 既会向服务器的 <code>__sentinel__:hello</code> 频道发送消息，也会订阅服务器的 <code>__sentinel__:hello</code> 频道的消息。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131153842.png" alt="img"></p>
<h3 id="向服务器发送消息"><a href="#向服务器发送消息" class="headerlink" title="向服务器发送消息"></a>向服务器发送消息</h3><p>在默认情况下，Sentinel 会以每两秒一次的频率，通过命令向所有被监视的主服务器和从服务器发送以下格式的命令。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;<span class="tag">&lt;<span class="name">s_ip</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_port</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_runid</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_epoch</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_name</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_ip</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_port</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_epoch</span>&gt;</span>&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令向服务器的 <code>__sentinel__:hello</code> 频道发送一条消息。</p>
<h3 id="接收服务器的消息"><a href="#接收服务器的消息" class="headerlink" title="接收服务器的消息"></a>接收服务器的消息</h3><p>当 Sentinel 与一个主服务器或从服务器建立起订阅连接后，Sentinel 就会通过订阅连接，向服务器发送以下命令：<code>SUBSCRIBE __sentinel__:hello</code>。</p>
<p>Sentinel 对 <code>__sentinel__:hello</code> 频道的订阅会一直持续到 Sentinel 与服务器断开连接为止。</p>
<h2 id="五、选举-Leader"><a href="#五、选举-Leader" class="headerlink" title="五、选举 Leader"></a>五、选举 Leader</h2><blockquote>
<p>Redis Sentinel 系统选举 Leader 的算法是 <a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">Raft</a> 的实现。</p>
<p>Raft 是一种共识性算法，想了解其原理，可以参考 <a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md">深入剖析共识性算法 Raft</a>。</p>
</blockquote>
<p><strong>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头的 Sentinel，并由领头 Sentinel 对下线主服务器执行故障转移操作</strong>。</p>
<p>所有在线 Sentinel 都有资格被选为 Leader。</p>
<p>每个 <code>Sentinel</code> 节点都需要 <strong>定期执行</strong> 以下任务：</p>
<p>（1）每个 <code>Sentinel</code> 以 <strong>每秒钟</strong> 一次的频率，向它所知的 <strong>主服务器</strong>、<strong>从服务器</strong> 以及其他 <code>Sentinel</code> <strong>实例</strong> 发送一个 <code>PING</code> 命令。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61df44c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>（2）如果一个 <strong>实例</strong>（<code>instance</code>）距离 <strong>最后一次</strong> 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，那么这个实例会被 <code>Sentinel</code> 标记为 <strong>主观下线</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dc739de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>（3）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，那么正在 <strong>监视</strong> 这个 <strong>主服务器</strong> 的所有 <code>Sentinel</code> 节点，要以 <strong>每秒一次</strong> 的频率确认 <strong>主服务器</strong> 的确进入了 <strong>主观下线</strong> 状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647a39535?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>（4）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，并且有 <strong>足够数量</strong> 的 <code>Sentinel</code>（至少要达到 <strong>配置文件</strong> 指定的数量）在指定的 <strong>时间范围</strong> 内同意这一判断，那么这个 <strong>主服务器</strong> 被标记为 <strong>客观下线</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647c2583e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>（5）在一般情况下， 每个 <code>Sentinel</code> 会以每 <code>10</code> 秒一次的频率，向它已知的所有 <strong>主服务器</strong> 和 <strong>从服务器</strong> 发送 <code>INFO</code> 命令。当一个 <strong>主服务器</strong> 被 <code>Sentinel</code> 标记为 <strong>客观下线</strong> 时，<code>Sentinel</code> 向 <strong>下线主服务器</strong> 的所有 <strong>从服务器</strong> 发送 <code>INFO</code> 命令的频率，会从 <code>10</code> 秒一次改为 <strong>每秒一次</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6738a30db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>（6）<code>Sentinel</code> 和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong>。将剩余的 <strong>从节点</strong> 指向 <strong>新的主节点</strong> 进行 <strong>数据复制</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce676a95a54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>（7）当没有足够数量的 <code>Sentinel</code> 同意 <strong>主服务器</strong> 下线时， <strong>主服务器</strong> 的 <strong>客观下线状态</strong> 就会被移除。当 <strong>主服务器</strong> 重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回 <strong>有效回复</strong> 时，<strong>主服务器</strong> 的 <strong>主观下线状态</strong> 就会被移除。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6759c1cb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>注意：一个有效的 <code>PING</code> 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果 <strong>服务器</strong> 返回除以上三种回复之外的其他回复，又或者在 <strong>指定时间</strong> 内没有回复 <code>PING</code> 命令， 那么 <code>Sentinel</code> 认为服务器返回的回复 <strong>无效</strong>（<code>non-valid</code>）。</p>
</blockquote>
<h2 id="六、故障转移"><a href="#六、故障转移" class="headerlink" title="六、故障转移"></a>六、故障转移</h2><p>在选举产生出 Sentinel Leader 后，Sentinel Leader 将对已下线的主服务器执行故障转移操作。操作含以下三个步骤：</p>
<p>（一）<strong>选出新的主服务器</strong></p>
<p>故障转移第一步，是 Sentinel Leader 在已下线主服务属下的所有从服务器中，挑选一个状态良好、数据完整的从服务器。然后，向这个从服务器发送 <code>SLAVEOF no one</code> 命令，将其转换为主服务器。</p>
<p>Sentinel Leader 如何选出新的主服务器：</p>
<ul>
<li>删除列表中所有处于下线或断线状态的从服务器。</li>
<li>删除列表中所有最近五秒没有回复过 Sentinel Leader 的 INFO 命令的从服务器。</li>
<li>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds</code> * 10 毫秒的从服务器（<code>down-after-milliseconds</code> 指定了判断主服务器下线所需的时间）。</li>
<li>之后， Sentinel Leader 先选出优先级最高的从服务器；如果优先级一样高，再选择复制偏移量最大的从服务器；如果结果还不唯一，则选出运行 ID 最小的从服务器。</li>
</ul>
<p>（二）<strong>修改从服务器的复制目标</strong></p>
<p>选出新的主服务器后，Sentinel Leader 会向所有从服务器发送 <code>SLAVEOF</code> 命令，让它们去复制新的主服务器。</p>
<p>（三）<strong>将旧的主服务器变为从服务器</strong></p>
<p>Sentinel Leader 将旧的主服务器标记为从服务器。当旧的主服务器重新上线，Sentinel 会向它发送 SLAVEOF 命令，让其成为从服务器。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官网</strong><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="http://www.web-lovers.com/redis-source-sentinel.html">渐进式解析 Redis 源码 - 哨兵 sentinel</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64">深入剖析 Redis 系列(二) - Redis 哨兵模式与高可用集群</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/77dfbe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/77dfbe/" class="post-title-link" itemprop="url">Redis 集群</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">Redis 集群（Redis Cluster）</a> 是 Redis 官方提供的分布式数据库方案</strong>。</p>
<p>既然是分布式，自然具备分布式系统的基本特性：可扩展、高可用、一致性。</p>
<ul>
<li>Redis 集群通过划分 hash 槽来分区，进行数据分享。</li>
<li>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。</li>
<li>根据 CAP 理论，Consistency、Availability、Partition tolerance 三者不可兼得，而 Redis 集群的选择是 AP。Redis 集群节点间采用异步通信方式，不保证强一致性，尽力达到最终一致性。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713100613.png" alt="img"></p>
<h2 id="1-Redis-Cluster-分区"><a href="#1-Redis-Cluster-分区" class="headerlink" title="1. Redis Cluster 分区"></a>1. Redis Cluster 分区</h2><h3 id="1-1-集群节点"><a href="#1-1-集群节点" class="headerlink" title="1.1. 集群节点"></a>1.1. 集群节点</h3><p>Redis 集群由多个节点组成，节点刚启动时，彼此是相互独立的。<strong>节点通过握手（ <code>CLUSTER MEET</code> 命令）来将其他节点添加到自己所处的集群中</strong>。</p>
<p>向一个节点发送 <code>CLUSTER MEET</code> 命令，可以让当前节点与指定 IP、PORT 的节点进行握手，握手成功时，当前节点会将指定节点加入所在集群。</p>
<p><strong>集群节点保存键值对以及过期时间的方式与单机 Redis 服务完全相同</strong>。</p>
<p>Redis 集群节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<h3 id="1-2-分配-Hash-槽"><a href="#1-2-分配-Hash-槽" class="headerlink" title="1.2. 分配 Hash 槽"></a>1.2. 分配 Hash 槽</h3><p>分布式存储需要解决的首要问题是把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p>
<p><strong>Redis 集群通过划分 hash 槽来将数据分区</strong>。Redis 集群通过分区的方式来保存数据库的键值对：<strong>集群的整个数据库被分为 16384 个哈希槽（slot）</strong>，数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。<strong>如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态</strong>。</p>
<p>通过向节点发送 <a target="_blank" rel="noopener" href="https://redis.io/commands/cluster-addslots"><code>CLUSTER ADDSLOTS</code></a> 命令，可以将一个或多个槽指派给节点负责。</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="variable constant_">CLUSTER</span> <span class="variable constant_">ADDSLOTS</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p>
<ul>
<li>节点Ａ存储的哈希槽范围是：0 – 5500</li>
<li>节点Ｂ存储的哈希槽范围是：5501 – 11000</li>
<li>节点Ｃ存储的哈希槽范围是：11001 – 16384</li>
</ul>
<h3 id="1-3-寻址"><a href="#1-3-寻址" class="headerlink" title="1.3. 寻址"></a>1.3. 寻址</h3><p>当客户端向节点发送与数据库键有关的命令时，接受命令的节点会<strong>计算出命令要处理的数据库属于哪个槽</strong>，并<strong>检查这个槽是否指派给了自己</strong>：</p>
<ul>
<li>如果键所在的槽正好指派给了当前节点，那么当前节点直接执行命令。</li>
<li>如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个 MOVED 错误，指引客户端重定向至正确的节点。</li>
</ul>
<h4 id="1-3-1-计算键属于哪个槽"><a href="#1-3-1-计算键属于哪个槽" class="headerlink" title="1.3.1. 计算键属于哪个槽"></a>1.3.1. 计算键属于哪个槽</h4><p>决定一个 key 应该分配到那个槽的算法是：<strong>计算该 key 的 CRC16 结果再模 16834</strong>。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HASH_SLOT</span> = CRC16(KEY) mod <span class="number">16384</span></span><br></pre></td></tr></table></figure>

<p>当节点计算出 key 所属的槽为 i 之后，节点会根据以下条件判断槽是否由自己负责：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clusterState.slots[i] <span class="operator">=</span><span class="operator">=</span> clusterState.myself</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-MOVED-错误"><a href="#1-3-2-MOVED-错误" class="headerlink" title="1.3.2. MOVED 错误"></a>1.3.2. MOVED 错误</h4><p>当节点发现键所在的槽并非自己负责处理的时候，节点就会向客户端返回一个 <code>MOVED</code> 错误，指引客户端转向正在负责槽的节点。</p>
<p><code>MOVED</code> 错误的格式为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVED <span class="tag">&lt;<span class="name">slot</span>&gt;</span> <span class="tag">&lt;<span class="name">ip</span>&gt;</span>:<span class="tag">&lt;<span class="name">port</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>个人理解：MOVED 这种操作有点类似 HTTP 协议中的重定向。</p>
</blockquote>
<h3 id="1-4-重新分区"><a href="#1-4-重新分区" class="headerlink" title="1.4. 重新分区"></a>1.4. 重新分区</h3><p>Redis 集群的<strong>重新分区操作可以将任意数量的已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点</strong>。</p>
<p>重新分区操作<strong>可以在线进</strong>行，在重新分区的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p>
<p>Redis 集群的重新分区操作由 Redis 集群管理软件 <strong>redis-trib</strong> 负责执行的，redis-trib 通过向源节点和目标节点发送命令来进行重新分区操作。</p>
<p>重新分区的实现原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-cluster-trib.png" alt="img"></p>
<h3 id="1-5-ASK-错误"><a href="#1-5-ASK-错误" class="headerlink" title="1.5. ASK 错误"></a>1.5. ASK 错误</h3><p><code>ASK</code> 错误与 <code>MOVED</code> 的区别在于：<strong>ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施</strong>，在客户端收到关于槽 X 的 ASK 错误之后，客户端只会在接下来的一次命令请求中将关于槽 X 的命令请求发送至 ASK 错误所指示的节点，但这种转向不会对客户端今后发送关于槽 X 的命令请求产生任何影响，客户端仍然会将关于槽 X 的命令请求发送至目前负责处理槽 X 的节点，除非 ASK 错误再次出现。</p>
<p>判断 ASK 错误的过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-ask.png" alt="img"></p>
<h2 id="2-Redis-Cluster-故障转移"><a href="#2-Redis-Cluster-故障转移" class="headerlink" title="2. Redis Cluster 故障转移"></a>2. Redis Cluster 故障转移</h2><h3 id="2-1-复制"><a href="#2-1-复制" class="headerlink" title="2.1. 复制"></a>2.1. 复制</h3><p>Redis 复制机制可以参考：<a href="docs/05.KV%E6%95%B0%E6%8D%AE%E5%BA%93/01.Redis/05.Redis%E5%A4%8D%E5%88%B6.md">Redis 复制</a></p>
<h3 id="2-2-故障检测"><a href="#2-2-故障检测" class="headerlink" title="2.2. 故障检测"></a>2.2. 故障检测</h3><p><strong>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线</strong>。</p>
<p>节点的状态信息可以分为：</p>
<ul>
<li><p>在线状态；</p>
</li>
<li><p>下线状态（FAIL）;</p>
</li>
<li><p>疑似下线状态（PFAIL），即在规定的时间内，没有应答 PING 消息；</p>
</li>
</ul>
<h3 id="2-3-故障转移"><a href="#2-3-故障转移" class="headerlink" title="2.3. 故障转移"></a>2.3. 故障转移</h3><ol>
<li>下线主节点的所有从节点中，会有一个从节点被选中。</li>
<li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条 PONG 消息，告知其他节点这个从节点已变成主节点。</li>
</ol>
<h3 id="2-4-选举新的主节点"><a href="#2-4-选举新的主节点" class="headerlink" title="2.4. 选举新的主节点"></a>2.4. 选举新的主节点</h3><p>Redis 集群选举新的主节点流程基于<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e4bbe7e276c">共识算法：Raft</a></p>
<h2 id="3-Redis-Cluster-通信"><a href="#3-Redis-Cluster-通信" class="headerlink" title="3. Redis Cluster 通信"></a>3. Redis Cluster 通信</h2><p>集群中的节点通过发送和接收消息来进行通信。</p>
<p>Redis 集群节点发送的消息主要有以下五种：</p>
<ul>
<li><code>MEET</code> - 请求接收方加入发送方所在的集群。</li>
<li><code>PING</code> - 集群中每个节点每隔一段时间（默认为一秒）从已知节点列表中随机选出五个节点，然后对这五个节点中最久没联系的节点发送 PING 消息，以此检测被选中的节点是否在线。</li>
<li><code>PONG</code> - 当接收方收到发送方发来的 MEET 消息或 PING 消息时，会返回一条 PONG 消息作为应答。</li>
<li><code>FAIL</code> - 当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条关于节点 B 的 FAIL 消息，所有收到这条消息的节点都会立即将节点 B 标记为已下线。</li>
<li><code>PUBLISH</code> - 当节点收到一个 PUBLISH 命令时，节点会执行这个命令，并向集群广播一条 PUBLISH 消息，所有接受到这条消息的节点都会执行相同的 PUBLISH 命令。</li>
</ul>
<h2 id="4-Redis-Cluster-应用"><a href="#4-Redis-Cluster-应用" class="headerlink" title="4. Redis Cluster 应用"></a>4. Redis Cluster 应用</h2><h3 id="4-1-集群功能限制"><a href="#4-1-集群功能限制" class="headerlink" title="4.1. 集群功能限制"></a>4.1. 集群功能限制</h3><p>Redis 集群相对 <strong>单机</strong>，存在一些功能限制，需要 <strong>开发人员</strong> 提前了解，在使用时做好规避。</p>
<ul>
<li><p><code>key</code> <strong>批量操作</strong> 支持有限：类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的 <code>key</code> 执行 <strong>批量操作</strong>。对于 <strong>映射为不同</strong> <code>slot</code> 值的 <code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</p>
</li>
<li><p><code>key</code> <strong>事务操作</strong> 支持有限：只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个 <code>key</code> 分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</p>
</li>
<li><p><code>key</code> 作为 <strong>数据分区</strong> 的最小粒度，不能将一个 <strong>大的键值</strong> 对象如 <code>hash</code>、<code>list</code> 等映射到 <strong>不同的节点</strong>。</p>
</li>
<li><p>不支持 <strong>多数据库空间</strong>：<strong>单机</strong> 下的 Redis 可以支持 <code>16</code> 个数据库（<code>db0 ~ db15</code>），<strong>集群模式</strong> 下只能使用 <strong>一个</strong> 数据库空间，即 <code>db0</code>。</p>
</li>
<li><p><strong>复制结构</strong> 只支持一层：<strong>从节点</strong> 只能复制 <strong>主节点</strong>，不支持 <strong>嵌套树状复制</strong> 结构。</p>
</li>
</ul>
<h3 id="4-2-集群规模限制"><a href="#4-2-集群规模限制" class="headerlink" title="4.2. 集群规模限制"></a>4.2. 集群规模限制</h3><p>Redis Cluster 的优点是易于使用。分区、主从复制、弹性扩容这些功能都可以做到自动化，通过简单的部署就可以获得一个大容量、高可靠、高可用的 Redis 集群，并且对于应用来说，近乎于是透明的。</p>
<p>所以，<strong>Redis Cluster 非常适合构建中小规模 Redis 集群</strong>，这里的中小规模指的是，大概几个到几十个节点这样规模的 Redis 集群。</p>
<p>但是 Redis Cluster 不太适合构建超大规模集群，主要原因是，它采用了去中心化的设计。</p>
<p>Redis 的每个节点上，都保存了所有槽和节点的映射关系表，客户端可以访问任意一个节点，再通过重定向命令，找到数据所在的那个节点。那么，这个映射关系表是如何更新的呢？Redis Cluster 采用了一种去中心化的流言 (Gossip) 协议来传播集群配置的变化。</p>
<p>Gossip 协议的优点是去中心化；缺点是传播速度慢，并且是集群规模越大，传播的越慢。</p>
<h3 id="4-3-集群配置"><a href="#4-3-集群配置" class="headerlink" title="4.3. 集群配置"></a>4.3. 集群配置</h3><p>我们后面会部署一个 Redis 集群作为例子，在那之前，先介绍一下集群在 redis.conf 中的参数。</p>
<ul>
<li><strong>cluster-enabled</strong> <code>&lt;yes/no&gt;</code> - 如果配置”yes”则开启集群功能，此 redis 实例作为集群的一个节点，否则，它是一个普通的单一的 redis 实例。</li>
<li><strong>cluster-config-file</strong> <code>&lt;filename&gt;</code> - 注意：虽然此配置的名字叫“集群配置文件”，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</li>
<li><strong>cluster-node-timeout</strong> <code>&lt;milliseconds&gt;</code> - 这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。</li>
<li><strong>cluster-slave-validity-factor</strong> <code>&lt;factor&gt;</code> - 如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节点。如果设置成正数，则 cluster-node-timeout 乘以 cluster-slave-validity-factor 得到的时间，是从节点与主节点失联后，此从节点数据有效的最长时间，超过这个时间，从节点不会启动故障迁移。假设 cluster-node-timeout&#x3D;5，cluster-slave-validity-factor&#x3D;10，则如果从节点跟主节点失联超过 50 秒，此从节点不能成为主节点。注意，如果此参数配置为非 0，将可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，只有等到原来的主节点重新回归到集群，集群才恢复运作。</li>
<li><strong>cluster-migration-barrier</strong> <code>&lt;count&gt;</code> - 主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。更详细介绍可以看本教程后面关于副本迁移到部分。</li>
<li><strong>cluster-require-full-coverage</strong> <code>&lt;yes/no&gt;</code> - 在部分 key 所在的节点不可用时，如果此参数设置为”yes”(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的 key 提供读操作。</li>
</ul>
<h2 id="5-其他-Redis-集群方案"><a href="#5-其他-Redis-集群方案" class="headerlink" title="5. 其他 Redis 集群方案"></a>5. 其他 Redis 集群方案</h2><p>Redis Cluster 不太适合用于大规模集群，所以，如果要构建超大 Redis 集群，需要选择替代方案。一般有三种方案类型：</p>
<ul>
<li>客户端分区方案</li>
<li>代理分区方案</li>
<li>查询路由方案</li>
</ul>
<h3 id="5-1-客户端分区方案"><a href="#5-1-客户端分区方案" class="headerlink" title="5.1. 客户端分区方案"></a>5.1. 客户端分区方案</h3><p><strong>客户端</strong> 就已经决定数据会被 <strong>存储</strong> 到哪个 Redis 节点或者从哪个 Redis 节点 <strong>读取数据</strong>。其主要思想是采用 <strong>哈希算法</strong> 将 Redis 数据的 <code>key</code> 进行散列，通过 <code>hash</code> 函数，特定的 <code>key</code>会 <strong>映射</strong> 到特定的 Redis 节点上。</p>
<p><strong>客户端分区方案</strong> 的代表为 Redis Sharding，Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的 Redis <strong>多实例集群</strong> 方法。Java 的 Redis 客户端驱动库 <a target="_blank" rel="noopener" href="https://github.com/redis/jedis"><strong>Jedis</strong></a>，支持 Redis Sharding 功能，即 ShardedJedis 以及 <strong>结合缓存池</strong> 的 ShardedJedisPool。</p>
<ul>
<li><p><strong>优点</strong>：不使用 <strong>第三方中间件</strong>，<strong>分区逻辑</strong> 可控，<strong>配置</strong> 简单，节点之间无关联，容易 <strong>线性扩展</strong>，灵活性强。</p>
</li>
<li><p><strong>缺点</strong>：<strong>客户端</strong> 无法 <strong>动态增删</strong> 服务节点，客户端需要自行维护 <strong>分发逻辑</strong>，客户端之间 <strong>无连接共享</strong>，会造成 <strong>连接浪费</strong>。</p>
</li>
</ul>
<h3 id="5-2-代理分区方案"><a href="#5-2-代理分区方案" class="headerlink" title="5.2. 代理分区方案"></a>5.2. 代理分区方案</h3><p><strong>客户端</strong> 发送请求到一个 <strong>代理组件</strong>，<strong>代理</strong> 解析 <strong>客户端</strong> 的数据，并将请求转发至正确的节点，最后将结果回复给客户端。</p>
<ul>
<li><strong>优点</strong>：简化 <strong>客户端</strong> 的分布式逻辑，<strong>客户端</strong> 透明接入，切换成本低，代理的 <strong>转发</strong> 和 <strong>存储</strong> 分离。</li>
<li><strong>缺点</strong>：多了一层 <strong>代理层</strong>，加重了 <strong>架构部署复杂度</strong> 和 <strong>性能损耗</strong>。</li>
</ul>
<p><strong>代理分区</strong> 主流实现的有方案有 <strong><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></strong> 和 <a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a>。</p>
<h4 id="5-2-1-Twemproxy"><a href="#5-2-1-Twemproxy" class="headerlink" title="5.2.1. Twemproxy"></a>5.2.1. Twemproxy</h4><p><strong><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></strong> 也叫 <code>nutcraker</code>，是 Twitter 开源的一个 Redis 和 Memcache 的 <strong>中间代理服务器</strong> 程序。</p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></strong> 作为 <strong>代理</strong>，可接受来自多个程序的访问，按照 <strong>路由规则</strong>，转发给后台的各个 Redis 服务器，再原路返回。**<a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a>** 存在 <strong>单点故障</strong> 问题，需要结合 Lvs 和 Keepalived 做 <strong>高可用方案</strong>。</p>
<ul>
<li><strong>优点</strong>：应用范围广，稳定性较高，中间代理层 <strong>高可用</strong>。</li>
<li><strong>缺点</strong>：无法平滑地 <strong>水平扩容&#x2F;缩容</strong>，无 <strong>可视化管理界面</strong>，运维不友好，出现故障，不能 <strong>自动转移</strong>。</li>
</ul>
<h4 id="5-2-2-Codis"><a href="#5-2-2-Codis" class="headerlink" title="5.2.2. Codis"></a>5.2.2. Codis</h4><p><a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a> 是一个 <strong>分布式</strong> Redis 解决方案，对于上层应用来说，连接 Codis-Proxy 和直接连接 <strong>原生的</strong> Redis-Server 没有的区别。<a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a> 底层会 <strong>处理请求的转发</strong>，不停机的进行 <strong>数据迁移</strong> 等工作。<a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis"><strong>Codis</strong></a> 采用了无状态的 <strong>代理层</strong>，对于 <strong>客户端</strong> 来说，一切都是透明的。</p>
<ul>
<li><p><strong>优点</strong>：实现了上层 Proxy 和底层 Redis 的 <strong>高可用</strong>，<strong>数据分区</strong> 和 <strong>自动平衡</strong>，提供 <strong>命令行接口</strong> 和 RESTful API，提供 <strong>监控</strong> 和 <strong>管理</strong> 界面，可以动态 <strong>添加</strong> 和 <strong>删除</strong> Redis 节点。</p>
</li>
<li><p><strong>缺点</strong>：<strong>部署架构</strong> 和 <strong>配置</strong> 复杂，不支持 <strong>跨机房</strong> 和 <strong>多租户</strong>，不支持 <strong>鉴权管理</strong>。</p>
</li>
</ul>
<h3 id="5-3-查询路由方案"><a href="#5-3-查询路由方案" class="headerlink" title="5.3. 查询路由方案"></a>5.3. 查询路由方案</h3><p><strong>客户端随机地</strong> 请求任意一个 Redis 实例，然后由 Redis 将请求 <strong>转发</strong> 给 <strong>正确</strong> 的 Redis 节点。Redis Cluster 实现了一种 <strong>混合形式</strong> 的 <strong>查询路由</strong>，但并不是 <strong>直接</strong> 将请求从一个 Redis 节点 <strong>转发</strong> 到另一个 Redis 节点，而是在 <strong>客户端</strong> 的帮助下直接 <strong>重定向</strong>（ <code>redirected</code>）到正确的 Redis 节点。</p>
<ul>
<li><p><strong>优点</strong>：<strong>去中心化</strong>，数据按照 <strong>槽</strong> 存储分布在多个 Redis 实例上，可以平滑的进行节点 <strong>扩容&#x2F;缩容</strong>，支持 <strong>高可用</strong> 和 <strong>自动故障转移</strong>，运维成本低。</p>
</li>
<li><p><strong>缺点</strong>：重度依赖 Redis-trib 工具，缺乏 <strong>监控管理</strong>，需要依赖 Smart Client (<strong>维护连接</strong>，<strong>缓存路由表</strong>，<code>MultiOp</code> 和 <code>Pipeline</code> 支持)。Failover 节点的 <strong>检测过慢</strong>，不如有 <strong>中心节点</strong> 的集群及时（如 ZooKeeper）。Gossip 消息采用广播方式，集群规模越大，开销越大。无法根据统计区分 <strong>冷热数据</strong>。</p>
</li>
</ul>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li><strong>官网</strong><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>中间件</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis">Codis</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046801">后端存储实战课</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/redis-cluster-tutorial/">Redis 集群教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c869feb5581d">Redis 集群的原理和搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1fc9c4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1fc9c4/" class="post-title-link" itemprop="url">Redis 实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>952</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-实战"><a href="#Redis-实战" class="headerlink" title="Redis 实战"></a>Redis 实战</h1><h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>Redis 可以应用于很多场景，这里列举几个经典的应用场景。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存是 Redis 最常见的应用场景。</p>
<p>Redis 有多种数据类型，以及丰富的操作命令，并且有着高性能、高可用的特性，非常适合用于分布式缓存。</p>
<blockquote>
<p>缓存应用的基本原理，请参考 <a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a> 第四 ~ 第六节内容。</p>
</blockquote>
<h3 id="BitMap-和-BloomFilter"><a href="#BitMap-和-BloomFilter" class="headerlink" title="BitMap 和 BloomFilter"></a>BitMap 和 BloomFilter</h3><p>Redis 除了 5 种基本数据类型外，还支持 BitMap 和 BloomFilter（即布隆过滤器，可以通过 Redis Module 支持）。</p>
<p>BitMap 和 BloomFilter 都可以用于解决缓存穿透问题。要点在于：过滤一些不可能存在的数据。</p>
<blockquote>
<p>什么是缓存穿透，可以参考：<a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a></p>
</blockquote>
<p>小数据量可以用 BitMap，大数据量可以用布隆过滤器。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>使用 Redis 作为分布式锁，基本要点如下：</p>
<ul>
<li><strong>互斥性</strong> - 使用 <code>setnx</code> 抢占锁。</li>
<li><strong>避免永远不释放锁</strong> - 使用 <code>expire</code> 加一个过期时间，避免一直不释放锁，导致阻塞。</li>
<li><strong>原子性</strong> - setnx 和 expire 必须合并为一个原子指令，避免 setnx 后，机器崩溃，没来得及设置 expire，从而导致锁永不释放。</li>
</ul>
<blockquote>
<p>更多分布式锁的实现方式及细节，请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-lock.md">分布式锁基本原理</a></p>
</blockquote>
<h2 id="二、技巧"><a href="#二、技巧" class="headerlink" title="二、技巧"></a>二、技巧</h2><p>根据 Redis 的特性，在实际应用中，存在一些应用小技巧。</p>
<h3 id="keys-和-scan"><a href="#keys-和-scan" class="headerlink" title="keys 和 scan"></a>keys 和 scan</h3><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。</p>
<p>如果这个 redis 正在给线上的业务提供服务，那使用 <code>keys</code> 指令会有什么问题？</p>
<p>首先，Redis 是单线程的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p>
<p>这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<p>不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 <code>SMEMBERS</code> 命令可以返回集合键当前包含的所有元素， 但是对于 <code>SCAN</code> 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官网</strong><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5db66ed9e51d452a2f15d833">《我们一起进大厂》系列- Redis 基础</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/537098/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/537098/" class="post-title-link" itemprop="url">Redis 运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-运维"><a href="#Redis-运维" class="headerlink" title="Redis 运维"></a>Redis 运维</h1><blockquote>
<p><strong>Redis</strong> 是一个高性能的 key-value 数据库。</p>
<p>SET 操作每秒钟 110000 次；GET 操作每秒钟 81000 次。</p>
</blockquote>
<h2 id="一、Redis-安装"><a href="#一、Redis-安装" class="headerlink" title="一、Redis 安装"></a>一、Redis 安装</h2><h3 id="Window-下安装"><a href="#Window-下安装" class="headerlink" title="Window 下安装"></a>Window 下安装</h3><p><strong>下载地址：</strong><a target="_blank" rel="noopener" href="https://github.com/MSOpenTech/redis/releases">https://github.com/MSOpenTech/redis/releases</a>。</p>
<p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。</p>
<p>打开一个 <strong>cmd</strong> 窗口 使用 cd 命令切换目录到 <strong>C:\redis</strong> 运行 <strong>redis-server.exe redis.windows.conf</strong> 。</p>
<p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。</p>
<p>这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。</p>
<p>切换到 redis 目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。</p>
<h3 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h3><p><strong>下载地址：</strong> <a target="_blank" rel="noopener" href="http://redis.io/download%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E6%96%87%E6%A1%A3%E7%89%88%E6%9C%AC%E3%80%82">http://redis.io/download，下载最新文档版本。</a></p>
<p>下载、解压、编译 Redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.4.tar.gz</span><br><span class="line">tar xzf redis-5.0.4.tar.gz</span><br><span class="line">cd redis-5.0.4</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>为了编译 Redis 源码，你需要 gcc-c++和 tcl。如果你的系统是 CentOS，可以直接执行命令：<code>yum install -y gcc-c++ tcl</code> 来安装。</p>
<p>进入到解压后的 <code>src</code> 目录，通过如下命令启动 Redis:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server</span><br></pre></td></tr></table></figure>

<p>您可以使用内置的客户端与 Redis 进行交互:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">src/redis-cli</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash"><span class="built_in">set</span> foo bar</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">get foo</span></span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-下安装"><a href="#Ubuntu-下安装" class="headerlink" title="Ubuntu 下安装"></a>Ubuntu 下安装</h3><p>在 Ubuntu 系统安装 Redis 可以使用以下命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure>

<h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><ul>
<li>开机启动配置：<code>echo &quot;/usr/local/bin/redis-server /etc/redis.conf&quot; &gt;&gt; /etc/rc.local</code></li>
</ul>
<h3 id="开放防火墙端口"><a href="#开放防火墙端口" class="headerlink" title="开放防火墙端口"></a>开放防火墙端口</h3><ul>
<li>添加规则：<code>iptables -I INPUT -p tcp -m tcp --dport 6379 -j ACCEPT</code></li>
<li>保存规则：<code>service iptables save</code></li>
<li>重启 iptables：<code>service iptables restart</code></li>
</ul>
<h3 id="Redis-安装脚本"><a href="#Redis-安装脚本" class="headerlink" title="Redis 安装脚本"></a>Redis 安装脚本</h3><blockquote>
<p>CentOS7 环境安装脚本：<a target="_blank" rel="noopener" href="https://github.com/dunwu/linux-tutorial/tree/master/codes/linux/soft">软件运维配置脚本集合</a></p>
</blockquote>
<p><strong>安装说明</strong></p>
<ul>
<li>采用编译方式安装 Redis, 并将其注册为 systemd 服务</li>
<li>安装路径为：<code>/usr/local/redis</code></li>
<li>默认下载安装 <code>5.0.4</code> 版本，端口号为：<code>6379</code>，密码为空</li>
</ul>
<p><strong>使用方法</strong></p>
<ul>
<li>默认安装 - 执行以下任意命令即可：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://gitee.com/turnon/linux-tutorial/raw/master/codes/linux/soft/redis-install.sh | bash</span><br><span class="line">wget -qO- https://gitee.com/turnon/linux-tutorial/raw/master/codes/linux/soft/redis-install.sh | bash</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义安装 - 下载脚本到本地，并按照以下格式执行：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh redis-install.sh [version] [port] [password]</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>version</code> - redis 版本号</li>
<li><code>port</code> - redis 服务端口号</li>
<li><code>password</code> - 访问密码</li>
</ul>
<h2 id="二、Redis-单机使用和配置"><a href="#二、Redis-单机使用和配置" class="headerlink" title="二、Redis 单机使用和配置"></a>二、Redis 单机使用和配置</h2><h3 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h3><p><strong>启动 redis 服务</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis/src</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure>

<p><strong>启动 redis 客户端</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis/src</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure>

<p><strong>查看 redis 是否启动</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p>以上命令将打开以下终端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<p>以上说明我们已经成功启动了 redis。</p>
<h3 id="Redis-常见配置"><a href="#Redis-常见配置" class="headerlink" title="Redis 常见配置"></a>Redis 常见配置</h3><blockquote>
<p>Redis 默认的配置文件是根目录下的 <code>redis.conf</code> 文件。</p>
<p>如果需要指定特定文件作为配置文件，需要使用命令： <code>./redis-server -c xxx.conf</code></p>
<p>每次修改配置后，需要重启才能生效。</p>
<p>Redis 官方默认配置：</p>
<ul>
<li>自描述文档 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/antirez/redis/2.8/redis.conf">redis.conf for Redis 2.8</a></li>
<li>自描述文档 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/antirez/redis/2.6/redis.conf">redis.conf for Redis 2.6</a>.</li>
<li>自描述文档 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/antirez/redis/2.4/redis.conf">redis.conf for Redis 2.4</a>.</li>
</ul>
<p>自 Redis2.6 起就可以直接通过命令行传递 Redis 配置参数。这种方法可以用于测试。自 Redis2.6 起就可以直接通过命令行传递 Redis 配置参数。这种方法可以用于测试。</p>
</blockquote>
<h3 id="设为守护进程"><a href="#设为守护进程" class="headerlink" title="设为守护进程"></a>设为守护进程</h3><p>Redis 默认以非守护进程方式启动，而通常我们会将 Redis 设为守护进程启动方式，配置：<code>daemonize yes</code></p>
<h4 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h4><p>Redis 默认绑定 127.0.0.1，这样就只能本机才能访问，若要 Redis 允许远程访问，需要配置：<code>bind 0.0.0.0</code></p>
<h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>Redis 默认访问不需要密码，如果需要设置密码，需要如下配置：</p>
<ul>
<li><code>protected-mode yes</code></li>
<li><code>requirepass &lt;密码&gt;</code></li>
</ul>
<h4 id="配置参数表"><a href="#配置参数表" class="headerlink" title="配置参数表"></a>配置参数表</h4><table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>daemonize no</code></td>
<td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td align="left"><code>pidfile /var/run/redis.pid</code></td>
<td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 &#x2F;var&#x2F;run&#x2F;redis.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td align="left"><code>port 6379</code></td>
<td align="left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td>
</tr>
<tr>
<td align="left"><code>bind 127.0.0.1</code></td>
<td align="left">绑定的主机地址</td>
</tr>
<tr>
<td align="left"><code>timeout 300</code></td>
<td align="left">当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td>
</tr>
<tr>
<td align="left"><code>loglevel notice</code></td>
<td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td align="left"><code>logfile stdout</code></td>
<td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 &#x2F;dev&#x2F;null</td>
</tr>
<tr>
<td align="left"><code>databases 16</code></td>
<td align="left">设置数据库的数量，默认数据库为 0，可以使用 SELECT 命令在连接上指定数据库 id</td>
</tr>
<tr>
<td align="left"><code>save &lt;seconds&gt; &lt;changes&gt;</code> Redis 默认配置文件中提供了三个条件：<strong>save 900 1</strong>、<strong>save 300 10</strong>、<strong>save 60 10000</strong> 分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td>
<td align="left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td>
</tr>
<tr>
<td align="left"><code>rdbcompression yes</code></td>
<td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td align="left"><code>dbfilename dump.rdb</code></td>
<td align="left">指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td align="left"><code>dir ./</code></td>
<td align="left">指定本地数据库存放目录</td>
</tr>
<tr>
<td align="left"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td>
<td align="left">设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td align="left"><code>masterauth &lt;master-password&gt;</code></td>
<td align="left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td align="left"><code>requirepass foobared</code></td>
<td align="left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 <code>AUTH &lt;password&gt;</code> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td align="left"><code>maxclients 128</code></td>
<td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td align="left"><code>maxmemory &lt;bytes&gt;</code></td>
<td align="left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td align="left"><code>appendonly no</code></td>
<td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td align="left"><code>appendfilename appendonly.aof</code></td>
<td align="left">指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td align="left"><code>appendfsync everysec</code></td>
<td align="left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td>
</tr>
<tr>
<td align="left"><code>vm-enabled no</code></td>
<td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td align="left"><code>vm-swap-file /tmp/redis.swap</code></td>
<td align="left">虚拟内存文件路径，默认值为 &#x2F;tmp&#x2F;redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td align="left"><code>vm-max-memory 0</code></td>
<td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td align="left"><code>vm-page-size 32</code></td>
<td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td align="left"><code>vm-pages 134217728</code></td>
<td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td align="left"><code>vm-max-threads 4</code></td>
<td align="left">设置访问 swap 文件的线程数,最好不要超过机器的核数,如果设置为 0,那么所有对 swap 文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4</td>
</tr>
<tr>
<td align="left"><code>glueoutputbuf yes</code></td>
<td align="left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td align="left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td>
<td align="left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td align="left"><code>activerehashing yes</code></td>
<td align="left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td align="left"><code>include /path/to/local.conf</code></td>
<td align="left">指定包含其它的配置文件，可以在同一主机上多个 Redis 实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
</tbody></table>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><blockquote>
<p>参考官方文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/benchmarks">How fast is Redis?</a></p>
</blockquote>
<p>Redis 自带了一个性能测试工具：<code>redis-benchmark</code></p>
<p><strong>（1）基本测试</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -q -n 100000</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-q</code> 表示静默（quiet）执行</li>
<li><code>-n 100000</code> 请求 10 万次</li>
</ul>
<p><strong>（2）测试指定读写指令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-benchmark -t <span class="built_in">set</span>,lpush -n 100000 -q</span></span><br><span class="line">SET: 74239.05 requests per second</span><br><span class="line">LPUSH: 79239.30 requests per second</span><br></pre></td></tr></table></figure>

<p><strong>（3）测试 pipeline 模式下指定读写指令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -n 1000000 -t set,get -P 16 -q</span><br><span class="line">SET: 403063.28 requests per second</span><br><span class="line">GET: 508388.41 requests per second</span><br></pre></td></tr></table></figure>

<h2 id="三、Redis-集群使用和配置"><a href="#三、Redis-集群使用和配置" class="headerlink" title="三、Redis 集群使用和配置"></a>三、Redis 集群使用和配置</h2><p>Redis 3.0 后支持集群模式。</p>
<h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><p><code>Redis</code> 集群一般由 <strong>多个节点</strong> 组成，节点数量至少为 <code>6</code> 个，才能保证组成 <strong>完整高可用</strong> 的集群。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0d1c392?w=1467&h=803&f=png&s=43428" alt="img"></p>
<p>理想情况当然是所有节点各自在不同的机器上，首先于资源，本人在部署 Redis 集群时，只得到 3 台服务器。所以，我计划每台服务器部署 2 个 Redis 节点。</p>
<p>【示例】最简高可用 Redis 集群规划</p>
<p>机器配置：16G 内存 + 8 核 CPU + 1T 磁盘</p>
<p>Redis 进程分配 10 G 内存。一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>集群拓扑：三主三从；三哨兵，每个哨兵监听所有主节点。</p>
<p>估算性能：</p>
<ul>
<li>容量：三主，占用 30 G 内存，所以最大存储容量为 30 G。假设每条数据记录平均 大小为 10 K，则最大能存储 300 万条数据。</li>
<li>吞吐量：单机一般 TPS&#x2F;QPS 为 五万到八万左右。假设为五万，那么三主三从架构理论上能达到 TPS 15 万，QPS 30 万。</li>
</ul>
<h3 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h3><blockquote>
<p>Redis 集群节点的安装与单节点服务相同，差异仅在于部署方式。</p>
<p>注意：为了演示方便，本示例将所有 Redis 集群节点都部署在一台机器上，实际生产环境中，基本都会将节点部署在不同机器上。要求更高的，可能还要考虑多机房部署。</p>
</blockquote>
<p>（1）创建节点目录</p>
<p>我个人偏好将软件放在 <code>/opt</code> 目录下，在我的机器中，Redis 都安装在 <code>/usr/local/redis</code> 目录下。所以，下面的命令和配置都假设 Redis 安装目录为 <code>/usr/local/redis</code> 。</p>
<p>确保机器上已经安装了 Redis 后，执行以下命令，创建 Redis 集群节点实例目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/redis/conf/7001</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7002</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7003</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7004</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7005</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7006</span><br></pre></td></tr></table></figure>

<p>（2）配置集群节点</p>
<p>每个实例目录下，新建 <code>redis.conf</code> 配置文件。</p>
<p>实例配置模板以 7001 节点为例（其他节点，完全替换配置中的端口号 7001 即可），如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口号</span></span><br><span class="line">port 7001</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绑定的主机端口（0.0.0.0 表示允许远程访问）</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以守护进程方式启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群的配置，配置文件首次启动自动生成</span></span><br><span class="line">cluster-config-file /usr/local/redis/conf/7001/7001.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求超时时间，设置 10 秒</span></span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 AOF 持久化</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据存放目录</span></span><br><span class="line">dir /usr/local/redis/conf/7001</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进程文件</span></span><br><span class="line">pidfile /usr/local/redis/conf/7001/7001.pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件</span></span><br><span class="line">logfile /usr/local/redis/conf/7001/7001.log</span><br></pre></td></tr></table></figure>

<p>（3）批量启动 Redis 节点</p>
<p>Redis 的 utils&#x2F;create-cluster 目录下自带了一个名为 create-cluster 的脚本工具，可以利用它来新建、启动、停止、重启 Redis 节点。</p>
<p>脚本中有几个关键参数：</p>
<ul>
<li><code>PORT</code>&#x3D;30000 - 初始端口号</li>
<li><code>TIMEOUT</code>&#x3D;2000 - 超时时间</li>
<li><code>NODES</code>&#x3D;6 - 节点数</li>
<li><code>REPLICAS</code>&#x3D;1 - 备份数</li>
</ul>
<p>脚本中的每个命令项会根据初始端口号，以及设置的节点数，遍历的去执行操作。</p>
<p>由于前面的规划中，节点端口是从 7001 ~ 7006，所以需要将 PORT 变量设为 7000。</p>
<p>脚本中启动每个 Redis 节点是通过指定命令行参数来配置属性。所以，我们需要改一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PORT=7000</span><br><span class="line">TIMEOUT=2000</span><br><span class="line">NODES=6</span><br><span class="line">ENDPORT=$((PORT+NODES))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; == &quot;start&quot; ]</span><br><span class="line">then</span><br><span class="line">    while [ $((PORT &lt; ENDPORT)) != &quot;0&quot; ]; do</span><br><span class="line">        PORT=$((PORT+1))</span><br><span class="line">        echo &quot;Starting $PORT&quot;</span><br><span class="line">        /usr/local/redis/src/redis-server /usr/local/redis/conf/$&#123;PORT&#125;/redis.conf</span><br><span class="line">    done</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>好了，在每台服务器上，都执行 <code>./create-cluster start</code> 来启动节点。</p>
<p>然后，通过 ps 命令来确认 Redis 进程是否已经工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root @ dbClusterDev01 <span class="keyword">in</span> /usr/local/redis/conf [11:07:55]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep redis</span></span><br><span class="line">root      4604     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7001 [cluster]</span><br><span class="line">root      4609     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7002 [cluster]</span><br><span class="line">root      4614     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7003 [cluster]</span><br><span class="line">root      4619     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7004 [cluster]</span><br><span class="line">root      4624     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7005 [cluster]</span><br><span class="line">root      4629     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7006 [cluster]</span><br></pre></td></tr></table></figure>

<p>（4）启动集群</p>
<p>通过 <code>redis-cli --cluster create</code> 命令可以自动配置集群，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.2:7003 127.0.0.2:7004 127.0.0.3:7005 127.0.0.3:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p>redis-cluster 会根据设置的节点数和副本数自动分片（分配 Hash 虚拟槽 slot），如果满意，输入 yes ，直接开始分片。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.2:7004 to 127.0.0.1:7001</span><br><span class="line">Adding replica 127.0.0.3:7006 to 127.0.0.2:7003</span><br><span class="line">Adding replica 127.0.0.1:7002 to 127.0.0.3:7005</span><br><span class="line">M: b721235997deb6b9a7a2be690b5b9663db8057c6 127.0.0.1:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">S: bda9b7036df0bbefe601bda4ce45d3787a2e9bd9 127.0.0.1:7002</span><br><span class="line">   replicates 3623fff69b5243ed18c02a2fbb6f53069b0f1505</span><br><span class="line">M: 91523c0391a044da6cc9f53bb965aabe89502187 127.0.0.2:7003</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: 9d899cbe49dead7b8c4f769920cdb75714a441ae 127.0.0.2:7004</span><br><span class="line">   replicates b721235997deb6b9a7a2be690b5b9663db8057c6</span><br><span class="line">M: 3623fff69b5243ed18c02a2fbb6f53069b0f1505 127.0.0.3:7005</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: a2869dc153ea4977ca790b76483574a5d56cb40e 127.0.0.3:7006</span><br><span class="line">   replicates 91523c0391a044da6cc9f53bb965aabe89502187</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">....</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: b721235997deb6b9a7a2be690b5b9663db8057c6 127.0.0.1:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: a2869dc153ea4977ca790b76483574a5d56cb40e 127.0.0.1:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 91523c0391a044da6cc9f53bb965aabe89502187</span><br><span class="line">M: 91523c0391a044da6cc9f53bb965aabe89502187 127.0.0.1:7003</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 3623fff69b5243ed18c02a2fbb6f53069b0f1505 127.0.0.1:7005</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 9d899cbe49dead7b8c4f769920cdb75714a441ae 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b721235997deb6b9a7a2be690b5b9663db8057c6</span><br><span class="line">S: bda9b7036df0bbefe601bda4ce45d3787a2e9bd9 127.0.0.1:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3623fff69b5243ed18c02a2fbb6f53069b0f1505</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>（5）日常维护操作</p>
<ul>
<li>关闭集群 - <code>./create-cluster stop</code></li>
<li>检查集群是否健康（指定任意节点即可）：<code>./redis-cli --cluster check &lt;ip:port&gt;</code></li>
<li>尝试修复集群节点：<code>./redis-cli --cluster fix &lt;ip:port&gt;</code></li>
</ul>
<h3 id="部署哨兵"><a href="#部署哨兵" class="headerlink" title="部署哨兵"></a>部署哨兵</h3><p>redis-cluster 实现了 Redis 的分片、复制。</p>
<p>但 redis-cluster 没有解决故障转移问题，一旦任意分片的 Master 节点宕机、网络不通，就会导致 redis-cluster 的集群不能工作。为了解决高可用的问题，Redis 提供了 Redis 哨兵来监控 Redis 节点状态，并且会在 Master 宕机时，发起选举，将这个 Master 的一个 Slave 节点选举为 Master。</p>
<p>（1）创建节点目录</p>
<p>我个人偏好将软件放在 <code>/opt</code> 目录下，在我的机器中，Redis 都安装在 <code>/usr/local/redis</code> 目录下。所以，下面的命令和配置都假设 Redis 安装目录为 <code>/usr/local/redis</code> 。</p>
<p>确保机器上已经安装了 Redis 后，执行以下命令，创建 Redis 集群节点实例目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/redis/conf/27001</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/27002</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/27003</span><br></pre></td></tr></table></figure>

<p>（2）配置集群节点</p>
<p>每个实例目录下，新建 <code>redis.conf</code> 配置文件。</p>
<p>实例配置模板以 7001 节点为例（其他节点，完全替换配置中的端口号 7001 即可），如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 27001</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor redis-master 172.22.6.3 7001 2</span><br><span class="line">sentinel down-after-milliseconds redis-master 5000</span><br><span class="line">sentinel failover-timeout redis-master 900000</span><br><span class="line">sentinel parallel-syncs redis-master 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sentinel auth-pass redis-master 123456</span></span><br><span class="line">logfile /usr/local/redis/conf/27001/27001.log</span><br></pre></td></tr></table></figure>

<p>（3）批量启动哨兵节点</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27001/</span>sentinel.conf</span><br><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27002/</span>sentinel.conf</span><br><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27003/</span>sentinel.conf</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>（1）查看信息</p>
<p>进入任意节点</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-<span class="keyword">cli</span> -h <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span> -p <span class="number">7001</span></span><br></pre></td></tr></table></figure>

<p>cluster info 查看集群节点状态</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line"><span class="attribute">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b</span> <span class="number">172.22.6.3:7006</span>@<span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594528179000</span> <span class="number">6</span> connected</span><br><span class="line"><span class="attribute">f348e67648460c7a800120d69b4977bf2e4524cb</span> <span class="number">172.22.6.3:7001</span>@<span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594528179000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="attribute">52601e2d4af0e64b83f4cc6d20e8316d0ac38b99</span> <span class="number">172.22.6.3:7004</span>@<span class="number">17004</span> slave <span class="number">4802</span>fafe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="attribute">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31</span> <span class="number">172.22.6.3:7005</span>@<span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594528179852</span> <span class="number">5</span> connected</span><br><span class="line"><span class="attribute">e7aa182e756b76ec85b471797db9b66e4b2da725</span> <span class="number">172.22.6.3:7002</span>@<span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line"><span class="attribute">4802fafe897160c46392c6e569d6f5e466cca696</span> <span class="number">172.22.6.3:7003</span>@<span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br></pre></td></tr></table></figure>

<p>cluster info 查看集群信息</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster info</span><br><span class="line"><span class="attribute">cluster_state</span>:ok</span><br><span class="line"><span class="attribute">cluster_slots_assigned</span>:<span class="number">16384</span></span><br><span class="line"><span class="attribute">cluster_slots_ok</span>:<span class="number">16384</span></span><br><span class="line"><span class="attribute">cluster_slots_pfail</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">cluster_slots_fail</span>:<span class="number">0</span></span><br><span class="line"><span class="attribute">cluster_known_nodes</span>:<span class="number">6</span></span><br><span class="line"><span class="attribute">cluster_size</span>:<span class="number">3</span></span><br><span class="line"><span class="attribute">cluster_current_epoch</span>:<span class="number">6</span></span><br><span class="line"><span class="attribute">cluster_my_epoch</span>:<span class="number">1</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_ping_sent</span>:<span class="number">3406</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_pong_sent</span>:<span class="number">3569</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_publish_sent</span>:<span class="number">5035</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_sent</span>:<span class="number">12010</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_ping_received</span>:<span class="number">3564</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_pong_received</span>:<span class="number">3406</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_meet_received</span>:<span class="number">5</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_publish_received</span>:<span class="number">5033</span></span><br><span class="line"><span class="attribute">cluster_stats_messages_received</span>:<span class="number">12008</span></span><br></pre></td></tr></table></figure>

<p>（2）添加节点到集群</p>
<p>将已启动的节点实例添加到集群中</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>127.0.0.1:7007 127.0.0.1:7008</span><br></pre></td></tr></table></figure>

<p><strong>添加主节点</strong></p>
<p>添加一组主节点</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7007 172.22.6.3:7001</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7008 172.22.6.3:7001</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7009 172.22.6.3:7001</span><br></pre></td></tr></table></figure>

<p>查看节点状态</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line"><span class="attribute">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b</span> <span class="number">172.22.6.3:7006</span>@<span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594529342575</span> <span class="number">6</span> connected</span><br><span class="line"><span class="attribute">f348e67648460c7a800120d69b4977bf2e4524cb</span> <span class="number">172.22.6.3:7001</span>@<span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="attribute">55cacf121662833a4a19dbeb4a5df712cfedf77f</span> <span class="number">172.22.6.3:7009</span>@<span class="number">17009</span> master - <span class="number">0</span> <span class="number">1594529342000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31</span> <span class="number">172.22.6.3:7005</span>@<span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594529341573</span> <span class="number">5</span> connected</span><br><span class="line"><span class="attribute">4802fafe897160c46392c6e569d6f5e466cca696</span> <span class="number">172.22.6.3:7003</span>@<span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594529343577</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line"><span class="attribute">e7aa182e756b76ec85b471797db9b66e4b2da725</span> <span class="number">172.22.6.3:7002</span>@<span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594529342000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line"><span class="attribute">e5ba78fe629115977a74fbbe1478caf8868d6d55</span> <span class="number">172.22.6.3:7007</span>@<span class="number">17007</span> master - <span class="number">0</span> <span class="number">1594529341000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">52601e2d4af0e64b83f4cc6d20e8316d0ac38b99</span> <span class="number">172.22.6.3:7004</span>@<span class="number">17004</span> slave <span class="number">4802</span>fafe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="attribute">79d4fffc2cec210556c3b4c44e63ab506e87eda3</span> <span class="number">172.22.6.3:7008</span>@<span class="number">17008</span> master - <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">7</span> connected</span><br></pre></td></tr></table></figure>

<p>可以发现，新加入的三个主节点，还没有分配哈希槽，所以，暂时还无法访问。</p>
<p><strong>添加从节点</strong></p>
<p>–slave：设置该参数，则新节点以 slave 的角色加入集群<br>–master-id：这个参数需要设置了–slave 才能生效，–master-id 用来指定新节点的 master 节点。如果不设置该参数，则会随机为节点选择 master 节点。</p>
<p>语法</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span> 新节点IP地址：端口    存在节点IP：端口 --cluster-slave （从节点） --cluster-master-id （master节点的ID）</span><br><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>  10.42.141.119:6379  10.42.166.105:6379  --cluster-slave   --cluster-master-id  dfa238fff8a7a49230cff7eb74f573f5645c8ec5</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7010 172.22.6.3:7007 --cluster-slave</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7011 172.22.6.3:7008 --cluster-slave</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7012 172.22.6.3:7009 --cluster-slave</span><br></pre></td></tr></table></figure>

<p>查看状态</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">172</span>.<span class="number">22</span>.<span class="number">6</span>.<span class="number">3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line"><span class="attribute">ef5c1b9ce4cc795dc12b2c1e8736a572647b4c3e</span> <span class="number">172.22.6.3:7011</span>@<span class="number">17011</span> slave <span class="number">79</span>d4fffc2cec210556c3b4c44e63ab506e87eda3 <span class="number">0</span> <span class="number">1594529492043</span> <span class="number">7</span> connected</span><br><span class="line"><span class="attribute">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b</span> <span class="number">172.22.6.3:7006</span>@<span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594529491943</span> <span class="number">6</span> connected</span><br><span class="line"><span class="attribute">f348e67648460c7a800120d69b4977bf2e4524cb</span> <span class="number">172.22.6.3:7001</span>@<span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="attribute">5140d1129ed850df59c51cf818c4eb74545d9959</span> <span class="number">172.22.6.3:7010</span>@<span class="number">17010</span> slave e5ba78fe629115977a74fbbe1478caf8868d6d55 <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">55cacf121662833a4a19dbeb4a5df712cfedf77f</span> <span class="number">172.22.6.3:7009</span>@<span class="number">17009</span> master - <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">8</span> connected</span><br><span class="line"><span class="attribute">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31</span> <span class="number">172.22.6.3:7005</span>@<span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594529490000</span> <span class="number">5</span> connected</span><br><span class="line"><span class="attribute">4802fafe897160c46392c6e569d6f5e466cca696</span> <span class="number">172.22.6.3:7003</span>@<span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594529489939</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line"><span class="attribute">e7aa182e756b76ec85b471797db9b66e4b2da725</span> <span class="number">172.22.6.3:7002</span>@<span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594529491000</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line"><span class="attribute">e5ba78fe629115977a74fbbe1478caf8868d6d55</span> <span class="number">172.22.6.3:7007</span>@<span class="number">17007</span> master - <span class="number">0</span> <span class="number">1594529490942</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">52601e2d4af0e64b83f4cc6d20e8316d0ac38b99</span> <span class="number">172.22.6.3:7004</span>@<span class="number">17004</span> slave <span class="number">4802</span>fafe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594529491000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="attribute">02e9f57b5b45c350dc57acf1c8efa8db136db7b7</span> <span class="number">172.22.6.3:7012</span>@<span class="number">17012</span> master - <span class="number">0</span> <span class="number">1594529489000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="attribute">79d4fffc2cec210556c3b4c44e63ab506e87eda3</span> <span class="number">172.22.6.3:7008</span>@<span class="number">17008</span> master - <span class="number">0</span> <span class="number">1594529489000</span> <span class="number">7</span> connected</span><br></pre></td></tr></table></figure>

<p>分配哈希槽</p>
<p>执行 <code>./redis-cli --cluster rebalance 172.22.6.3:7001 --cluster-threshold 1 --cluster-use-empty-masters</code></p>
<p>参数说明：</p>
<p>rebalance：表明让 Redis 自动根据节点数进行均衡哈希槽分配。</p>
<p>–cluster-use-empty-masters：表明</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712125827.png" alt="img"></p>
<p>执行结束后，查看状态：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712130234.png" alt="img"></p>
<h2 id="四、Redis-命令"><a href="#四、Redis-命令" class="headerlink" title="四、Redis 命令"></a>四、Redis 命令</h2><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><blockquote>
<p>命令详细用法，请参考 <a target="_blank" rel="noopener" href="https://redis.io/commands"><strong>Redis 命令官方文档</strong></a></p>
<p>搬迁两张 cheat sheet 图，原址：<a target="_blank" rel="noopener" href="https://www.cheatography.com/tasjaevan/cheat-sheets/redis/">https://www.cheatography.com/tasjaevan/cheat-sheets/redis/</a></p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0b8ea57?w=2230&h=2914&f=png&s=246433" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0e9ba3c?w=2229&h=2890&f=png&s=192997" alt="img"></p>
<h3 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h3><ul>
<li><strong>集群</strong><ul>
<li><code>cluster info</code> - 打印集群的信息</li>
<li><code>cluster nodes</code> - 列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</li>
</ul>
</li>
<li><strong>节点</strong><ul>
<li><code>cluster meet &lt;ip&gt; &lt;port&gt;</code> - 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。</li>
<li><code>cluster forget &lt;node_id&gt;</code> - 从集群中移除 node_id 指定的节点。</li>
<li><code>cluster replicate &lt;node_id&gt;</code> - 将当前节点设置为 node_id 指定的节点的从节点。</li>
<li><code>cluster saveconfig</code> - 将节点的配置文件保存到硬盘里面。</li>
</ul>
</li>
<li><strong>槽(slot)</strong><ul>
<li><code>cluster addslots &lt;slot&gt; [slot ...]</code> - 将一个或多个槽（ slot）指派（ assign）给当前节点。</li>
<li><code>cluster delslots &lt;slot&gt; [slot ...]</code> - 移除一个或多个槽对当前节点的指派。</li>
<li><code>cluster flushslots</code> - 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</li>
<li><code>cluster setslot &lt;slot&gt; node &lt;node_id&gt;</code> - 将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。</li>
<li><code>cluster setslot &lt;slot&gt; migrating &lt;node_id&gt;</code> - 将本节点的槽 slot 迁移到 node_id 指定的节点中。</li>
<li><code>cluster setslot &lt;slot&gt; importing &lt;node_id&gt;</code> - 从 node_id 指定的节点中导入槽 slot 到本节点。</li>
<li><code>cluster setslot &lt;slot&gt; stable</code> - 取消对槽 slot 的导入（ import）或者迁移（ migrate）。</li>
</ul>
</li>
<li><strong>键</strong><ul>
<li><code>cluster keyslot &lt;key&gt;</code> - 计算键 key 应该被放置在哪个槽上。</li>
<li><code>cluster countkeysinslot &lt;slot&gt;</code> - 返回槽 slot 目前包含的键值对数量。</li>
<li><code>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</code> - 返回 count 个 slot 槽中的键。</li>
</ul>
</li>
</ul>
<h4 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h4><p>添加节点：.&#x2F;redis-cli –cluster add-node 192.168.1.136:7007 192.168.1.136:7001 –cluster-slave</p>
<p>redis-cli –cluster reshard 172.22.6.3 7001</p>
<h2 id="五、客户端"><a href="#五、客户端" class="headerlink" title="五、客户端"></a>五、客户端</h2><p>推荐使用 <a target="_blank" rel="noopener" href="https://github.com/uglide/RedisDesktopManager"><strong>RedisDesktopManager</strong></a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官网</strong><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">Redis github</a></li>
<li><a target="_blank" rel="noopener" href="http://redis.cn/">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/17aad9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/17aad9/" class="post-title-link" itemprop="url">JVM 类加载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-17 15:06:46" itemprop="dateCreated datePublished" datetime="2020-06-17T15:06:46+08:00">2020-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-26 07:52:26" itemprop="dateModified" datetime="2022-12-26T07:52:26+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaSE/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-类加载"><a href="#JVM-类加载" class="headerlink" title="JVM 类加载"></a>JVM 类加载</h1><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200617145849.png" alt="img"></p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><blockquote>
<p>类是在运行期间动态加载的。</p>
</blockquote>
<p>类的加载指的是将类的 <code>.class</code> 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的<code>Class</code>对象，<code>Class</code>对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError 错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200617115110.png" alt="img"></p>
<p>Java 类的完整生命周期包括以下几个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>链接（Linking）</strong><ul>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
</ul>
</li>
<li><strong>初始化（Initialization）</strong></li>
<li><strong>使用（Using）</strong></li>
<li><strong>卸载（Unloading）</strong></li>
</ul>
<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而<strong>解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定</strong>。</p>
<p>类加载过程是指加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h3 id="（一）加载"><a href="#（一）加载" class="headerlink" title="（一）加载"></a>（一）加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p><strong>加载，是指查找字节流，并且据此创建类的过程</strong>。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表这个类的 <code>Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用是 Applet。</li>
<li>运行时计算生成，这种场景使用得最多得就是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 中，就是用了 <code>ProxyGenerator.generateProxyClass</code> 的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。<br>…</li>
</ul>
<blockquote>
<p>更详细内容会在 <a href="#3-classloader">3. ClassLoader</a> 介绍。</p>
</blockquote>
<h3 id="（二）验证"><a href="#（二）验证" class="headerlink" title="（二）验证"></a>（二）验证</h3><p>验证是链接阶段的第一步。<strong>验证的目标是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求</strong>，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段大致会完成 4 个阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证</strong> - 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</li>
<li><strong>元数据验证</strong> - 对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li>
<li><strong>字节码验证</strong> - 通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。</li>
<li><strong>符号引用验证</strong> - 发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="（三）准备"><a href="#（三）准备" class="headerlink" title="（三）准备"></a>（三）准备</h3><p><strong>类变量是被 static 修饰的变量，准备阶段为 static 变量在方法区分配内存并初始化为默认值，使用的是方法区的内存。</strong></p>
<p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>准备阶段有以下几点需要注意：</p>
<ul>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值（如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等），而不是被在 Java 代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为：<code>public static int value = 3</code>；</p>
<p>那么变量 value 在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>public static</code>指令是在程序编译后，存放于类构造器<code>（）</code>方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即 null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</blockquote>
<ul>
<li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。</li>
</ul>
<p>假设上面的类变量 value 被定义为： <code>public static final int value = 3</code>；</p>
<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中</p>
<h3 id="（四）解析"><a href="#（四）解析" class="headerlink" title="（四）解析"></a>（四）解析</h3><p>在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。</p>
<p>举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。</p>
<p><strong>解析阶段目标是将常量池的符号引用替换为直接引用的过程</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p>
<ul>
<li><strong>符号引用（Symbolic References）</strong> - 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li><strong>直接引用（Direct Reference）</strong> - 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
</ul>
<h3 id="（五）初始化"><a href="#（五）初始化" class="headerlink" title="（五）初始化"></a>（五）初始化</h3><p>在 Java 代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。</p>
<p>如果直接赋值的静态字段被 <code>final</code> 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 <code>&lt; clinit &gt;</code>。</p>
<p>初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化，<strong>为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化</strong>。</p>
<h4 id="类初始化方式"><a href="#类初始化方式" class="headerlink" title="类初始化方式"></a>类初始化方式</h4><ul>
<li>声明类变量时指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<blockquote>
<p>在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
</blockquote>
<h4 id="类初始化步骤"><a href="#类初始化步骤" class="headerlink" title="类初始化步骤"></a>类初始化步骤</h4><ol>
<li>如果类还没有被加载和链接，开始加载该类。</li>
<li>如果该类的直接父类还没有被初始化，先初始化其父类。</li>
<li>如果该类有初始化语句，则依次执行这些初始化语句。</li>
</ol>
<h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h4><p>只有主动引用类的时候才会导致类的初始化。</p>
<p><strong>（1）主动引用</strong></p>
<p>类的主动引用包括以下六种：</p>
<ul>
<li><strong>创建类的实例</strong> - 也就是 <code>new</code> 对象</li>
<li><strong>访问静态变量</strong> - 访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li><strong>访问静态方法</strong></li>
<li><strong>反射</strong> - 如<code>Class.forName(“com.shengsiyuan.Test”)</code></li>
<li><strong>初始化子类</strong> - 初始化某个类的子类，则其父类也会被初始化</li>
<li><strong>启动类</strong> - Java 虚拟机启动时被标明为启动类的类（<code>Java Test</code>），直接使用<code>java.exe</code>命令来运行某个主类</li>
</ul>
<p><strong>（2）被动引用</strong></p>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li><strong>通过子类引用父类的静态字段，不会导致子类初始化</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value); <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过数组定义来引用类，不会触发此类的初始化</strong>。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 <code>Object</code> 的子类，其中包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发<strong>定义常量的类的初始化</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h4 id="类初始化细节"><a href="#类初始化细节" class="headerlink" title="类初始化细节"></a>类初始化细节</h4><p>类初始化 <code>&lt;clinit&gt;()</code> 方法的细节：</p>
<ul>
<li>是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与类的构造函数（或者说实例构造器 <code>&lt;init&gt;()</code>）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 <code>&lt;clinit&gt;()</code> 方法运行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行结束。因此虚拟机中第一个执行 <code>&lt;clinit&gt;()</code> 方法的类肯定为 <code>java.lang.Object</code>。</li>
<li>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 输出结果是父类中的静态变量 A 的值，也就是 2。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;clinit&gt;()</code> 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 <code>&lt;clinit&gt;()</code> 方法。</li>
<li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</li>
<li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</li>
</ul>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p><code>ClassLoader</code> 即类加载器，负责将类加载到 JVM。在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。</p>
<p>JVM 加载 <code>class</code> 文件到内存有两种方式：</p>
<ul>
<li>隐式加载 - JVM 自动加载需要的类到内存中。</li>
<li>显示加载 - 通过使用 <code>ClassLoader</code> 来加载一个类到内存中。</li>
</ul>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>如何判断两个类是否相等：类本身相等，并且使用同一个类加载器进行加载。这是因为<strong>每一个 <code>ClassLoader</code> 都拥有一个独立的类名称空间</strong>。</p>
<p>这里的相等，包括类的 <code>Class</code> 对象的 <code>equals()</code> 方法、<code>isAssignableFrom()</code> 方法、<code>isInstance()</code> 方法的返回结果为 true，也包括使用 <code>instanceof</code> 关键字做对象所属关系判定结果为 true。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200617115936.png" alt="img"></p>
<h4 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h4><p><code>Bootstrap ClassLoader</code> ，即启动类加载器 ，<strong>负责加载 JVM 自身工作所需要的类</strong>。</p>
<p><strong><code>Bootstrap ClassLoader</code> 会将存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中</strong>。</p>
<p><code>Bootstrap ClassLoader</code> 是由 C++ 实现的，它完全由 JVM 自己控制的，启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 <code>null</code> 代替即可。</p>
<h4 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h4><p><code>ExtClassLoader</code>，即扩展类加载器，这个类加载器是由 <code>ExtClassLoader(sun.misc.Launcher\$ExtClassLoader)</code>实现的。</p>
<p><strong><code>ExtClassLoader</code> 负责将 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器</strong>。</p>
<h4 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h4><p><code>AppClassLoader</code>，即应用程序类加载器，这个类加载器是由 <code>AppClassLoader(sun.misc.Launcher\$AppClassLoader)</code> 实现的。由于这个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值，因此一般称为系统类加载器。</p>
<p><strong><code>AppClassLoader</code> 负责加载用户类路径（即 <code>classpath</code>）上所指定的类库</strong>，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>自定义类加载器可以做到如下几点：</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得 java class，例如数据库中和网络中。</li>
</ul>
<p>假设，我们需要自定义一个名为 <code>FileSystemClassLoader</code> 的类加载器，继承自 <code>java.lang.ClassLoader</code>，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（<code>.class</code> 文件），然后读取该文件内容，最后通过 <code>defineClass()</code> 方法来把这些字节代码转换成 <code>java.lang.Class</code> 类的实例。</p>
<p><code>java.lang.ClassLoader</code> 类的方法 <code>loadClass()</code> 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去覆写它，而是通过覆写 <code>findClass()</code> 方法。</p>
<p><code>ClassLoader</code> 常用的场景：</p>
<ul>
<li>容器 - 典型应用：Servlet 容器（如：Tomcat、Jetty）、udf （Mysql、Hive）等。加载解压 jar 包或 war 包后，加载其 Class 到指定的类加载器中运行（通常需要考虑空间隔离）。</li>
<li>热部署、热插拔 - 应用启动后，动态获得某个类信息，然后加载到 JVM 中工作。很多著名的容器软件、框架（如：Spring 等），都使用 <code>ClassLoader</code> 来实现自身的热部署。</li>
</ul>
<p>【示例】自定义一个类加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemClassLoader</span><span class="params">(String rootDir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>理解双亲委派之前，先让我们看一个示例。</p>
<p>【示例】寻找类加载示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    System.out.println(loader);</span><br><span class="line">    System.out.println(loader.getParent());</span><br><span class="line">    System.out.println(loader.getParent().getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader<span class="symbol">@18b4aac2</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader<span class="symbol">@19e1023e</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出，并没有获取到 <code>ExtClassLoader</code> 的父 Loader，原因是 <code>Bootstrap Loader</code>（引导类加载器）是用 C 语言实现的，找不到一个确定的返回父 Loader 的方式，于是就返回 null。</p>
<p>下图展示的类加载器之间的层次关系，称为类加载器的<strong>双亲委派模型（Parents Delegation Model）</strong>。<strong>该模型要求除了顶层的 Bootstrap ClassLoader 外，其余的类加载器都应有自己的父类加载器</strong>。<strong>这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现</strong>。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jmm-类加载-双亲委派.png" width="500" />
</div>

<p><strong>（1）工作过程</strong></p>
<p><strong>一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载</strong>。</p>
<p><strong>（2）好处</strong></p>
<p><strong>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系</strong>，从而使得基础类得到统一：</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证 Java 程序安全稳定运行</li>
</ul>
<p>例如： <code>java.lang.Object</code> 存放在 rt.jar 中，如果编写另外一个 <code>java.lang.Object</code> 的类并放到 <code>classpath</code> 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 <code>Object</code> 比在 <code>classpath</code> 中的 <code>Object</code> 优先级更高，因为 rt.jar 中的 <code>Object</code> 使用的是启动类加载器，而 <code>classpath</code> 中的 <code>Object</code> 使用的是应用程序类加载器。正因为 rt.jar 中的 <code>Object</code> 优先级更高，因为程序中所有的 <code>Object</code> 都是这个 <code>Object</code>。</p>
<p><strong>（3）实现</strong></p>
<p>以下是抽象类 <code>java.lang.ClassLoader</code> 的代码片段，其中的 <code>loadClass()</code> 方法运行过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器加载失败，会抛出 ClassNotFoundException</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【说明】</p>
<ul>
<li>先检查类是否已经加载过，如果没有则让父类加载器去加载。</li>
<li>当父类加载器加载失败时抛出 <code>ClassNotFoundException</code>，此时尝试自己去加载。</li>
</ul>
<h3 id="ClassLoader-参数"><a href="#ClassLoader-参数" class="headerlink" title="ClassLoader 参数"></a>ClassLoader 参数</h3><p>在生产环境上启动 java 应用时，通常会指定一些 <code>ClassLoader</code> 参数，以加载应用所需要的 lib：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar -classpath lib/*</span><br></pre></td></tr></table></figure>

<p><code>ClassLoader</code> 相关参数选项：</p>
<table>
<thead>
<tr>
<th>参数选项</th>
<th>ClassLoader 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xbootclasspath</code></td>
<td><code>Bootstrap ClassLoader</code></td>
<td>设置 <code>Bootstrap ClassLoader</code> 搜索路径。【不常用】</td>
</tr>
<tr>
<td><code>-Xbootclasspath/a</code></td>
<td><code>Bootstrap ClassLoader</code></td>
<td>把路径添加到已存在的 <code>Bootstrap ClassLoader</code> 搜索路径后面。【常用】</td>
</tr>
<tr>
<td><code>-Xbootclasspath/p</code></td>
<td><code>Bootstrap ClassLoader</code></td>
<td>把路径添加到已存在的 <code>Bootstrap ClassLoader</code> 搜索路径前面。【不常用】</td>
</tr>
<tr>
<td><code>-Djava.ext.dirs</code></td>
<td><code>ExtClassLoader</code></td>
<td>设置 <code>ExtClassLoader</code> 搜索路径。</td>
</tr>
<tr>
<td><code>-Djava.class.path</code> 或 <code>-cp</code> 或 <code>-classpath</code></td>
<td><code>AppClassLoader</code></td>
<td>设置 <code>AppClassLoader</code> 搜索路径。</td>
</tr>
</tbody></table>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h3 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h3><p>类加载有三种方式：</p>
<ul>
<li>命令行启动应用时候由 JVM 初始化加载</li>
<li>通过 <code>Class.forName()</code> 方法动态加载</li>
<li>通过 <code>ClassLoader.loadClass()</code> 方法动态加载</li>
</ul>
<p><strong><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 区别</strong></p>
<ul>
<li><code>Class.forName()</code> 将类的 <code>.class</code> 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 <code>static</code> 块；</li>
<li><code>ClassLoader.loadClass()</code> 只干一件事情，就是将 <code>.class</code> 文件加载到 jvm 中，不会执行 <code>static</code> 中的内容，只有在 <code>newInstance</code> 才会去执行 <code>static</code> 块。</li>
<li><code>Class.forName(name, initialize, loader)</code> 带参函数也可控制是否加载 <code>static</code> 块。并且只有调用了 <code>newInstance()</code> 方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h3 id="加载类错误"><a href="#加载类错误" class="headerlink" title="加载类错误"></a>加载类错误</h3><h4 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h4><p><code>ClassNotFoundException</code> 异常出镜率极高。**<code>ClassNotFoundException</code> 表示当前 <code>classpath</code> 下找不到指定类**。</p>
<p>常见问题原因：</p>
<ul>
<li>调用 <code>Class</code> 的 <code>forName()</code> 方法，未找到类。</li>
<li>调用 <code>ClassLoader</code> 中的 <code>loadClass()</code> 方法，未找到类。</li>
<li>调用 <code>ClassLoader</code> 中的 <code>findSystemClass()</code> 方法，未找到类。</li>
</ul>
<p>【示例】执行以下代码，会抛出 <code>ClassNotFoundException</code> 异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNotFoundExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;NotFound&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：检查 <code>classpath</code> 下有没有相应的 class 文件。</p>
<h4 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h4><p>常见问题原因：</p>
<ul>
<li>类依赖的 Class 或者 jar 不存在。</li>
<li>类文件存在，但是存在不同的域中。</li>
</ul>
<p>解决方法：现代 Java 项目，一般使用 <code>maven</code>、<code>gradle</code> 等构建工具管理项目，仔细检查找不到的类所在的 jar 包是否已添加为依赖。</p>
<h4 id="UnsatisfiedLinkError"><a href="#UnsatisfiedLinkError" class="headerlink" title="UnsatisfiedLinkError"></a>UnsatisfiedLinkError</h4><p>这个异常倒不是很常见，但是出错的话，通常是在 JVM 启动的时候如果一不小心将在 JVM 中的某个 lib 删除了，可能就会报这个错误了。</p>
<p>【示例】执行以下代码，会抛出 <code>UnsatisfiedLinkError</code> 错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsatisfiedLinkErrorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;NoLib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkErrorDemo</span>().nativeMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【输出】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: no NoLib in java.library.path</span><br><span class="line">	at java.lang.ClassLoader.loadLibrary(ClassLoader.java:<span class="number">1867</span>)</span><br><span class="line">	at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="number">870</span>)</span><br><span class="line">	at java.lang.System.loadLibrary(System.java:<span class="number">1122</span>)</span><br><span class="line">	at io.github.dunwu.javacore.jvm.classloader.exception.UnsatisfiedLinkErrorDemo.&lt;clinit&gt;(UnsatisfiedLinkErrorDemo.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h4 id="ClassCastException"><a href="#ClassCastException" class="headerlink" title="ClassCastException"></a>ClassCastException</h4><p><code>ClassCastException</code> 异常通常是在程序中强制类型转换失败时出现。</p>
<p>【示例】执行以下代码，会抛出 <code>ClassCastException</code> 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastExceptionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">EmptyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (EmptyClass) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmptyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【输出】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Object cannot be cast to io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo$EmptyClass</span><br><span class="line">	at io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo.main(ClassCastExceptionDemo.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100010301">深入拆解 Java 虚拟机</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e479c2cf265da575f4e65e4">一篇图文彻底弄懂类加载器与双亲委派机制</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html">Jvm 系列(一):Java 类的加载机制</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/18/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/blog/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/39/">39</a><a class="extend next" rel="next" href="/blog/page/20/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">46:19</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>




  <script src="/blog/js/third-party/pace.js"></script>

  




<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"7bfe66064a49a63bf2ff1331d43e50e7"}</script>
<script src="/blog/js/third-party/comments/gitalk.js"></script>

</body>
</html>
